<div class="notebook">
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse2"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=#taillpn-htmlse1"> tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch1"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<h3 class="sectionHead">
<span class="titlemark"> 1.1 
</span>
<a id="x11-90001.1">
</a> Some Simple Examples 
</h3>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> There are only three basic constructs in Prolog: facts, rules, and queries. A collection of facts and rules is called a knowledge base (or a database) and Prolog programming is all about writing knowledge bases. That is, Prolog programs simply 
<span class="cmti-10"> are 
</span> knowledge bases, collections of facts and rules which describe some collection of relationships that we find interesting. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> So how do we 
<span class="cmti-10"> use 
</span> a Prolog program? By posing queries. That is, by asking questions about the information stored in the knowledge base. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Now this probably sounds rather strange. It’s certainly not obvious that it has much to do with programming at all. After all, isn’t programming all about telling a computer what to do? But as we shall see, the Prolog way of programming makes a lot of sense, at least for certain tasks; for example, it is useful in computational linguistics and Artificial Intelligence (AI). But instead of saying more about Prolog in general terms, let’s jump right in and start writing some simple knowledge bases; this is not just the best way of learning Prolog, it’s the only way. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent">
</p>
</div>
<div class="nb-cell html" name="htm1">
<h4 class="likesubsectionHead">
<a id="x11-100001.1">
</a> Knowledge Base 1 
</h4>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Knowledge Base 1 (KB1) is simply a collection of facts. Facts are used to state things that are 
<span class="cmti-10"> unconditionally 
</span> true of some situation of interest. For example, we can state that Mia, Jody, and Yolanda are women, that Jody plays air guitar, and that a party is taking place, using the following five facts: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb1">
<a id="x11-10002r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  woman(mia). 
</span>
<br class="fancyvrb"/>
<a id="x11-10004r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  woman(jody). 
</span>
<br class="fancyvrb"/>
<a id="x11-10006r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  woman(yolanda). 
</span>
<br class="fancyvrb"/>
<a id="x11-10008r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  playsAirGuitar(jody). 
</span>
<br class="fancyvrb"/>
<a id="x11-10010r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  party. 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> This collection of facts is KB1. It is our first example of a Prolog program. Note that the names 
<span class="verb">
<span class="cmtt-10"> mia 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> jody 
</span>
</span> , and 
<span class="verb">
<span class="cmtt-10"> yolanda 
</span>
</span> , the properties 
<span class="verb">
<span class="cmtt-10"> woman 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> playsAirGuitar 
</span>
</span> , and the proposition 
<span class="verb">
<span class="cmtt-10"> party 
</span>
</span> have been written so that the first letter is in lower-case. This is important; we will see why a little later on. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> How can we use KB1? By posing queries. That is, by asking questions about the information KB1 contains. Here are some examples. We can ask Prolog whether Mia is a woman by posing the query: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb2">
<a id="x11-10012r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  woman(mia). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Prolog will answer 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb3">
<a id="x11-10014r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> for the obvious reason that this is one of the facts explicitly recorded in KB1. Incidentally, 
<span class="cmti-10"> we 
</span> don’t type in the 
<span class="verb">
<span class="cmtt-10"> ?- 
</span>
</span> . This symbol (or something like it, depending on the implementation of Prolog you are using) is the prompt symbol that the Prolog interpreter displays when it is waiting to evaluate a query. We just type in the actual query (for example 
<span class="verb">
<span class="cmtt-10"> woman(mia) 
</span>
</span> ) followed by 
<span class="verb">
<span class="cmtt-10"> . 
</span>
</span> (a full stop). The full stop is important. If you don’t type it, Prolog won’t start working on the query. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Similarly, we can ask whether Jody plays air guitar by posing the following query: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb4">
<a id="x11-10016r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  playsAirGuitar(jody). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Prolog will again answer yes, because this is one of the facts in KB1. However, suppose we ask whether Mia plays air guitar: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb5">
<a id="x11-10018r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  playsAirGuitar(mia). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> We will get the answer 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb6">
<a id="x11-10020r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  no 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Why? Well, first of all, this is not a fact in KB1. Moreover, KB1 is extremely simple, and contains no other information (such as the 
<span class="cmti-10"> rules 
</span> we will learn about shortly) which might help Prolog try to infer (that is, deduce) whether Mia plays air guitar. So Prolog correctly concludes that 
<span class="verb">
<span class="cmtt-10"> playsAirGuitar(mia) 
</span>
</span> does 
<span class="cmti-10"> not 
</span> follow from KB1. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Here are two important examples. First, suppose we pose the query: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb7">
<a id="x11-10022r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  playsAirGuitar(vincent). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Again Prolog answers no. Why? Well, this query is about a person (Vincent) that it has no information about, so it (correctly) concludes that 
<span class="verb">
<span class="cmtt-10"> playsAirGuitar(vincent) 
</span>
</span> cannot be deduced from the information in KB1. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Similarly, suppose we pose the query: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb8">
<a id="x11-10024r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  tatooed(jody). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Again Prolog will answer no. Why? Well, this query is about a property (being tatooed) that it has no information about, so once again it (correctly) concludes that the query cannot be deduced from the information in KB1. (Actually, some Prolog implementations will respond to this query with an error message, telling you that the predicate or procedure 
<span class="verb">
<span class="cmtt-10"> tatooed 
</span>
</span> is not defined; we will soon introduce the notion of predicates.) 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Needless to say, we can also make queries concerning propositions. For example, if we pose the query 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb9">
<a id="x11-10026r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  party. 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> then Prolog will respond 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb10">
<a id="x11-10028r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> and if we pose the query 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb11">
<a id="x11-10030r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  rockConcert. 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> then Prolog will respond 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb12">
<a id="x11-10032r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  no 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> exactly as we would expect. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent">
</p>
</div>
<div class="nb-cell html" name="htm1">
<h4 class="likesubsectionHead">
<a id="x11-110001.1">
</a> Knowledge Base 2 
</h4>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Here is KB2, our second knowledge base: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb13">
<a id="x11-11002r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  happy(yolanda). 
</span>
<br class="fancyvrb"/>
<a id="x11-11004r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  listens2Music(mia). 
</span>
<br class="fancyvrb"/>
<a id="x11-11006r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  listens2Music(yolanda):- 
</span>
<span class="cmtt-10">  happy(yolanda). 
</span>
<br class="fancyvrb"/>
<a id="x11-11008r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  playsAirGuitar(mia):- 
</span>
<span class="cmtt-10">  listens2Music(mia). 
</span>
<br class="fancyvrb"/>
<a id="x11-11010r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  playsAirGuitar(yolanda):- 
</span>
<span class="cmtt-10">  listens2Music(yolanda). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> There are two facts in KB2, 
<span class="verb">
<span class="cmtt-10"> listens2Music(mia) 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> happy(yolanda) 
</span>
</span> . The last three items it contains are rules. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Rules state information that is 
<span class="cmti-10"> conditionally 
</span> true of the situation of interest. For example, the first rule says that Yolanda listens to music 
<span class="cmti-10"> if 
</span> she is happy, and the last rule says that Yolanda plays air guitar 
<span class="cmti-10"> if 
</span> she listens to music. More generally, the 
<span class="verb">
<span class="cmtt-10"> :- 
</span>
</span> should be read as “if”, or “is implied by”. The part on the left hand side of the 
<span class="verb">
<span class="cmtt-10"> :- 
</span>
</span> is called the head of the rule, the part on the right hand side is called the body. So in general rules say: 
<span class="cmti-10"> if 
</span> the body of the rule is true, 
<span class="cmti-10"> then 
</span> the head of the rule is true too. And now for the key point: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="quote">
<!--l. 183-->
<p class="noindent">
<span class="cmti-10"> If a knowledge base contains a rule 
</span>
<span class="verb">
<span class="cmtt-10"> head 
</span>
<span class="cmtt-10">  :- 
</span>
<span class="cmtt-10">  body, 
</span>
</span>
<span class="cmti-10"> and Prolog knows 
</span>
<span class="cmti-10"> that 
</span>
<span class="verb">
<span class="cmtt-10"> body 
</span>
</span>
<span class="cmti-10"> follows from the information in the knowledge base, then 
</span>
<span class="cmti-10"> Prolog can infer 
</span>
<span class="verb">
<span class="cmtt-10"> head. 
</span>
</span>
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> This fundamental deduction step is called modus ponens. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Let’s consider an example. Suppose we ask whether Mia plays air guitar: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb14">
<a id="x11-11012r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  playsAirGuitar(mia). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Prolog will respond yes. Why? Well, although it can’t find 
<span class="verb">
<span class="cmtt-10"> playsAirGuitar(mia) 
</span>
</span> as a fact explicitly recorded in KB2, it can find the rule 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb15">
<a id="x11-11014r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  playsAirGuitar(mia):- 
</span>
<span class="cmtt-10">  listens2Music(mia). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Moreover, KB2 also contains the fact 
<span class="verb">
<span class="cmtt-10"> listens2Music(mia) 
</span>
</span> . Hence Prolog can use the rule of modus ponens to deduce that 
<span class="verb">
<span class="cmtt-10"> playsAirGuitar(mia) 
</span>
</span> . 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Our next example shows that Prolog can chain together uses of modus ponens. Suppose we ask: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb16">
<a id="x11-11016r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  playsAirGuitar(yolanda). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Prolog would respond yes. Why? Well, first of all, by using the fact 
<span class="verb">
<span class="cmtt-10"> happy(yolanda) 
</span>
</span> and the rule 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb17">
<a id="x11-11018r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  listens2Music(yolanda):- 
</span>
<span class="cmtt-10">  happy(yolanda). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Prolog can deduce the new fact 
<span class="verb">
<span class="cmtt-10"> listens2Music(yolanda) 
</span>
</span> . This new fact is not explicitly recorded in the knowledge base — it is only 
<span class="cmti-10"> implicitly 
</span> present (it is 
<span class="cmti-10"> inferred 
</span> knowledge). Nonetheless, Prolog can then use it just like an explicitly recorded fact. In particular, from this inferred fact and the rule 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb18">
<a id="x11-11020r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  playsAirGuitar(yolanda):- 
</span>
<span class="cmtt-10">  listens2Music(yolanda). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> it can deduce 
<span class="verb">
<span class="cmtt-10"> playsAirGuitar(yolanda) 
</span>
</span> , which is what we asked it. Summing up: any fact produced by an application of modus ponens can be used as input to further rules. By chaining together applications of modus ponens in this way, Prolog is able to retrieve information that logically follows from the rules and facts recorded in the knowledge base. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> The facts and rules contained in a knowledge base are called clauses. Thus KB2 contains five clauses, namely three rules and two facts. Another way of looking at KB2 is to say that it consists of three predicates (or procedures). The three predicates are: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb19">
<a id="x11-11022r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  listens2Music 
</span>
<br class="fancyvrb"/>
<a id="x11-11024r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  happy 
</span>
<br class="fancyvrb"/>
<a id="x11-11026r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  playsAirGuitar 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> The 
<span class="verb">
<span class="cmtt-10"> happy 
</span>
</span> predicate is defined using a single clause (a fact). The 
<span class="verb">
<span class="cmtt-10"> listens2Music 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> playsAirGuitar 
</span>
</span> predicates are each defined using two clauses (in one case, two rules, and in the other case, one rule and one fact). It is a good idea to think about Prolog programs in terms of the predicates they contain. In essence, the predicates are the concepts we find important, and the various clauses we write down concerning them are our attempts to pin down what they mean and how they are inter-related. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> One final remark. We can view a fact as a rule with an empty body. That is, we can think of facts as conditionals that do not have any antecedent conditions, or degenerate rules. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent">
</p>
</div>
<div class="nb-cell html" name="htm1">
<h4 class="likesubsectionHead">
<a id="x11-120001.1">
</a> Knowledge Base 3 
</h4>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> KB3, our third knowledge base, consists of five clauses: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb20">
<a id="x11-12002r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  happy(vincent). 
</span>
<br class="fancyvrb"/>
<a id="x11-12004r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  listens2Music(butch). 
</span>
<br class="fancyvrb"/>
<a id="x11-12006r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  playsAirGuitar(vincent):- 
</span>
<br class="fancyvrb"/>
<a id="x11-12008r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  listens2Music(vincent), 
</span>
<br class="fancyvrb"/>
<a id="x11-12010r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  happy(vincent). 
</span>
<br class="fancyvrb"/>
<a id="x11-12012r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  playsAirGuitar(butch):- 
</span>
<br class="fancyvrb"/>
<a id="x11-12014r7">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  happy(butch). 
</span>
<br class="fancyvrb"/>
<a id="x11-12016r8">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  playsAirGuitar(butch):- 
</span>
<br class="fancyvrb"/>
<a id="x11-12018r9">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  listens2Music(butch). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> There are two facts, 
<span class="verb">
<span class="cmtt-10"> happy(vincent) 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> listens2Music(butch) 
</span>
</span> , and three rules. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> KB3 defines the same three predicates as KB2 (namely 
<span class="verb">
<span class="cmtt-10"> happy 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> listens2Music 
</span>
</span> , and 
<span class="verb">
<span class="cmtt-10"> playsAirGuitar 
</span>
</span> ) but it defines them differently. In particular, the three rules that define the 
<span class="verb">
<span class="cmtt-10"> playsAirGuitar 
</span>
</span> predicate introduce some new ideas. First, note that the rule 
<a id="dx11-12019">
</a>
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb21">
<a id="x11-12021r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  playsAirGuitar(vincent):- 
</span>
<br class="fancyvrb"/>
<a id="x11-12023r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  listens2Music(vincent), 
</span>
<br class="fancyvrb"/>
<a id="x11-12025r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  happy(vincent). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> has 
<span class="cmti-10"> two 
</span> items in its body, or (to use the standard terminology) two goals. So, what exactly does this rule mean? The most important thing to note is the comma 
<span class="verb">
<span class="cmtt-10"> , 
</span>
</span> that separates the goal 
<span class="verb">
<span class="cmtt-10"> listens2Music(vincent) 
</span>
</span> and the goal 
<span class="verb">
<span class="cmtt-10"> happy(vincent) 
</span>
</span> in the rule’s body. This is the way logical conjunction is expressed in Prolog (that is, the comma means 
<span class="cmti-10"> and 
</span> ). So this rule says: “Vincent plays air guitar if he listens to music 
<span class="cmti-10"> and 
</span> he is happy”. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Thus, if we posed the query 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb22">
<a id="x11-12027r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  playsAirGuitar(vincent). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Prolog would answer no. This is because while KB3 contains 
<span class="verb">
<span class="cmtt-10"> happy(vincent) 
</span>
</span> , it does 
<span class="cmti-10"> not 
</span> explicitly contain the information 
<span class="verb">
<span class="cmtt-10"> listens2Music(vincent) 
</span>
</span> , and this fact cannot be deduced either. So KB3 only fulfils one of the two preconditions needed to establish 
<span class="verb">
<span class="cmtt-10"> playsAirGuitar(vincent) 
</span>
</span> , and our query fails. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Incidentally, the spacing used in this rule is irrelevant. For example, we could have written it as 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb23">
<a id="x11-12029r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  playsAirGuitar(vincent):- 
</span>
<span class="cmtt-10">  happy(vincent), 
</span>
<br class="fancyvrb"/>
<a id="x11-12031r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  listens2Music(vincent). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> and it would have meant exactly the same thing. Prolog offers us a lot of freedom in the way we set out knowledge bases, and we can take advantage of this to keep our code readable. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Next, note that KB3 contains two rules with 
<span class="cmti-10"> exactly 
</span> the same head, namely: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb24">
<a id="x11-12033r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  playsAirGuitar(butch):- 
</span>
<br class="fancyvrb"/>
<a id="x11-12035r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  happy(butch). 
</span>
<br class="fancyvrb"/>
<a id="x11-12037r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  playsAirGuitar(butch):- 
</span>
<br class="fancyvrb"/>
<a id="x11-12039r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  listens2Music(butch). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> This is a way of stating that Butch plays air guitar 
<span class="cmti-10"> either 
</span> if he listens to music, 
<span class="cmti-10"> or 
</span> if he is happy. That is, listing multiple rules with the same head is a way of expressing logical disjunction (that is, it is a way of saying 
<span class="cmti-10"> or 
</span> ). So if we posed the query 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb25">
<a id="x11-12041r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  playsAirGuitar(butch). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Prolog would answer yes. For although the first of these rules will not help (KB3 does not allow Prolog to conclude that 
<span class="verb">
<span class="cmtt-10"> happy(butch) 
</span>
</span> ), KB3 
<span class="cmti-10"> does 
</span> contain 
<span class="verb">
<span class="cmtt-10"> listens2Music(butch) 
</span>
</span> and this means Prolog can apply modus ponens using the rule 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb26">
<a id="x11-12043r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  playsAirGuitar(butch):- 
</span>
<br class="fancyvrb"/>
<a id="x11-12045r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  listens2Music(butch). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> to conclude that 
<span class="verb">
<span class="cmtt-10"> playsAirGuitar(butch) 
</span>
</span> . 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> There is another way of expressing disjunction in Prolog. We could replace the pair of rules given above by the single rule 
<a id="dx11-12046">
</a>
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb27">
<a id="x11-12048r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  playsAirGuitar(butch):- 
</span>
<br class="fancyvrb"/>
<a id="x11-12050r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  happy(butch); 
</span>
<br class="fancyvrb"/>
<a id="x11-12052r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  listens2Music(butch). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> That is, the semicolon 
<span class="verb">
<span class="cmtt-10"> ; 
</span>
</span> is the Prolog symbol for 
<span class="cmti-10"> or 
</span> , so this single rule means exactly the same thing as the previous pair of rules. Is it better to use multiple rules or the semicolon? That depends. On the one hand, extensive use of semicolon can make Prolog code hard to read. On the other hand, the semicolon is more efficient as Prolog only has to deal with one rule. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> It should now be clear that Prolog has something to do with logic: after all, the 
<span class="verb">
<span class="cmtt-10"> :- 
</span>
</span> means implication, the 
<span class="verb">
<span class="cmtt-10"> , 
</span>
</span> means conjunction, and the 
<span class="verb">
<span class="cmtt-10"> ; 
</span>
</span> means disjunction. (What about negation? That is a whole other story. We’ll be discussing it in Chapter  
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch10"> 10 
<!--tex4ht:ref: CHAPTER10 -->
</a> .) Moreover, we have seen that a standard logical proof rule (modus ponens) plays an important role in Prolog programming. So we are already beginning to understand why “Prolog” is short for “Programming with logic”. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent">
</p>
</div>
<div class="nb-cell html" name="htm1">
<h4 class="likesubsectionHead">
<a id="x11-130001.1">
</a> Knowledge Base 4 
</h4>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Here is KB4, our fourth knowledge base: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb28">
<a id="x11-13002r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  woman(mia). 
</span>
<br class="fancyvrb"/>
<a id="x11-13004r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  woman(jody). 
</span>
<br class="fancyvrb"/>
<a id="x11-13006r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  woman(yolanda). 
</span>
<br class="fancyvrb"/>
<a id="x11-13008r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x11-13010r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  loves(vincent,mia). 
</span>
<br class="fancyvrb"/>
<a id="x11-13012r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  loves(marsellus,mia). 
</span>
<br class="fancyvrb"/>
<a id="x11-13014r7">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  loves(pumpkin,honey_bunny). 
</span>
<br class="fancyvrb"/>
<a id="x11-13016r8">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  loves(honey_bunny,pumpkin). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Now, this is a pretty boring knowledge base. There are no rules, only a collection of facts. Ok, we are seeing a relation that has two names as arguments for the first time (namely the 
<span class="verb">
<span class="cmtt-10"> loves 
</span>
</span> relation), but, let’s face it, that’s a rather predictable idea. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> No, the novelty this time lies not in the knowledge base, it lies in the queries we are going to pose. In particular, 
<span class="cmti-10"> for the first time we’re going to make use of 
</span>
<span class="cmti-10"> variables 
</span> . Here’s an example: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb29">
<a id="x11-13018r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  woman(X). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> The 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> is a variable (in fact, any word beginning with an upper-case letter is a Prolog variable, which is why we had to be careful to use lower-case initial letters in our earlier examples). Now a variable isn’t a name, rather it’s a 
<span class="cmti-10"> placeholder 
</span> for information. That is, this query asks Prolog: tell me which of the individuals you know about is a woman. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Prolog answers this query by working its way through KB4, from top to bottom, trying to unify (or match) the expression 
<span class="verb">
<span class="cmtt-10"> woman(X) 
</span>
</span> with the information KB4 contains. Now the first item in the knowledge base is 
<span class="verb">
<span class="cmtt-10"> woman(mia) 
</span>
</span> . So, Prolog unifies 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> with 
<span class="verb">
<span class="cmtt-10"> mia 
</span>
</span> , thus making the query agree perfectly with this first item. (Incidentally, there’s a lot of different terminology for this process: we can also say that Prolog instantiates 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> to 
<span class="verb">
<span class="cmtt-10"> mia 
</span>
</span> , or that it binds 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> to 
<span class="verb">
<span class="cmtt-10"> mia 
</span>
</span> .) Prolog then reports back to us as follows: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb30">
<a id="x11-13020r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  mia 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> That is, it not only says that there is information about at least one woman in KB4, it actually tells us who she is. It didn’t just say yes, it actually gave us the variable binding (or variable instantiation) that led to success. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> But that’s not the end of the story. The whole point of variables is that they can stand for, or unify with, different things. And there is information about other women in the knowledge base. We can access this information by typing a semicolon: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb31">
<a id="x11-13022r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  mia 
</span>
<span class="cmtt-10">  ; 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Remember that 
<span class="verb">
<span class="cmtt-10"> ; 
</span>
</span> means 
<span class="cmti-10"> or 
</span> , so this query means: 
<span class="cmti-10"> are there any alternatives 
</span> ? So Prolog begins working through the knowledge base again (it remembers where it got up to last time and starts from there) and sees that if it unifies 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> with 
<span class="verb">
<span class="cmtt-10"> jody 
</span>
</span> , then the query agrees perfectly with the second entry in the knowledge base. So it responds: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb32">
<a id="x11-13024r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  mia 
</span>
<span class="cmtt-10">  ; 
</span>
<br class="fancyvrb"/>
<a id="x11-13026r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  jody 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> It’s telling us that there is information about a second woman in KB4, and (once again) it actually gives us the value that led to success. And of course, if we press 
<span class="verb">
<span class="cmtt-10"> ; 
</span>
</span> a second time, Prolog returns the answer 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb33">
<a id="x11-13028r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  mia 
</span>
<span class="cmtt-10">  ; 
</span>
<br class="fancyvrb"/>
<a id="x11-13030r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  jody 
</span>
<span class="cmtt-10">  ; 
</span>
<br class="fancyvrb"/>
<a id="x11-13032r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  yolanda 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> But what happens if we press 
<span class="verb">
<span class="cmtt-10"> ; 
</span>
</span> a 
<span class="cmti-10"> third 
</span> time? Prolog responds no. No other unifications are possible. There are no other facts starting with the symbol 
<span class="verb">
<span class="cmtt-10"> woman 
</span>
</span> . The last four entries in the knowledge base concern the 
<span class="verb">
<span class="cmtt-10"> love 
</span>
</span> relation, and there is no way that such entries can be unified with a query of the form 
<span class="verb">
<span class="cmtt-10"> woman(X) 
</span>
</span> . 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Let’s try a more complicated query, namely 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb34">
<a id="x11-13034r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  loves(marsellus,X), 
</span>
<span class="cmtt-10">  woman(X). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Now, remember that 
<span class="verb">
<span class="cmtt-10"> , 
</span>
</span> means 
<span class="cmti-10"> and 
</span> , so this query says: 
<span class="cmti-10"> is there any individual 
</span>
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span>
<span class="cmti-10"> such that 
</span>
<span class="cmti-10"> Marsellus loves 
</span>
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span>
<span class="cmti-10"> and 
</span>
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span>
<span class="cmti-10"> is a woman 
</span> ? If you look at the knowledge base you’ll see that there is: Mia is a woman (fact 1) and Marsellus loves Mia (fact 5). And in fact, Prolog is capable of working this out. That is, it can search through the knowledge base and work out that if it unifies 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> with Mia, then both conjuncts of the query are satisfied (we’ll learn in the following chapter how Prolog does this). So Prolog returns the answer 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb35">
<a id="x11-13036r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  mia 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> The business of unifying variables with information in the knowledge base is the heart of Prolog. As we’ll learn, there are many interesting ideas in Prolog — but when you get right down to it, it’s Prolog’s ability to perform unification and return the values of the variable bindings to us that is crucial. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent">
</p>
</div>
<div class="nb-cell html" name="htm1">
<h4 class="likesubsectionHead">
<a id="x11-140001.1">
</a> Knowledge Base 5 
</h4>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Well, we’ve introduced variables, but so far we’ve only used them in queries. But variables not only 
<span class="cmti-10"> can 
</span> be used in knowledge bases, it’s only when we start to do so that we can write truly interesting programs. Here’s a simple example, the knowledge base KB5: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb36">
<a id="x11-14002r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  loves(vincent,mia). 
</span>
<br class="fancyvrb"/>
<a id="x11-14004r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  loves(marsellus,mia). 
</span>
<br class="fancyvrb"/>
<a id="x11-14006r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  loves(pumpkin,honey_bunny). 
</span>
<br class="fancyvrb"/>
<a id="x11-14008r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  loves(honey_bunny,pumpkin). 
</span>
<br class="fancyvrb"/>
<a id="x11-14010r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x11-14012r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  jealous(X,Y):- 
</span>
<span class="cmtt-10">  loves(X,Z), 
</span>
<span class="cmtt-10">  loves(Y,Z). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> KB5 contains four facts about the 
<span class="verb">
<span class="cmtt-10"> loves 
</span>
</span> relation and one rule. (Incidentally, the blank line between the facts and the rule has no meaning: it’s simply there to increase the readability. As we said earlier, Prolog gives us a great deal of freedom in the way we format knowledge bases.) But this rule is by far the most interesting one we have seen so far: it contains three variables (note that 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> Y 
</span>
</span> , and 
<span class="verb">
<span class="cmtt-10"> Z 
</span>
</span> are all upper-case letters). What does it say? 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> In effect, it is defining a concept of jealousy. It says that an individual 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> will be jealous of an individual 
<span class="verb">
<span class="cmtt-10"> Y 
</span>
</span> if there is some individual 
<span class="verb">
<span class="cmtt-10"> Z 
</span>
</span> that 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> loves, and 
<span class="verb">
<span class="cmtt-10"> Y 
</span>
</span> loves that same individual 
<span class="verb">
<span class="cmtt-10"> Z 
</span>
</span> too. (Ok, so jealousy isn’t as straightforward as this in the real world.) The key thing to note is that this is a 
<span class="cmti-10"> general 
</span> statement: it is not stated in terms of 
<span class="verb">
<span class="cmtt-10"> mia 
</span>
</span> , or 
<span class="verb">
<span class="cmtt-10"> pumpkin 
</span>
</span> , or anyone in particular — it’s a conditional statement about 
<span class="cmti-10"> everybody 
</span> in our little world. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Suppose we pose the query: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb37">
<a id="x11-14014r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  jealous(marsellus,W). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> This query asks: can you find an individual 
<span class="verb">
<span class="cmtt-10"> W 
</span>
</span> such that Marsellus is jealous of 
<span class="verb">
<span class="cmtt-10"> W 
</span>
</span> ? Vincent is such an individual. If you check the definition of jealousy, you’ll see that Marsellus must be jealous of Vincent, because they both love the same woman, namely Mia. So Prolog will return the value 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb38">
<a id="x11-14016r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  W 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  vincent 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Now some questions for 
<span class="cmti-10"> you 
</span> . First, are there any other jealous people in KB5? Furthermore, suppose we wanted Prolog to tell us about all the jealous people: what query would we pose? Do any of the answers surprise you? Do any seem silly? 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse2"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse1"> front 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch1"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse3"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse1"> prev 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse1"> prev-tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=#taillpn-htmlse2"> tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch1"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<h3 class="sectionHead">
<span class="titlemark"> 1.2 
</span>
<a id="x12-150001.2">
</a> Prolog Syntax 
</h3>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Now that we’ve got some idea of what Prolog does, it’s time to go back to the beginning and work through the details more carefully. Let’s start by asking a very basic question: we’ve seen all kinds of expressions (for example 
<span class="verb">
<span class="cmtt-10"> jody 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> playsAirGuitar(mia) 
</span>
</span> , and 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> ) in our Prolog programs, but these have just been examples. It’s time for precision: exactly what are facts, rules, and queries built out of? 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> The answer is terms, and there are four kinds of term in Prolog: atoms, numbers, variables, and complex terms (or structures). Atoms and numbers are lumped together under the heading constants, and constants and variables together make up the simple terms of Prolog. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Let’s take a closer look. To make things crystal clear, let’s first be precise about the basic characters (that is, symbols) at our disposal. The 
<span class="cmti-10"> upper-case letters 
</span> are 
<span class="verb">
<span class="cmtt-10"> A 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> B 
</span>
</span> ,…, 
<span class="verb">
<span class="cmtt-10"> Z 
</span>
</span> ; the 
<span class="cmti-10"> lower-case letters 
</span> are 
<span class="verb">
<span class="cmtt-10"> a 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> b 
</span>
</span> ,…, 
<span class="verb">
<span class="cmtt-10"> z 
</span>
</span> ; the 
<span class="cmti-10"> digits 
</span> are 
<span class="verb">
<span class="cmtt-10"> 0 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> 1 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> 2 
</span>
</span> ,…, 
<span class="verb">
<span class="cmtt-10"> 9 
</span>
</span> . In addition we have the 
<span class="verb">
<span class="cmtt-10"> _ 
</span>
</span> symbol, which is called underscore, and some 
<span class="cmti-10"> special characters 
</span> , which include characters such as 
<span class="verb">
<span class="cmtt-10"> + 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> - 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> * 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> / 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> &lt; 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> &gt; 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> = 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> : 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> . 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> &amp; 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> ~ 
</span>
</span> . The blank 
<span class="cmti-10"> space 
</span> is also a character, but a rather unusual one, being invisible. A string is an unbroken sequence of characters. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent">
</p>
</div>
<div class="nb-cell html" name="htm1">
<h4 class="likesubsectionHead">
<a id="x12-160001.2">
</a> Atoms 
</h4>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> An atom is either: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<ol class="enumerate1">
<li class="enumerate" id="x12-16002x1"> A string of characters made up of upper-case letters, lower-case letters, digits, and the underscore character, that begins with a lower-case letter. Here are some examples: 
<span class="verb">
<span class="cmtt-10"> butch 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> big_kahuna_burger 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> listens2Music 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> playsAirGuitar 
</span>
</span> . 
</li>
<li class="enumerate" id="x12-16004x2"> An arbitrary sequence of characters enclosed in single quotes. For example ’ 
<span class="verb">
<span class="cmtt-10"> Vincent 
</span>
</span> ’, ’ 
<span class="verb">
<span class="cmtt-10"> The 
</span>
<span class="cmtt-10">  Gimp 
</span>
</span> ’, ’ 
<span class="verb">
<span class="cmtt-10"> Five_Dollar_Shake 
</span>
</span> ’, ’ 
<span class="verb">
<span class="cmtt-10"> &amp;^%&amp;#@$ 
</span>
<span class="cmtt-10">  &amp;* 
</span>
</span> ’, and ’ 
<span class="verb">
<span class="cmtt-10">   
</span>
</span> ’. The sequence of characters between the single quotes is called the atom name. Note that we are allowed to use spaces in such atoms; in fact, a common reason for using single quotes is so we can do precisely that. 
</li>
<li class="enumerate" id="x12-16006x3"> A string of special characters. Here are some examples: 
<span class="verb">
<span class="cmtt-10"> @= 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> ====&gt; 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> ; 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> :- 
</span>
</span> are all atoms. As we have seen, some of these atoms, such as 
<span class="verb">
<span class="cmtt-10"> ; 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> :- 
</span>
</span> have a pre-defined meaning. 
</li>
</ol>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent">
</p>
</div>
<div class="nb-cell html" name="htm1">
<h4 class="likesubsectionHead">
<a id="x12-170001.2">
</a> Numbers 
</h4>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Real numbers aren’t particularly important in typical Prolog applications. So although most Prolog implementations do support floating point numbers or floats (that is, representations of real numbers such as 1657.3087 or 
<span class="cmmi-10"> π 
</span> ) we say little about them in this book. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> But integers (that is: …,-2, -1, 0, 1, 2, 3,…) are useful for such tasks as counting the elements of a list, and we’ll discuss how to manipulate them in Chapter  
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch5"> 5 
<!--tex4ht:ref: CHAPTER5 -->
</a> . Their Prolog syntax is the obvious one: 
<span class="verb">
<span class="cmtt-10"> 23 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> 1001 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> 0 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> -365 
</span>
</span> , and so on. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent">
</p>
</div>
<div class="nb-cell html" name="htm1">
<h4 class="likesubsectionHead">
<a id="x12-180001.2">
</a> Variables 
</h4>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> A variable is a string of upper-case letters, lower-case letters, digits and underscore characters that starts 
<span class="cmti-10"> either 
</span> with an upper-case letter 
<span class="cmti-10"> or 
</span> with an underscore. For example, 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> Y 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> Variable 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> _tag 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> X_526 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> List 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> List24 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> _head 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> Tail 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> _input 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> Output 
</span>
</span> are all Prolog variables. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> The variable 
<span class="verb">
<span class="cmtt-10"> _ 
</span>
</span> (that is, a single underscore character) is rather special. It’s called the 
<span class="cmti-10"> anonymous variable 
</span> , and we discuss it in Chapter  
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch4"> 4 
<!--tex4ht:ref: CHAPTER4 -->
</a> . 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent">
</p>
</div>
<div class="nb-cell html" name="htm1">
<h4 class="likesubsectionHead">
<a id="x12-190001.2">
</a> Complex terms 
</h4>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Constants, numbers, and variables are the building blocks: now we need to know how to fit them together to make complex terms. Recall that complex terms are often called structures. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Complex terms are build out of a functor followed by a sequence of arguments. The arguments are put in ordinary parentheses, separated by commas, and placed after the functor. Note that the functor has to be directly followed by the parenthesis; you can’t have a space between the functor and the parenthesis enclosing the arguments. The functor 
<span class="cmti-10"> must 
</span> be an atom. That is, variables 
<span class="cmti-10"> cannot 
</span> be used as functors. On the other hand, arguments can be any kind of term. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Now, we’ve already seen lots of examples of complex terms when we looked at the knowledge bases KB1 to KB5. For example, 
<span class="verb">
<span class="cmtt-10"> playsAirGuitar(jody) 
</span>
</span> is a complex term: its functor is 
<span class="verb">
<span class="cmtt-10"> playsAirGuitar 
</span>
</span> and its argument is 
<span class="verb">
<span class="cmtt-10"> jody 
</span>
</span> . Other examples are 
<span class="verb">
<span class="cmtt-10"> loves(vincent,mia) 
</span>
</span> and, to give an example containing a variable, 
<span class="verb">
<span class="cmtt-10"> jealous(marsellus,W) 
</span>
</span> . 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> But the definition allows for more complex terms than this. In fact, it allows us to keep nesting complex terms inside complex terms indefinitely (that is, it is allows recursive structure). For example 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb39">
<a id="x12-19002r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  hide(X,father(father(father(butch)))) 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> is a perfectly acceptable complex term. Its functor is 
<span class="verb">
<span class="cmtt-10"> hide 
</span>
</span> , and it has two arguments: the variable 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> , and the complex term 
<span class="verb">
<span class="cmtt-10"> father(father(father(butch))) 
</span>
</span> . This complex term has 
<span class="verb">
<span class="cmtt-10"> father 
</span>
</span> as its functor, and another complex term, namely 
<span class="verb">
<span class="cmtt-10"> father(father(butch)) 
</span>
</span> , as its sole argument. And the argument of this complex term, namely 
<span class="verb">
<span class="cmtt-10"> father(butch) 
</span>
</span> , is also complex. But then the nesting bottoms out, for the argument here is the constant 
<span class="verb">
<span class="cmtt-10"> butch 
</span>
</span> . 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> As we shall see, such nested (or recursively structured) terms enable us to represent many problems naturally. In fact the interplay between recursive term structure and variable unification is the source of much of Prolog’s power. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> The number of arguments that a complex term has is called its arity. For example, 
<span class="verb">
<span class="cmtt-10"> woman(mia) 
</span>
</span> is a complex term of arity 1, and 
<span class="verb">
<span class="cmtt-10"> loves(vincent,mia) 
</span>
</span> is a complex term of arity 2. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Arity is important to Prolog. Prolog would be quite happy for us to define two predicates with the same functor but with a different number of arguments. For example, we are free to define a knowledge base that defines a two-place predicate 
<span class="verb">
<span class="cmtt-10"> love 
</span>
</span> (this might contain such facts as 
<span class="verb">
<span class="cmtt-10"> love(vincent,mia) 
</span>
</span> ), and also a three-place 
<span class="verb">
<span class="cmtt-10"> love 
</span>
</span> predicate (which might contain such facts as 
<span class="verb">
<span class="cmtt-10"> love(vincent,marsellus,mia) 
</span>
</span> ). However, if we did this, Prolog would treat the two-place 
<span class="verb">
<span class="cmtt-10"> love 
</span>
</span> and the three-place 
<span class="verb">
<span class="cmtt-10"> love 
</span>
</span> as different predicates. Later in the book (for example, when we introduce accumulators in Chapter 5) we shall see that it can be useful to define two predicates with the same functor but different arity. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> When we need to talk about predicates and how we intend to use them (for example, in documentation) it is usual to use a suffix 
<span class="verb">
<span class="cmtt-10"> / 
</span>
</span> followed by a number to indicate the predicate’s arity. To return to KB2, instead of saying that it defines predicates 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb40">
<a id="x12-19004r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  listens2Music 
</span>
<br class="fancyvrb"/>
<a id="x12-19006r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  happy 
</span>
<br class="fancyvrb"/>
<a id="x12-19008r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  playsAirGuitar 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> we should really say that it defines predicates 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb41">
<a id="x12-19010r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  listens2Music/1 
</span>
<br class="fancyvrb"/>
<a id="x12-19012r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  happy/1 
</span>
<br class="fancyvrb"/>
<a id="x12-19014r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  playsAirGuitar/1 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> And Prolog can’t get confused about a knowledge base containing the two different love predicates, for it regards the 
<span class="verb">
<span class="cmtt-10"> love/2 
</span>
</span> predicate and the 
<span class="verb">
<span class="cmtt-10"> love/3 
</span>
</span> predicate as distinct. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse3"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse1"> prev 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse1"> prev-tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse2"> front 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch1"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse4"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse2"> prev 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse2"> prev-tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=#taillpn-htmlse3"> tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch1"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<h3 class="sectionHead">
<span class="titlemark"> 1.3 
</span>
<a id="x13-200001.3">
</a> <strong>Exercise</strong>s 
</h3>
</div>
<div class="nb-cell html" name="htm1">
<div class="newtheorem">
<!--l. 712-->
<p class="noindent">
<span class="head">
<span class="cmbx-10"> <strong>Exercise</strong>
</span>
<span class="cmbx-10">  1.1 
</span>
</span>
<a id="x13-200011">
</a>
<span class="cmti-10"> Which of the following sequences of characters are atoms, which 
</span>
<span class="cmti-10"> are variables, and which are neither? 
</span>
</p>
<!--l. 715-->
<p class="indent">
</p>
<ol class="enumerate1">
<li class="enumerate" id="x13-20003x1">
<span class="verb">
<span class="cmtt-10"> vINCENT 
</span>
</span>
</li>
<li class="enumerate" id="x13-20005x2">
<span class="verb">
<span class="cmtt-10"> Footmassage 
</span>
</span>
</li>
<li class="enumerate" id="x13-20007x3">
<span class="verb">
<span class="cmtt-10"> variable23 
</span>
</span>
</li>
<li class="enumerate" id="x13-20009x4">
<span class="verb">
<span class="cmtt-10"> Variable2000 
</span>
</span>
</li>
<li class="enumerate" id="x13-20011x5">
<span class="verb">
<span class="cmtt-10"> big_kahuna_burger 
</span>
</span>
</li>
<li class="enumerate" id="x13-20013x6">
<span class="verb">
<span class="cmtt-10"> ’big 
</span>
<span class="cmtt-10">  kahuna 
</span>
<span class="cmtt-10">  burger’ 
</span>
</span>
</li>
<li class="enumerate" id="x13-20015x7">
<span class="verb">
<span class="cmtt-10"> big 
</span>
<span class="cmtt-10">  kahuna 
</span>
<span class="cmtt-10">  burger 
</span>
</span>
</li>
<li class="enumerate" id="x13-20017x8">
<span class="verb">
<span class="cmtt-10"> ’Jules’ 
</span>
</span>
</li>
<li class="enumerate" id="x13-20019x9">
<span class="verb">
<span class="cmtt-10"> _Jules 
</span>
</span>
</li>
<li class="enumerate" id="x13-20021x10">
<span class="verb">
<span class="cmtt-10"> ’_Jules’ 
</span>
</span>
</li>
</ol>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="newtheorem">
<!--l. 729-->
<p class="noindent">
<span class="head">
<span class="cmbx-10"> <strong>Exercise</strong>
</span>
<span class="cmbx-10">  1.2 
</span>
</span>
<a id="x13-200222">
</a>
<span class="cmti-10"> Which of the following sequences of characters are atoms, which 
</span>
<span class="cmti-10"> are variables, which are complex terms, and which are not terms at all? Give 
</span>
<span class="cmti-10"> the functor and arity of each complex term. 
</span>
</p>
<!--l. 734-->
<p class="indent">
</p>
<ol class="enumerate1">
<li class="enumerate" id="x13-20024x1">
<span class="verb">
<span class="cmtt-10"> loves(Vincent,mia) 
</span>
</span>
</li>
<li class="enumerate" id="x13-20026x2">
<span class="verb">
<span class="cmtt-10"> ’loves(Vincent,mia)’ 
</span>
</span>
</li>
<li class="enumerate" id="x13-20028x3">
<span class="verb">
<span class="cmtt-10"> Butch(boxer) 
</span>
</span>
</li>
<li class="enumerate" id="x13-20030x4">
<span class="verb">
<span class="cmtt-10"> boxer(Butch) 
</span>
</span>
</li>
<li class="enumerate" id="x13-20032x5">
<span class="verb">
<span class="cmtt-10"> and(big(burger),kahuna(burger)) 
</span>
</span>
</li>
<li class="enumerate" id="x13-20034x6">
<span class="verb">
<span class="cmtt-10"> and(big(X),kahuna(X)) 
</span>
</span>
</li>
<li class="enumerate" id="x13-20036x7">
<span class="verb">
<span class="cmtt-10"> _and(big(X),kahuna(X)) 
</span>
</span>
</li>
<li class="enumerate" id="x13-20038x8">
<span class="verb">
<span class="cmtt-10"> (Butch 
</span>
<span class="cmtt-10">  kills 
</span>
<span class="cmtt-10">  Vincent) 
</span>
</span>
</li>
<li class="enumerate" id="x13-20040x9">
<span class="verb">
<span class="cmtt-10"> kills(Butch 
</span>
<span class="cmtt-10">  Vincent) 
</span>
</span>
</li>
<li class="enumerate" id="x13-20042x10">
<span class="verb">
<span class="cmtt-10"> kills(Butch,Vincent 
</span>
</span>
</li>
</ol>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="newtheorem">
<!--l. 748-->
<p class="noindent">
<span class="head">
<span class="cmbx-10"> <strong>Exercise</strong>
</span>
<span class="cmbx-10">  1.3 
</span>
</span>
<a id="x13-200433">
</a>
<span class="cmti-10"> How many facts, rules, clauses, and predicates are there in the 
</span>
<span class="cmti-10"> following knowledge base? What are the heads of the rules, and what are the 
</span>
<span class="cmti-10"> goals they contain? 
</span>
</p>
<!--l. 752-->
<p class="indent">
</p>
<div class="fancyvrb" id="fancyvrb42">
<a id="x13-20045r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  woman(vincent). 
</span>
<br class="fancyvrb"/>
<a id="x13-20047r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  woman(mia). 
</span>
<br class="fancyvrb"/>
<a id="x13-20049r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  man(jules). 
</span>
<br class="fancyvrb"/>
<a id="x13-20051r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  person(X):- 
</span>
<span class="cmtt-10">  man(X); 
</span>
<span class="cmtt-10">  woman(X). 
</span>
<br class="fancyvrb"/>
<a id="x13-20053r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  loves(X,Y):- 
</span>
<span class="cmtt-10">  father(X,Y). 
</span>
<br class="fancyvrb"/>
<a id="x13-20055r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  father(Y,Z):- 
</span>
<span class="cmtt-10">  man(Y), 
</span>
<span class="cmtt-10">  son(Z,Y). 
</span>
<br class="fancyvrb"/>
<a id="x13-20057r7">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  father(Y,Z):- 
</span>
<span class="cmtt-10">  man(Y), 
</span>
<span class="cmtt-10">  daughter(Z,Y). 
</span>
</div>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="newtheorem">
<!--l. 763-->
<p class="noindent">
<span class="head">
<span class="cmbx-10"> <strong>Exercise</strong>
</span>
<span class="cmbx-10">  1.4 
</span>
</span>
<a id="x13-200584">
</a>
<span class="cmti-10"> Represent the following in Prolog: 
</span>
</p>
<!--l. 765-->
<p class="indent">
</p>
<ol class="enumerate1">
<li class="enumerate" id="x13-20060x1">
<span class="cmti-10"> Butch is a killer. 
</span>
</li>
<li class="enumerate" id="x13-20062x2">
<span class="cmti-10"> Mia and Marsellus are married. 
</span>
</li>
<li class="enumerate" id="x13-20064x3">
<span class="cmti-10"> Zed is dead. 
</span>
</li>
<li class="enumerate" id="x13-20066x4">
<span class="cmti-10"> Marsellus kills everyone who gives Mia a footmassage. 
</span>
</li>
<li class="enumerate" id="x13-20068x5">
<span class="cmti-10"> Mia loves everyone who is a good dancer. 
</span>
</li>
<li class="enumerate" id="x13-20070x6">
<span class="cmti-10"> Jules eats anything that is nutritious or tasty. 
</span>
</li>
</ol>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="newtheorem">
<!--l. 775-->
<p class="noindent">
<span class="head">
<span class="cmbx-10"> <strong>Exercise</strong>
</span>
<span class="cmbx-10">  1.5 
</span>
</span>
<a id="x13-200715">
</a>
<span class="cmti-10"> Suppose we are working with the following knowledge base: 
</span>
</p>
<!--l. 777-->
<p class="indent">
</p>
<div class="fancyvrb" id="fancyvrb43">
<a id="x13-20073r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  wizard(ron). 
</span>
<br class="fancyvrb"/>
<a id="x13-20075r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  hasWand(harry). 
</span>
<br class="fancyvrb"/>
<a id="x13-20077r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  quidditchPlayer(harry). 
</span>
<br class="fancyvrb"/>
<a id="x13-20079r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  wizard(X):- 
</span>
<span class="cmtt-10">  hasBroom(X), 
</span>
<span class="cmtt-10">  hasWand(X). 
</span>
<br class="fancyvrb"/>
<a id="x13-20081r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  hasBroom(X):- 
</span>
<span class="cmtt-10">  quidditchPlayer(X). 
</span>
</div>
<!--l. 786-->
<p class="indent">
<span class="cmti-10"> How does Prolog respond to the following queries? 
</span>
</p>
<ol class="enumerate1">
<li class="enumerate" id="x13-20083x1">
<span class="verb">
<span class="cmtt-10"> wizard(ron). 
</span>
</span>
</li>
<li class="enumerate" id="x13-20085x2">
<span class="verb">
<span class="cmtt-10"> witch(ron). 
</span>
</span>
</li>
<li class="enumerate" id="x13-20087x3">
<span class="verb">
<span class="cmtt-10"> wizard(hermione). 
</span>
</span>
</li>
<li class="enumerate" id="x13-20089x4">
<span class="verb">
<span class="cmtt-10"> witch(hermione). 
</span>
</span>
</li>
<li class="enumerate" id="x13-20091x5">
<span class="verb">
<span class="cmtt-10"> wizard(harry). 
</span>
</span>
</li>
<li class="enumerate" id="x13-20093x6">
<span class="verb">
<span class="cmtt-10"> wizard(Y). 
</span>
</span>
</li>
<li class="enumerate" id="x13-20095x7">
<span class="verb">
<span class="cmtt-10"> witch(Y). 
</span>
</span>
</li>
</ol>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse4"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse2"> prev 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse2"> prev-tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse3"> front 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch1"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse3"> prev 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse3"> prev-tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=#taillpn-htmlse4"> tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch1"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<h3 class="sectionHead">
<span class="titlemark"> 1.4 
</span>
<a id="x14-210001.4">
</a> Practical Session 
</h3>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Don’t be fooled by the fact that the description of the practical sessions is shorter than the text you have just read; the practical part is definitely the most important. Yes, you need to read the text and do the exercises, but that’s not enough to become a Prolog programmer. To really master the language you need to sit down in front of a computer and play with Prolog — a lot! 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> The goal of the first practical session is for you to become familiar with the basics of how to create and run simple Prolog programs. Now, because there are many different implementations of Prolog, and different operating systems you can run them under, we can’t be too specific here. Rather, what we’ll do is describe in very general terms what is involved in running Prolog, list the practical skills you need to master, and suggest some things for you to do. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> The simplest way to run a Prolog program is as follows. You have a file with your Prolog program in it (for example, you may have a file 
<span class="verb">
<span class="cmtt-10"> kb2.pl 
</span>
</span> which contains the knowledge base KB2). You then start Prolog. Prolog will display its prompt, something like 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb44">
<a id="x14-21002r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> which indicates that it is ready to accept a query. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Now, at this stage, Prolog knows absolutely nothing about KB2 (or indeed anything else). To see this, type in the command 
<span class="verb">
<span class="cmtt-10"> listing 
</span>
</span> , 
<a id="dx14-21003">
</a> followed by a full stop, and hit return. That is, type 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb45">
<a id="x14-21005r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  listing. 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> and press the return key. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Now, the listing command is a special built-in Prolog predicate that instructs Prolog to display the contents of the current knowledge base. But we haven’t yet told Prolog about any knowledge bases, so it will just say 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb46">
<a id="x14-21007r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> This is a correct answer: as yet Prolog knows nothing — so it correctly displays all this nothing and says 
<span class="verb">
<span class="cmtt-10"> yes 
</span>
</span> . Actually, with more sophisticated Prolog implementations you may get a little more (for example, the names of libraries that have been loaded; libraries are discussed in Chapter  
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch12"> 12 
<!--tex4ht:ref: CHAPTER12 -->
</a> ) but, one way or another, you will receive what is essentially an “I know nothing about any knowledge bases!” answer. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> So let’s tell Prolog about KB2. Assuming that you’ve stored KB2 in the file 
<span class="verb">
<span class="cmtt-10"> kb2.pl 
</span>
</span> , and that this file is in the directory where you’re running Prolog, all you have to type is 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb47">
<a id="x14-21009r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  [kb2]. 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> This tells Prolog to consult the file 
<span class="verb">
<span class="cmtt-10"> kb2.pl 
</span>
</span> , and load the contents as its new knowledge base. Assuming that 
<span class="verb">
<span class="cmtt-10"> kb2.pl 
</span>
</span> contains no typos, Prolog will read it in, maybe print out a message saying that it is consulting this file, and then answer: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb48">
<a id="x14-21011r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Incidentally, it is common to store Prolog code in files with a 
<span class="verb">
<span class="cmtt-10"> .pl 
</span>
</span> suffix. It’s an indication of what the file contains (namely Prolog code) and with some Prolog implementations you don’t actually have to type in the 
<span class="verb">
<span class="cmtt-10"> .pl 
</span>
</span> suffix when you consult a file. Nice — but there is a drawback. Files containing Perl scripts usually have a 
<span class="verb">
<span class="cmtt-10"> .pl 
</span>
</span> suffix too, and nowadays there are a lot of Perl scripts in use, so this can cause confusion. C’est la vie. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> If the above doesn’t work, that is, if typing 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb49">
<a id="x14-21013r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  [kb2]. 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> produces an error message saying that the file 
<span class="verb">
<span class="cmtt-10"> kb2 
</span>
</span> does not exist, then you probably haven’t started Prolog from the directory where 
<span class="verb">
<span class="cmtt-10"> kb2.pl 
</span>
</span> is stored. In that case, you can either stop Prolog (by typing 
<span class="verb">
<span class="cmtt-10"> halt. 
</span>
</span> after the prompt), change to the directory where 
<span class="verb">
<span class="cmtt-10"> kb2.pl 
</span>
</span> is stored, and start Prolog again. Or you can tell Prolog exactly where to look for 
<span class="verb">
<span class="cmtt-10"> kb2.pl 
</span>
</span> . To do this, instead of writing only 
<span class="verb">
<span class="cmtt-10"> kb2 
</span>
</span> between the square brackets, you give Prolog the whole path enclosed in single quotes. For example, you type something like 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb50">
<a id="x14-21015r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  [’home/kris/Prolog/kb2.pl’]. 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> or 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb51">
<a id="x14-21017r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  [’c:/Documents 
</span>
<span class="cmtt-10">  and 
</span>
<span class="cmtt-10">  Settings/Kris/Prolog/kb2.pl’]. 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Ok, so Prolog should now know about all the KB2 predicates. And we can check whether it does by using the 
<span class="verb">
<span class="cmtt-10"> listing 
</span>
</span> command again: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb52">
<a id="x14-21019r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  listing. 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> If you do this, Prolog will list (something like) the following on the screen: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb53">
<a id="x14-21021r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  listens2Music(mia). 
</span>
<br class="fancyvrb"/>
<a id="x14-21023r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  happy(yolanda). 
</span>
<br class="fancyvrb"/>
<a id="x14-21025r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  playsAirGuitar(mia):- 
</span>
<br class="fancyvrb"/>
<a id="x14-21027r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  listens2Music(mia). 
</span>
<br class="fancyvrb"/>
<a id="x14-21029r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  playsAirGuitar(yolanda):- 
</span>
<br class="fancyvrb"/>
<a id="x14-21031r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  listens2Music(yolanda). 
</span>
<br class="fancyvrb"/>
<a id="x14-21033r7">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  listens2Music(yolanda):- 
</span>
<br class="fancyvrb"/>
<a id="x14-21035r8">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  happy(yolanda). 
</span>
<br class="fancyvrb"/>
<a id="x14-21037r9">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x14-21039r10">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> That is, it will list the facts and rules that make up KB2, and then say 
<span class="verb">
<span class="cmtt-10"> yes 
</span>
</span> . Once again, you may get a little more than this, such as the locations of various libraries that have been loaded. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Incidentally, 
<span class="verb">
<span class="cmtt-10"> listing 
</span>
</span> can be used in other ways. For example, typing 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb54">
<a id="x14-21041r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  listing(playsAirGuitar). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> simply lists all the information in the knowledge base about the 
<span class="verb">
<span class="cmtt-10"> playsAirGuitar 
</span>
</span> predicate. So in this case Prolog will display 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb55">
<a id="x14-21043r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  playsAirGuitar(mia):- 
</span>
<br class="fancyvrb"/>
<a id="x14-21045r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  listens2Music(mia). 
</span>
<br class="fancyvrb"/>
<a id="x14-21047r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  playsAirGuitar(yolanda):- 
</span>
<br class="fancyvrb"/>
<a id="x14-21049r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  listens2Music(yolanda). 
</span>
<br class="fancyvrb"/>
<a id="x14-21051r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x14-21053r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Well — now you’re ready to go. KB2 is loaded and Prolog is running, so you can (and should!) start making exactly the sort of inquiries we discussed in the text. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> But let’s back up a little, and summarise a few of the practical skills you will need to master to get this far: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<ul class="itemize1">
<li class="itemize"> You will need to know some basic facts about the operating system you are using, such as the directory structure it uses. After all, you will need to know how to save the files containing programs where you want them. 
</li>
<li class="itemize"> You will need to know how to use some sort of text editor, in order to write and modify programs. Some Prolog implementations come with built-in text editors, but if you already know a text editor (such as Emacs) you can use this to write your Prolog code. Just make sure that you save your files as simple text files (for example, if you are working under Windows, don’t save them as Word documents). 
</li>
<li class="itemize"> You may want to take example Prolog programs from the internet. So make sure you know how to use a browser to find what you want, and to store the code where you want it. 
</li>
<li class="itemize"> You need to know how to start your version of Prolog, and how to consult files with it. 
</li>
</ul>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> The sooner you pick up these skills, the better. With them out of the way (which shouldn’t take long) you can start concentrating on mastering Prolog (which will take longer). 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> But assuming you have mastered these skills, what next? Quite simply, 
<span class="cmti-10"> play with 
</span>
<span class="cmti-10"> Prolog! 
</span> Consult the various knowledge bases discussed in the text, and check that the queries discussed really do work the way we said they did. In particular, take a look at KB5 and make sure you understand why you get those peculiar jealousy relations. Try posing new queries. Experiment with the 
<span class="verb">
<span class="cmtt-10"> listing 
</span>
</span> predicate (it’s a useful tool). Type in the knowledge base used in <strong>Exercise</strong>  
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse3"> 1.5 
<!--tex4ht:ref: L1.EX5 -->
</a> , and check whether your answers are correct. Best of all, think of some simple situation that interests you, and create a brand-new knowledge base from scratch. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse3"> prev 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse3"> prev-tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse4"> front 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch1"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse6"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=#taillpn-htmlse5"> tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch2"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<h3 class="sectionHead">
<span class="titlemark"> 2.1 
</span>
<a id="x16-230002.1">
</a> Unification 
</h3>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> When working with knowledge base KB4 in the previous chapter, we briefly mentioned the idea of unification. We said, for example, that Prolog unifies 
<span class="verb">
<span class="cmtt-10"> woman(X) 
</span>
</span> with 
<span class="verb">
<span class="cmtt-10"> woman(mia) 
</span>
</span> , thereby instantiating the variable 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> to 
<span class="verb">
<span class="cmtt-10"> mia 
</span>
</span> . It’s now time to take a closer look at unification, for it is one of the most fundamental ideas in Prolog. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Recall that there are three types of term: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<ol class="enumerate1">
<li class="enumerate" id="x16-23002x1"> Constants. These can either be atoms (such as 
<span class="verb">
<span class="cmtt-10"> vincent 
</span>
</span> ) or numbers (such as 
<span class="verb">
<span class="cmtt-10"> 24 
</span>
</span> ). 
</li>
<li class="enumerate" id="x16-23004x2"> Variables. (Such as 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> Z3 
</span>
</span> , and 
<span class="verb">
<span class="cmtt-10"> List 
</span>
</span> .) 
</li>
<li class="enumerate" id="x16-23006x3"> Complex terms. These have the form: 
<br class="newline"/>
<span class="verb">
<span class="cmtt-10"> functor(term_1,...,term_n) 
</span>
</span> . 
</li>
</ol>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> We are going to work our way towards a definition of when Prolog will unify two terms. Our starting point will be the following working definition. It gives the basic intuition, but is a little light on detail: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="center">
<!--l. 48-->
<p class="noindent">
</p>
<!--l. 52-->
<p class="noindent">
<span class="cmti-10"> Two terms unify if they are the same term or if they contain variables 
</span>
<span class="cmti-10"> that can be uniformly instantiated with terms in such a way that the 
</span>
<span class="cmti-10"> resulting terms are equal. 
</span>
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> This means, for example, that the terms 
<span class="verb">
<span class="cmtt-10"> mia 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> mia 
</span>
</span> unify, because they are the same atom. Similarly, the terms 
<span class="verb">
<span class="cmtt-10"> 42 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> 42 
</span>
</span> unify, because they are the same number, the terms 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> unify, because they are the same variable, and the terms 
<span class="verb">
<span class="cmtt-10"> woman(mia) 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> woman(mia) 
</span>
</span> unify, because they are the same complex term. The terms 
<span class="verb">
<span class="cmtt-10"> woman(mia) 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> woman(vincent) 
</span>
</span> , however, do not unify, as they are not the same (and neither of them contains a variable that could be instantiated to make them the same). 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Now, what about the terms 
<span class="verb">
<span class="cmtt-10"> mia 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> ? They are not the same. However, the variable 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> can be instantiated to 
<span class="verb">
<span class="cmtt-10"> mia 
</span>
</span> which makes them equal. So, by the second part of our working definition, 
<span class="verb">
<span class="cmtt-10"> mia 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> unify. Similarly, the terms 
<span class="verb">
<span class="cmtt-10"> woman(X) 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> woman(mia) 
</span>
</span> unify, because they can be made equal by instantiating 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> to 
<span class="verb">
<span class="cmtt-10"> mia 
</span>
</span> . How about 
<span class="verb">
<span class="cmtt-10"> loves(vincent,X) 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> loves(X,mia) 
</span>
</span> ? No. It is impossible to find an instantiation of 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> that makes the two terms equal. Do you see why? Instantiating 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> to 
<span class="verb">
<span class="cmtt-10"> vincent 
</span>
</span> would give us the terms 
<span class="verb">
<span class="cmtt-10"> loves(vincent,vincent) 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> loves(vincent,mia) 
</span>
</span> , which are obviously not equal. However, instantiating 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> to mia, would yield the terms 
<span class="verb">
<span class="cmtt-10"> loves(vincent,mia) 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> loves(mia,mia) 
</span>
</span> , which aren’t equal either. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Usually we are not only interested in the fact that two terms unify, we also want to know how the variables have to be instantiated to make them equal. And Prolog gives us this information. When Prolog unifies two terms it performs all the necessary instantiations, so that the terms really are equal afterwards. This functionality, together with the fact that we are allowed to build complex terms (that is, recursively structured terms) makes unification a powerful programming mechanism. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> The basic intuitions should now be clear. Here’s the definition which makes them precise. It tells us not only which terms Prolog will unify, but also what it will do to the variables to achieve this. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<ol class="enumerate1">
<li class="enumerate" id="x16-23008x1">
<span class="cmti-10"> If 
</span>
<span class="verb">
<span class="cmtt-10"> term1 
</span>
</span>
<span class="cmti-10"> and 
</span>
<span class="verb">
<span class="cmtt-10"> term2 
</span>
</span>
<span class="cmti-10"> are constants, then 
</span>
<span class="verb">
<span class="cmtt-10"> term1 
</span>
</span>
<span class="cmti-10"> and 
</span>
<span class="verb">
<span class="cmtt-10"> term2 
</span>
</span>
<span class="cmti-10"> unify if and 
</span>
<span class="cmti-10"> only if they are the same atom, or the same number. 
</span>
</li>
<li class="enumerate" id="x16-23010x2">
<span class="cmti-10"> If 
</span>
<span class="verb">
<span class="cmtt-10"> term1 
</span>
</span>
<span class="cmti-10"> is a variable and 
</span>
<span class="verb">
<span class="cmtt-10"> term2 
</span>
</span>
<span class="cmti-10"> is any type of term, then 
</span>
<span class="verb">
<span class="cmtt-10"> term1 
</span>
</span>
<span class="cmti-10"> and 
</span>
<span class="verb">
<span class="cmtt-10"> term2 
</span>
</span>
<span class="cmti-10"> unify, and 
</span>
<span class="verb">
<span class="cmtt-10"> term1 
</span>
</span>
<span class="cmti-10"> is instantiated to 
</span>
<span class="verb">
<span class="cmtt-10"> term2 
</span>
</span> . 
<span class="cmti-10"> Similarly, if 
</span>
<span class="verb">
<span class="cmtt-10"> term2 
</span>
</span>
<span class="cmti-10"> is a 
</span>
<span class="cmti-10"> variable and 
</span>
<span class="verb">
<span class="cmtt-10"> term1 
</span>
</span>
<span class="cmti-10"> is any type of term, then 
</span>
<span class="verb">
<span class="cmtt-10"> term1 
</span>
</span>
<span class="cmti-10"> and 
</span>
<span class="verb">
<span class="cmtt-10"> term2 
</span>
</span>
<span class="cmti-10"> unify, and 
</span>
<span class="verb">
<span class="cmtt-10"> term2 
</span>
</span>
<span class="cmti-10"> is instantiated to 
</span>
<span class="verb">
<span class="cmtt-10"> term1 
</span>
</span> . 
<span class="cmti-10"> (So if they are both variables, they’re both 
</span>
<span class="cmti-10"> instantiated to each other, and we say that they share values.) 
</span>
</li>
<li class="enumerate" id="x16-23012x3">
<span class="cmti-10"> If 
</span>
<span class="verb">
<span class="cmtt-10"> term1 
</span>
</span>
<span class="cmti-10"> and 
</span>
<span class="verb">
<span class="cmtt-10"> term2 
</span>
</span>
<span class="cmti-10"> are complex terms, then they unify if and only 
</span>
<span class="cmti-10"> if: 
</span>
<ol class="enumerate2">
<li class="enumerate" id="x16-23014x1">
<span class="cmti-10"> They have the same functor and arity, and 
</span>
</li>
<li class="enumerate" id="x16-23016x2">
<span class="cmti-10"> all their corresponding arguments unify, and 
</span>
</li>
<li class="enumerate" id="x16-23018x3">
<span class="cmti-10"> the variable instantiations are compatible. (For example, it is not 
</span>
<span class="cmti-10"> possible to instantiate variable 
</span>
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span>
<span class="cmti-10"> to 
</span>
<span class="verb">
<span class="cmtt-10"> mia 
</span>
</span>
<span class="cmti-10"> when unifying one pair of 
</span>
<span class="cmti-10"> arguments, and to instantiate 
</span>
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span>
<span class="cmti-10"> to 
</span>
<span class="verb">
<span class="cmtt-10"> vincent 
</span>
</span>
<span class="cmti-10"> when unifying another 
</span>
<span class="cmti-10"> pair of arguments 
</span> .) 
</li>
</ol>
</li>
<li class="enumerate" id="x16-23020x4">
<span class="cmti-10"> Two terms unify if and only if it follows from the previous three clauses that 
</span>
<span class="cmti-10"> they unify. 
</span>
</li>
</ol>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Let’s have a look at the form of this definition. The first clause tells us when two constants unify. The second clause tells us when two terms, one of which is a variable, unify (such terms will always unify; variables unify with 
<span class="cmti-10"> anything 
</span> ). Just as importantly, this clause also tells what instantiations we have to perform to make the two terms the same. Finally, the third clause tells us when two complex terms unify. Note the structure of this definition. Its first three clauses mirror perfectly the (recursive) structure of terms. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> The fourth clause is also important: it says that the first three clauses tell us all we need to know about the unification of two terms. If two terms can’t be shown to unify using clauses 1–3, then they 
<span class="cmti-10"> don’t 
</span> unify. For example, 
<span class="verb">
<span class="cmtt-10"> batman 
</span>
</span> does not unify with 
<span class="verb">
<span class="cmtt-10"> daughter(ink) 
</span>
</span> . Why not? Well, the first term is a constant, and the second is a complex term. But none of the first three clauses tell us how to unify two such terms, hence (by clause 4) they don’t unify. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent">
</p>
</div>
<div class="nb-cell html" name="htm1">
<h4 class="likesubsectionHead">
<a id="x16-240002.1">
</a> Examples 
</h4>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> To make sure we’ve fully understood this definition, let’s work through several examples. In these examples we’ll make use of an important built-in predicate, the 
<span class="verb">
<span class="cmtt-10"> =/2 
</span>
</span> predicate (recall that writing 
<a id="dx16-24001">
</a>
<span class="verb">
<span class="cmtt-10"> /2 
</span>
</span> at the end indicates that this predicate takes two arguments). 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> The 
<span class="verb">
<span class="cmtt-10"> =/2 
</span>
</span> predicate tests whether its two arguments unify. For example, if we pose the query 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb56">
<a id="x16-24003r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  =(mia,mia). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Prolog will respond yes, and if we pose the query 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb57">
<a id="x16-24005r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  =(mia,vincent). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Prolog will respond no. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> But we usually wouldn’t pose these queries in quite this way. Let’s face it, the notation 
<span class="verb">
<span class="cmtt-10"> =(mia,mia) 
</span>
</span> is rather unnatural. It would be nicer if we could use infix notation (that is, if we could put the 
<span class="verb">
<span class="cmtt-10"> =/2 
</span>
</span> functor between its arguments) and write things like: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb58">
<a id="x16-24007r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  mia 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  mia. 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> In fact, Prolog lets us do this, so in the examples that follow we’ll use infix notation. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Let’s return to our first example: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb59">
<a id="x16-24009r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  mia 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  mia. 
</span>
<br class="fancyvrb"/>
<a id="x16-24011r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Why does Prolog say yes? This may seem like a silly question: surely it’s obvious that the terms unify! That’s true, but how does this follow from the definition given above? It is important to learn to think systematically about unification (it is utterly fundamental to Prolog), and thinking systematically means relating the examples to the definition of unification given above. So let’s think this example through. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> The definition has three clauses. Now, clause 2 is for when one argument is a variable, and clause 3 is for when both arguments are complex terms, so these are of no use here. However clause 1 
<span class="cmti-10"> is 
</span> relevant to our example. This tells us that two constants unify if and only if they are exactly the same object. As 
<span class="verb">
<span class="cmtt-10"> mia 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> mia 
</span>
</span> are the same atom, unification succeeds. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> A similar argument explains the following responses: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb60">
<a id="x16-24013r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  2 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  2. 
</span>
<br class="fancyvrb"/>
<a id="x16-24015r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
<br class="fancyvrb"/>
<a id="x16-24017r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x16-24019r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  mia 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  vincent. 
</span>
<br class="fancyvrb"/>
<a id="x16-24021r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  no 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Once again, clause 1 is relevant here (after all, 
<span class="verb">
<span class="cmtt-10"> 2 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> mia 
</span>
</span> , and 
<span class="verb">
<span class="cmtt-10"> vincent 
</span>
</span> are all constants). And as 
<span class="verb">
<span class="cmtt-10"> 2 
</span>
</span> is the same number as 
<span class="verb">
<span class="cmtt-10"> 2 
</span>
</span> , and as 
<span class="verb">
<span class="cmtt-10"> mia 
</span>
</span> is 
<span class="cmti-10"> not 
</span> the same atom as 
<span class="verb">
<span class="cmtt-10"> vincent 
</span>
</span> , Prolog responds yes to the first query and no to the second. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> However clause 1 does hold one small surprise for us. Consider the following query: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb61">
<a id="x16-24023r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  ’mia’ 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  mia. 
</span>
<br class="fancyvrb"/>
<a id="x16-24025r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> What’s going on here? Why do these two terms unify? Well, as far as Prolog is concerned, 
<span class="verb">
<span class="cmtt-10"> ’mia’ 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> mia 
</span>
</span> are the same atom. In fact, for Prolog, any atom of the form 
<span class="verb">
<span class="cmtt-10"> ’symbols’ 
</span>
</span> is considered the same entity as the atom of the form 
<span class="verb">
<span class="cmtt-10"> symbols 
</span>
</span> . This can be a useful feature in certain kinds of programs, so don’t forget it. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> On the other hand, to the query 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb62">
<a id="x16-24027r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  ’2’ 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  2. 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Prolog will respond no. And if you think about the definitions given in Chapter  
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch1"> 1 
<!--tex4ht:ref: CHAPTER1 -->
</a> , you will see that this has to be the way things work. After all, 
<span class="verb">
<span class="cmtt-10"> 2 
</span>
</span> is a number, but 
<span class="verb">
<span class="cmtt-10"> ’2’ 
</span>
</span> is an atom. They simply cannot be the same. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Let’s try an example with a variable: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb63">
<a id="x16-24029r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  mia 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  X. 
</span>
<br class="fancyvrb"/>
<a id="x16-24031r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x16-24033r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  mia 
</span>
<br class="fancyvrb"/>
<a id="x16-24035r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Again, this in an easy example: clearly the variable 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> can be unified with the constant 
<span class="verb">
<span class="cmtt-10"> mia 
</span>
</span> , and Prolog does so, and tells us that it has made this unification. Fine, but how does this follow from our definition? 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> The relevant clause here is clause 2. This tells us what happens when at least one of the arguments is a variable. In our example it is the second term which is the variable. The definition tells us unification is possible, and also says that the variable is instantiated to the first argument, namely 
<span class="verb">
<span class="cmtt-10"> mia 
</span>
</span> . And this, of course, is exactly what Prolog does. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Now for an important example: what happens with the following query? 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb64">
<a id="x16-24037r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  Y. 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Well, depending on your Prolog implementation, you may just get back the output 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb65">
<a id="x16-24039r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  Y. 
</span>
<br class="fancyvrb"/>
<a id="x16-24041r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Prolog is simply agreeing that the two terms unify (after all, variables unify with anything, so they certainly unify with each other) and making a note that from now on, 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> Y 
</span>
</span> denote the same object, that is, share values. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> On the other hand, you may get the following output: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb66">
<a id="x16-24043r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  _5071 
</span>
<br class="fancyvrb"/>
<a id="x16-24045r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Y 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  _5071 
</span>
<br class="fancyvrb"/>
<a id="x16-24047r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> What’s going on here? Essentially the same thing. Note that 
<span class="verb">
<span class="cmtt-10"> _5071 
</span>
</span> is a variable (recall from Chapter  
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch1"> 1 
<!--tex4ht:ref: CHAPTER1 -->
</a> that strings of letters and numbers that start with the underscore character are variables). Now look at clause 2 of the definition of unification. This tells us that when two variables are unified, they share values. So Prolog has created a new variable (namely 
<span class="verb">
<span class="cmtt-10"> _5071 
</span>
</span> ) and from now on both 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> Y 
</span>
</span> share the value of this variable. In effect, Prolog is creating a common variable name for the two original variables. Needless to say, there’s nothing magic about the number 
<span class="verb">
<span class="cmtt-10"> 5071 
</span>
</span> . Prolog just needs to generate a brand new variable name, and using numbers is a handy way to do this. It might just as well generate 
<span class="verb">
<span class="cmtt-10"> _5075 
</span>
</span> , or 
<span class="verb">
<span class="cmtt-10"> _6189 
</span>
</span> , or whatever. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Here is another example involving only atoms and variables. How do you think will Prolog respond? 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb67">
<a id="x16-24049r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  mia, 
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  vincent. 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Prolog will respond no. This query involves two goals, 
<span class="verb">
<span class="cmtt-10"> X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  mia 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  vincent 
</span>
</span> . Taken separately, Prolog would succeed at both of them, instantiating 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> to 
<span class="verb">
<span class="cmtt-10"> mia 
</span>
</span> in the first case and to 
<span class="verb">
<span class="cmtt-10"> vincent 
</span>
</span> in the second. And that’s exactly the problem here: once Prolog has worked through the first goal, 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> is instantiated to (and therefore equal to) 
<span class="verb">
<span class="cmtt-10"> mia 
</span>
</span> , so that it simply can’t unify with 
<span class="verb">
<span class="cmtt-10"> vincent 
</span>
</span> anymore. Hence the second goal fails. An 
<span class="cmti-10"> instantiated 
</span> variable isn’t really a variable anymore: it has become what it was instantiated with. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Now let’s look at an example involving complex terms: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb68">
<a id="x16-24051r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  k(s(g),Y) 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  k(X,t(k)). 
</span>
<br class="fancyvrb"/>
<a id="x16-24053r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x16-24055r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  s(g) 
</span>
<br class="fancyvrb"/>
<a id="x16-24057r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Y 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  t(k) 
</span>
<br class="fancyvrb"/>
<a id="x16-24059r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Clearly the two complex terms unify if the stated variable instantiations are carried out. But how does this follow from the definition? Well, first of all, clause 3 has to be used here because we are trying to unify two complex terms. So the first thing we need to do is check that both complex terms have the same functor and arity. And they do. Clause 3 also tells us that we have to unify the corresponding arguments in each complex term. So do the first arguments, 
<span class="verb">
<span class="cmtt-10"> s(g) 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> , unify? By clause 2, yes, and we instantiate 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> to 
<span class="verb">
<span class="cmtt-10"> s(g) 
</span>
</span> . So do the second arguments, 
<span class="verb">
<span class="cmtt-10"> Y 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> t(k) 
</span>
</span> , unify? Again by clause 2, yes, and we instantiate 
<span class="verb">
<span class="cmtt-10"> Y 
</span>
</span> to 
<span class="verb">
<span class="cmtt-10"> t(k) 
</span>
</span> . 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Here’s another example with complex terms: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb69">
<a id="x16-24061r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  k(s(g), 
</span>
<span class="cmtt-10">  t(k)) 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  k(X,t(Y)). 
</span>
<br class="fancyvrb"/>
<a id="x16-24063r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x16-24065r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  s(g) 
</span>
<br class="fancyvrb"/>
<a id="x16-24067r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Y 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  k 
</span>
<br class="fancyvrb"/>
<a id="x16-24069r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> It should be clear that the two terms unify if these instantiations are carried out. But can you explain, step by step, how this relates to the definition? 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Here is a last example: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb70">
<a id="x16-24071r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  loves(X,X) 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  loves(marcellus,mia). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Do these terms unify? No, they don’t. It’s true that they are both complex terms and have the same functor and arity, but clause 3 also demands that all corresponding arguments have to unify, and that the variable instantiations have to be compatible. This is not the case here. Unifying the first arguments would instantiate 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> with 
<span class="verb">
<span class="cmtt-10"> marcellus 
</span>
</span> . Unifying the second arguments would instantiate 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> with 
<span class="verb">
<span class="cmtt-10"> mia 
</span>
</span> . Either way, we’re blocked. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent">
</p>
</div>
<div class="nb-cell html" name="htm1">
<h4 class="likesubsectionHead">
<a id="x16-250002.1">
</a> The occurs check 
</h4>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Unification is a well-known concept, used in several branches of computer science. It has been thoroughly studied, and many unification algorithms are known. But Prolog does 
<span class="cmti-10"> not 
</span> use a standard unification algorithm when it performs its version of unification. Instead it takes a shortcut. You need to know about this shortcut. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Consider the following query: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb71">
<a id="x16-25002r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  father(X) 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  X. 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Do these terms unify or not? A standard unification algorithm would say: “No, they don’t”. Why is that? Well, pick any term and instantiate 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> to the term you picked. For example, if you instantiate 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> to 
<span class="verb">
<span class="cmtt-10"> father(father(butch)) 
</span>
</span> , the left hand side becomes 
<span class="verb">
<span class="cmtt-10"> father(father(father(butch))) 
</span>
</span> , and the right hand side becomes 
<span class="verb">
<span class="cmtt-10"> father(father(butch)) 
</span>
</span> . Obviously these don’t unify. Moreover, it makes no difference what term you instantiate 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> to. No matter what you choose, the two terms cannot possibly be made the same, for the term on the left will always be one symbol longer than the term on the right (the functor 
<span class="verb">
<span class="cmtt-10"> father 
</span>
</span> on the left will always give it that one extra level). A standard unification algorithm will spot this (we’ll see why shortly when we discuss the occurs check), halt, and tell us no. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> The recursive definition of Prolog unification given earlier won’t do this. Because the left hand term is the variable 
<span class="cmtt-10"> X 
</span> , by clause 2 it decides that the terms 
<span class="cmti-10"> do 
</span> unify, and (in accordance with clause 2) instantiates 
<span class="cmtt-10"> X 
</span> to the right hand side, namely 
<span class="cmtt-10"> father(X) 
</span> . But there’s an 
<span class="cmtt-10"> X 
</span> in this term, and 
<span class="cmtt-10"> X 
</span> has been instantiated to 
<span class="cmtt-10"> father(X) 
</span> , so Prolog realises that 
<span class="cmtt-10"> father(X) 
</span> is really 
<span class="cmtt-10"> father(father(X)) 
</span> . But there’s an 
<span class="cmtt-10"> X 
</span> here too, and 
<span class="cmtt-10"> X 
</span> has been instantiated to 
<span class="cmtt-10"> father(X) 
</span> , so Prolog realises that 
<span class="cmtt-10"> father(father(X)) 
</span> is really 
<span class="cmtt-10"> father(father(father(X))) 
</span> , and so on. Having instantiated 
<span class="cmtt-10"> X 
</span> to 
<span class="cmtt-10"> father(X) 
</span> , Prolog is committed to carrying out an unending sequence of expansions. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> At least, that’s the theory. What happens in practice? Well, with older Prolog implementations, what we’ve just described is exactly what happens. You would get a message like: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb72">
<a id="x16-25004r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Not 
</span>
<span class="cmtt-10">  enough 
</span>
<span class="cmtt-10">  memory 
</span>
<span class="cmtt-10">  to 
</span>
<span class="cmtt-10">  complete 
</span>
<span class="cmtt-10">  query! 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> and a long string of symbols like: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb73">
<a id="x16-25006r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  father(father(father(father(father(father 
</span>
<br class="fancyvrb"/>
<a id="x16-25008r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  (father(father(father(father(father(father 
</span>
<br class="fancyvrb"/>
<a id="x16-25010r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  (father(father(father(father(father(father 
</span>
<br class="fancyvrb"/>
<a id="x16-25012r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  (father(father(father(father(father(father 
</span>
<br class="fancyvrb"/>
<a id="x16-25014r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  (father(father(father(father(father(father 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Prolog is desperately 
<span class="cmti-10"> trying 
</span> to come back with the correctly instantiated terms, but it can’t halt, because the instantiation process is unbounded. From an abstract mathematical perspective, what Prolog is trying to do is sensible. Intuitively, the only way the two terms could be made to unify would be if 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> was instantiated to a term containing an infinitely long string of 
<span class="verb">
<span class="cmtt-10"> father 
</span>
</span> functors, so that the effect of the extra 
<span class="verb">
<span class="cmtt-10"> father 
</span>
</span> functor on the left hand side was cancelled out. But the terms we compute with are 
<span class="cmti-10"> finite 
</span> entities. Infinite terms are an interesting mathematical abstraction, but they’re not something we can work with. No matter how hard Prolog tries, it can never build one. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Now, it’s annoying to have Prolog running out of memory like this, and sophisticated Prolog implementations have found ways of coping more gracefully. Try posing the query 
<span class="verb">
<span class="cmtt-10"> father(X) 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  X 
</span>
</span> to SWI Prolog or SICStus Prolog. The answer will be something like: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb74">
<a id="x16-25016r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  father(father(father(father(...)))))))) 
</span>
<br class="fancyvrb"/>
<a id="x16-25018r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> That is, these implementations insist that unification 
<span class="cmti-10"> is 
</span> possible, but they 
<span class="cmti-10"> don’t 
</span> fall into the trap of actually trying to instantiate a finite term for 
<span class="cmtt-10"> X 
</span> as the naive implementations do. Instead, they detect that there is a potential problem, halt, declare that unification is possible, and print out a finite representation of an infinite term, like the 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb75">
<a id="x16-25020r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  father(father(father(father(...)))))))) 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> in the previous query. Can you compute with these finite representations of infinite terms? That depends on the implementation. In some systems you cannot do much with them. For example, posing the query 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb76">
<a id="x16-25022r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  father(X), 
</span>
<span class="cmtt-10">  Y 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  father(Y), 
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  Y. 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> would result in a crash (note that the 
<span class="cmtt-10"> X = Y 
</span> demands that we unify two finite representations of infinite terms). Nonetheless, in some modern systems unification works robustly with such representations (for example, both SWI and Sicstus can handle the previous example) so you can actually use them in your programs. However, why you might want to use such representations, and what such representations actually are, are topics that lie beyond the scope of this book. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> In short, there are actually 
<span class="cmti-10"> three 
</span> different responses to the question “does 
<span class="cmtt-10"> father(X) 
</span> unify with 
<span class="cmtt-10"> X 
</span> ”. There is the answer given by the standard unification algorithm (which is to say no), the response of older Prolog implementations (which is to run amok until they use up the available memory), and the answer given by sophisticated Prolog implementations (which is to say yes, and return a finite representation of an infinite term). In short, there is no ‘right’ answer to this question. What is important is that you understand the difference between standard unification and Prolog unification, and know how the Prolog implementation that 
<span class="cmtt-10"> you 
</span> work with handles such examples. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Now, in the practical session at the end of the chapter we ask you to try out such examples with your Prolog interpreter. Here we want to say a little more about the difference between Prolog unification and standard unification. Given the very different ways they handle this example, it may seem that standard unification algorithms and the Prolog approach to unification are inherently different. Actually, they’re not. There is one simple difference between the two algorithms that accounts for their different behaviour when faced with the task of unifying terms like 
<span class="cmtt-10"> X 
</span> and 
<span class="cmtt-10"> father(X) 
</span> . A standard algorithm, when given two terms to unify, first carries out what is known as the occurs check. This means that if it is asked to unify a variable with a term, it first checks whether the variable occurs in the term. If it does, the standard algorithm declares that unification is impossible, for clearly it is the presence of the variable 
<span class="cmtt-10"> X 
</span> in 
<span class="cmtt-10"> father(X) 
</span> which leads to the problems discussed earlier. Only if the variable does not occur in the term do standard algorithms attempt to carry out the unification. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> To put it another way, standard unification algorithms are 
<span class="cmti-10"> pessimistic 
</span> . They first carry out the occurs check, and only when they are sure that the situation is safe they do go ahead and actually try to unify the terms. So a standard unification algorithm will never get locked into a situation where it is endlessly trying to instantiate variables, or having to appeal to infinite terms. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Prolog, on the other hand, is 
<span class="cmti-10"> optimistic 
</span> . It assumes that you are not going to give it anything dangerous. So it takes a shortcut: it omits the occurs check. As soon as you give it two terms, it rushes ahead and tries to unify them. As Prolog is a programming language, this is an intelligent strategy. Unification is one of the fundamental processes that makes Prolog work, so it needs to be carried out as fast as possible. Carrying out an occurs check every time unification is called for would slow it down considerably. Pessimism is safe, but optimism is a lot faster! Prolog can only run into problems if you, the programmer, ask it to do something like unify 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> with 
<span class="verb">
<span class="cmtt-10"> father(X) 
</span>
</span> . And it is unlikely you will ever (intentionally) ask it to do anything like that when writing a real program. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> One final remark. Prolog comes with a built-in predicate that carries out standard unification (that is, unification with the occurs check). The predicate is 
<a id="dx16-25023">
</a>
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb77">
<a id="x16-25025r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  unify_with_occurs_check/2. 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> So if we posed the query 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb78">
<a id="x16-25027r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  unify_with_occurs_check(father(X),X). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> we would get the response no. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent">
</p>
</div>
<div class="nb-cell html" name="htm1">
<h4 class="likesubsectionHead">
<a id="x16-260002.1">
</a> Programming with unification 
</h4>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> As we’ve said, unification is a fundamental operation in Prolog. It plays a key role in Prolog proof search (as we shall soon learn), and this alone makes it vital. However, as you get to know Prolog better, it will become clear that unification is interesting and important in its own right. Indeed, sometimes you can write useful programs simply by using complex terms to define interesting concepts. Unification can then be used to pull out the information you want. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Here’s a simple example of this, due to Ivan Bratko. 
<span class="footnote-mark">
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-html17">
<sup class="textsuperscript"> 1 
</sup>
</a>
</span>
<a id="x16-26001f1">
</a> The following two line knowledge base defines two predicates, namely 
<span class="verb">
<span class="cmtt-10"> vertical/1 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> horizontal/1 
</span>
</span> , which specify what it means for a line to be vertical or horizontal respectively: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb79">
<a id="x16-26003r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  vertical(line(point(X,Y),point(X,Z))). 
</span>
<br class="fancyvrb"/>
<a id="x16-26005r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x16-26007r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  horizontal(line(point(X,Y),point(Z,Y))). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Now, at first glance this knowledge base may seem too simple to be interesting: it contains just two facts, and no rules. But wait a minute: the two facts are expressed using complex terms which again have complex terms as arguments. Indeed, there are three levels of terms nested inside terms. Moreover, the deepest level arguments are all variables, so the concepts are being defined in a general way. Maybe it’s not quite as simple as it seems. Let’s take a closer look. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Right down at the bottom level, we have a complex term with functor 
<span class="verb">
<span class="cmtt-10"> point 
</span>
</span> and two arguments. Its two arguments are intended to be instantiated to numbers: 
<span class="verb">
<span class="cmtt-10"> point(X,Y) 
</span>
</span> represents the Cartesian coordinates of a point. That is, the 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> indicates the horizontal distance the point is from some fixed point, while the 
<span class="verb">
<span class="cmtt-10"> Y 
</span>
</span> indicates the vertical distance from that same fixed point. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Now, once we’ve specified two distinct points, we’ve specified a line, namely the line between them. So the two complex terms representing points are bundled together as the two arguments of another complex term with the functor 
<span class="verb">
<span class="cmtt-10"> line 
</span>
</span> . In effect, we represent a line by a complex term which has two arguments which are complex terms themselves and represent points. We’re using Prolog’s ability to build complex terms to work our way up a hierarchy of concepts. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Being vertical, and being horizontal, are properties of lines. The predicates 
<span class="verb">
<span class="cmtt-10"> vertical 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> horizontal 
</span>
</span> therefore both take one argument which represents a line. The definition of 
<span class="verb">
<span class="cmtt-10"> vertical/1 
</span>
</span> simply says: a line that goes between two points that have the same x-coordinate is vertical. Note how we capture the effect of “the same x-coordinate” in Prolog: we simply make use of the same variable 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> as the first argument of the two complex terms representing the points. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Similarly, the definition of 
<span class="verb">
<span class="cmtt-10"> horizontal/1 
</span>
</span> simply says: a line that goes between two points that have the same y-coordinate is horizontal. To capture the effect of “the same y-coordinate”, we use the same variable 
<span class="verb">
<span class="cmtt-10"> Y 
</span>
</span> as the second argument of the two complex terms representing the points. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> What can we do with this knowledge base? Let’s look at some examples: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb80">
<a id="x16-26009r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  vertical(line(point(1,1),point(1,3))). 
</span>
<br class="fancyvrb"/>
<a id="x16-26011r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> This should be clear: the query unifies with the definition of 
<span class="verb">
<span class="cmtt-10"> vertical/1 
</span>
</span> in our little knowledge base (and in particular, the representations of the two points have the same first argument) so Prolog says yes. Similarly we have: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb81">
<a id="x16-26013r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  vertical(line(point(1,1),point(3,2))). 
</span>
<br class="fancyvrb"/>
<a id="x16-26015r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  no 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> This query does not unify with the definition of 
<span class="verb">
<span class="cmtt-10"> vertical/1 
</span>
</span> (the representations of the two points have different first arguments) so Prolog says no. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> But we can also ask more general questions: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb82">
<a id="x16-26017r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  horizontal(line(point(1,1),point(2,Y))). 
</span>
<br class="fancyvrb"/>
<a id="x16-26019r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x16-26021r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Y 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  1 
</span>
<span class="cmtt-10">  ; 
</span>
<br class="fancyvrb"/>
<a id="x16-26023r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x16-26025r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  no 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Here our query is: if we want a horizontal line between a point at (1,1), and point whose x-coordinate is 2, what should the y-coordinate of that second point be? Prolog correctly tells us that the y-coordinate should be 1. If we then ask Prolog for a second possibility (note the 
<span class="verb">
<span class="cmtt-10"> ; 
</span>
</span> ) it tells us that no other possibilities exist. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Now consider the following: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb83">
<a id="x16-26027r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  horizontal(line(point(2,3),P)). 
</span>
<br class="fancyvrb"/>
<a id="x16-26029r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x16-26031r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  P 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  point(_1972,3) 
</span>
<span class="cmtt-10">  ; 
</span>
<br class="fancyvrb"/>
<a id="x16-26033r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x16-26035r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  no 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> This query is: if we want a horizontal line between a point at (2,3), and some other point, what other points are permissible? The answer is: any point whose y-coordinate is 3. Note that the 
<span class="verb">
<span class="cmtt-10"> _1972 
</span>
</span> in the first argument of the answer is a variable, which is Prolog’s way of telling us that any x-coordinate at all will do. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> A general remark: the answer given to our last query, namely 
<span class="verb">
<span class="cmtt-10"> point(_1972,3) 
</span>
</span> , is 
<span class="cmti-10"> structured 
</span> . That is, the answer is a complex term, representing a sophisticated concept (namely “any point whose y-coordinate is 3”). This structure was built using unification and nothing else: no logical inference (and in particular, no use of modus ponens) was used to produce it. Building structure by unification turns out to be a powerful idea in Prolog programming, far more powerful than this rather simple example might suggest. Moreover, when a program is written that makes heavy use of unification, it is likely to be extremely efficient. We will study a beautiful example in Chapter  
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch7"> 7 
<!--tex4ht:ref: CHAPTER7 -->
</a> when we discuss difference lists, which are used to implement Prolog’s built-in grammar system, Definite Clause Grammars. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> This style of programming is particularly useful in applications where the important concepts have a natural hierarchical structure (as they did in the simple knowledge base above), for we can then use complex terms to represent this structure, and unification to access it. This way of working plays an important role in computational linguistics, for example, because information about language has a natural hierarchical structure (think of the way sentences can be analysed into noun phrases and verb phrases, and noun phrases analysed into determiners and nouns, and so on). 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse6"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse5"> front 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch2"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse7"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse5"> prev 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse5"> prev-tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=#taillpn-htmlse6"> tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch2"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<h3 class="sectionHead">
<span class="titlemark"> 2.2 
</span>
<a id="x18-270002.2">
</a> Proof Search 
</h3>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Now that we know about unification, we are in a position to learn how Prolog actually searches a knowledge base to see if a query is satisfied. That is, we are ready to learn about proof search. We will introduce the basic ideas involved by working through a simple example. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Suppose we are working with the following knowledge base 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb84">
<a id="x18-27002r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  f(a). 
</span>
<br class="fancyvrb"/>
<a id="x18-27004r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  f(b). 
</span>
<br class="fancyvrb"/>
<a id="x18-27006r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x18-27008r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  g(a). 
</span>
<br class="fancyvrb"/>
<a id="x18-27010r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  g(b). 
</span>
<br class="fancyvrb"/>
<a id="x18-27012r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x18-27014r7">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  h(b). 
</span>
<br class="fancyvrb"/>
<a id="x18-27016r8">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x18-27018r9">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  k(X) 
</span>
<span class="cmtt-10">  :- 
</span>
<span class="cmtt-10">  f(X), 
</span>
<span class="cmtt-10">  g(X), 
</span>
<span class="cmtt-10">  h(X). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Suppose we then pose the query 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb85">
<a id="x18-27020r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  k(Y). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> It is probably clear that there is only one answer to this query, namely 
<span class="verb">
<span class="cmtt-10"> k(b) 
</span>
</span> , but how exactly does Prolog work this out? Let’s see. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Prolog reads the knowledge base, and tries to unify 
<span class="verb">
<span class="cmtt-10"> k(Y) 
</span>
</span> with either a fact, or the head of a rule. It searches the knowledge base top to bottom, and carries out the unification, if it can, at the first place possible. Here there is only one possibility: it must unify 
<span class="verb">
<span class="cmtt-10"> k(Y) 
</span>
</span> to the head of the rule 
<span class="verb">
<span class="cmtt-10"> k(X) 
</span>
<span class="cmtt-10">  :- 
</span>
<span class="cmtt-10">  f(X), 
</span>
<span class="cmtt-10">  g(X), 
</span>
<span class="cmtt-10">  h(X) 
</span>
</span> . 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> When Prolog unifies the variable in a query to a variable in a fact or rule, it generates a brand new variable (say 
<span class="verb">
<span class="cmtt-10"> _G34 
</span>
</span> ) to represent the shared variables. So the original query now reads: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb86">
<a id="x18-27022r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  k(_G34) 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> and Prolog knows that 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb87">
<a id="x18-27024r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  k(_G34) 
</span>
<span class="cmtt-10">  :- 
</span>
<span class="cmtt-10">  f(_G34), 
</span>
<span class="cmtt-10">  g(_G34), 
</span>
<span class="cmtt-10">  h(_G34). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> So what do we now have? The original query says: “I want to find an individual that has property 
<span class="verb">
<span class="cmtt-10"> k 
</span>
</span> ”. The rule says, “an individual has property 
<span class="verb">
<span class="cmtt-10"> k 
</span>
</span> if it has properties 
<span class="verb">
<span class="cmtt-10"> f 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> g 
</span>
</span> , and 
<span class="verb">
<span class="cmtt-10"> h 
</span>
</span> ”. So if Prolog can find an individual with properties 
<span class="verb">
<span class="cmtt-10"> f 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> g 
</span>
</span> , and 
<span class="verb">
<span class="cmtt-10"> h 
</span>
</span> , it will have satisfied the original query. So Prolog replaces the original query with the following list of goals: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb88">
<a id="x18-27026r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  f(_G34), 
</span>
<span class="cmtt-10">  g(_G34), 
</span>
<span class="cmtt-10">  h(_G34). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Our discussion of the querying process so far can be made more elegant and succinct if we think graphically. Consider the following diagram: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="center">
<!--l. 723-->
<p class="noindent">
</p>
<!--l. 724-->
<p class="noindent">
<img alt="*Pic not found*" src="html/chap2-pspic1.ps.png"/>
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Everything in a box is either a query or a goal. In particular, our original goal was to prove 
<span class="verb">
<span class="cmtt-10"> k(Y) 
</span>
</span> , thus this is shown in the top box. When we unified 
<span class="verb">
<span class="cmtt-10"> k(Y) 
</span>
</span> with the head of the rule in the knowledge base, 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span>
<span class="verb">
<span class="cmtt-10"> Y 
</span>
</span> , and the new internal variable 
<span class="verb">
<span class="cmtt-10"> _G34 
</span>
</span> were made to share values, and we were left with the goals 
<span class="verb">
<span class="cmtt-10"> f(_G34),g(_G34),h(_G34) 
</span>
</span> , just as shown. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Now, whenever it has a list of goals, Prolog tries to satisfy them one by one, working through the list in a left to right direction. The leftmost goal is 
<span class="verb">
<span class="cmtt-10"> f(_G34) 
</span>
</span> , which reads: “I want an individual with property 
<span class="verb">
<span class="cmtt-10"> f 
</span>
</span> ”. Can this goal be satisfied? Prolog tries to do so by searching through the knowledge base from top to bottom. The first item it finds that unifies with this goal is the fact 
<span class="verb">
<span class="cmtt-10"> f(a) 
</span>
</span> . This satisfies the goal 
<span class="verb">
<span class="cmtt-10"> f(_G34) 
</span>
</span> and we are left with two more goals. Now, when we unify 
<span class="verb">
<span class="cmtt-10"> f(_G34) 
</span>
</span> to 
<span class="verb">
<span class="cmtt-10"> f(a) 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> _G34 
</span>
</span> is instantiated to 
<span class="verb">
<span class="cmtt-10"> a 
</span>
</span> , and this instantiation applies to all occurrences of 
<span class="verb">
<span class="cmtt-10"> _G34 
</span>
</span> in the list of goals. So the list now looks like this: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb89">
<a id="x18-27028r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  g(a),h(a) 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> and our graphical representation of the proof search now looks like this: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="center">
<!--l. 750-->
<p class="noindent">
</p>
<!--l. 751-->
<p class="noindent">
<img alt="*Pic not found*" src="html/chap2-pspic2.ps.png"/>
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> But the fact 
<span class="verb">
<span class="cmtt-10"> g(a) 
</span>
</span> is in the knowledge base, so the first goal we have to prove is satisfied too. So the goal list becomes 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb90">
<a id="x18-27030r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  h(a) 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> and the graphical representation is now 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="center">
<!--l. 763-->
<p class="noindent">
</p>
<!--l. 764-->
<p class="noindent">
<img alt="*Pic not found*" src="html/chap2-pspic3.ps.png"/>
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> But there is no way to satisfy 
<span class="verb">
<span class="cmtt-10"> h(a) 
</span>
</span> , the last remaining goal. The only information about 
<span class="verb">
<span class="cmtt-10"> h 
</span>
</span> we have in the knowledge base is 
<span class="verb">
<span class="cmtt-10"> h(b) 
</span>
</span> , and this won’t unify with 
<span class="verb">
<span class="cmtt-10"> h(a) 
</span>
</span> . 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> So what happens next? Well, Prolog decides it has made a mistake, and checks whether it has missed any possible ways of unifying a goal with a fact or the head of a rule in the knowledge base. It does this by going back up the path shown in the graphical representation, looking for alternatives. Now, there is nothing else in the knowledge base that unifies with 
<span class="verb">
<span class="cmtt-10"> g(a) 
</span>
</span> , but there 
<span class="cmti-10"> is 
</span> another way of unifying 
<span class="verb">
<span class="cmtt-10"> f(_G34) 
</span>
</span> . Points in the search where there are several alternative ways of unifying a goal against the knowledge base are called choice points. Prolog keeps track of choice points it has encountered, so that if it makes a wrong choice it can retreat to the previous choice point and try something else instead. This process is called backtracking, and it is fundamental to proof search in Prolog. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> So let’s carry on with our example. Prolog backtracks to the last choice point. This is the point in the graphical representation where the list of goals was: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb91">
<a id="x18-27032r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  f(_G34),g(_G34),h(_G34). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Prolog must now redo this work. First it must try to re-satisfy the first goal by searching further in the knowledge base. It can do this: it sees that it can unify the first goal with information in the knowledge base by unifying 
<span class="verb">
<span class="cmtt-10"> f(_G34) 
</span>
</span> with 
<span class="verb">
<span class="cmtt-10"> f(b) 
</span>
</span> . This satisfies the goal 
<span class="verb">
<span class="cmtt-10"> f(_G34) 
</span>
</span> and instantiates 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> to 
<span class="verb">
<span class="cmtt-10"> b 
</span>
</span> , so that the remaining goal list is 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb92">
<a id="x18-27034r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  g(b),h(b). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> But 
<span class="verb">
<span class="cmtt-10"> g(b) 
</span>
</span> is a fact in the knowledge base, so this is satisfied too, leaving the goal list: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb93">
<a id="x18-27036r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  h(b). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Moreover, this fact too is in the knowledge base, so this goal is also satisfied. So Prolog now has an empty list of goals. This means that it has now proved everything required to establish the original goal (that is, 
<span class="verb">
<span class="cmtt-10"> k(Y) 
</span>
</span> ). So the original query 
<span class="cmti-10"> is 
</span> satisfiable, and moreover, Prolog has also discovered what it has to do to satisfy it (namely instantiate 
<span class="verb">
<span class="cmtt-10"> Y 
</span>
</span> to 
<span class="verb">
<span class="cmtt-10"> b 
</span>
</span> ). 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> It is interesting to consider what happens if we then ask for another solution by typing: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb94">
<a id="x18-27038r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ; 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> This forces Prolog to backtrack to the last choice point, to try and find another possibility. However, there are no other choice points, as there are no other possibilities for unifying 
<span class="verb">
<span class="cmtt-10"> h(b) 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> g(b) 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> f(_G34) 
</span>
</span> , or 
<span class="verb">
<span class="cmtt-10"> k(Y) 
</span>
</span> with clauses in the knowledge base, so Prolog would respond no. On the other hand, if there had been other rules involving 
<span class="verb">
<span class="cmtt-10"> k 
</span>
</span> , Prolog would have gone off and tried to use them in exactly the way we have described: that is, by searching top to bottom in the knowledge base, left to right in goal lists, and backtracking to the previous choice point whenever it fails. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Let’s take a look at the graphical representation of the entire search process. Some general remarks are called for, for such representations are an important way of thinking about proof search in Prolog. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="center">
<!--l. 833-->
<p class="noindent">
</p>
<!--l. 834-->
<p class="noindent">
<img alt="*Pic not found*" src="html/chap2-pspic4.ps.png"/>
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> This diagram has the form of a tree; in fact it is our first example of what is known as a search tree. The nodes of such trees say which goals have to be satisfied at the various steps of the proof search, and the edges keep track of the variable instantiations that are made when the current goal (that is, the first one in the list of goals) is unified to a fact or to the head of a rule in the knowledge base. Leaf nodes which still contain unsatisfied goals are points where Prolog failed (either because it made a wrong decision somewhere along the path, or because no solution exists). Leaf nodes with an empty goal list correspond to a possible solution. The edges along the path from the root node to a successful leaf node tell you the variable instantiations that need to be made to satisfy the original query. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Let’s have a look at another example. Suppose that we are working with the following knowledge base: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb95">
<a id="x18-27040r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  loves(vincent,mia). 
</span>
<br class="fancyvrb"/>
<a id="x18-27042r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  loves(marcellus,mia). 
</span>
<br class="fancyvrb"/>
<a id="x18-27044r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x18-27046r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  jealous(A,B):- 
</span>
<span class="cmtt-10">  loves(A,C), 
</span>
<span class="cmtt-10">  loves(B,C). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Now we pose the query 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb96">
<a id="x18-27048r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  jealous(X,Y). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> The search tree for the query looks like this: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="center">
<!--l. 866-->
<p class="noindent">
</p>
<!--l. 867-->
<p class="noindent">
<img alt="*Pic not found*" src="html/chap2-pspic5.ps.png"/>
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> There is only one possible way of unifying 
<span class="verb">
<span class="cmtt-10"> jealous(X,Y) 
</span>
</span> against the knowledge base, namely by using the rule 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb97">
<a id="x18-27050r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  jealous(A,B):- 
</span>
<span class="cmtt-10">  loves(A,C), 
</span>
<span class="cmtt-10">  loves(B,C). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> So the new goals that have to be satisfied are: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb98">
<a id="x18-27052r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  loves(_G5,_G6),loves(_G7,_G6) 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Now we have to unify 
<span class="verb">
<span class="cmtt-10"> loves(_G5,_G6) 
</span>
</span> against the knowledge base. There are two ways of doing this (it can either be unified with the first fact or with the second fact) and this is why the path branches at this point. In both cases the goal 
<span class="verb">
<span class="cmtt-10"> loves(_G7,mia) 
</span>
</span> remains, and this can also be satisfied by using either of two facts. All in all there are four leaf nodes with an empty goal list, which means that there are four ways of satisfying the original query. The variable instantiations for each solution can be read off the path from the root to the leaf node. So the four solutions are: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<ol class="enumerate1">
<li class="enumerate" id="x18-27054x1">
<span class="verb">
<span class="cmtt-10"> X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  _G5 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  vincent 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> Y 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  _G7 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  vincent 
</span>
</span>
</li>
<li class="enumerate" id="x18-27056x2">
<span class="verb">
<span class="cmtt-10"> X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  _G5 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  vincent 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> Y 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  _G7 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  marcellus 
</span>
</span>
</li>
<li class="enumerate" id="x18-27058x3">
<span class="verb">
<span class="cmtt-10"> X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  _G5 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  marcellus 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> Y 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  _G7 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  vincent 
</span>
</span>
</li>
<li class="enumerate" id="x18-27060x4">
<span class="verb">
<span class="cmtt-10"> X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  _G5 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  marcellus 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> Y 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  _G7 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  marcellus 
</span>
</span>
</li>
</ol>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Work through this example carefully, and make sure you understand it. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse7"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse5"> prev 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse5"> prev-tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse6"> front 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch2"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse8"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse6"> prev 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse6"> prev-tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=#taillpn-htmlse7"> tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch2"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<h3 class="sectionHead">
<span class="titlemark"> 2.3 
</span>
<a id="x19-280002.3">
</a> <strong>Exercise</strong>s 
</h3>
</div>
<div class="nb-cell html" name="htm1">
<div class="newtheorem">
<!--l. 904-->
<p class="noindent">
<span class="head">
<span class="cmbx-10"> <strong>Exercise</strong>
</span>
<span class="cmbx-10">  2.1 
</span>
</span>
<a id="x19-280011">
</a>
<span class="cmti-10"> Which of the following pairs of terms unify? Where relevant, give the 
</span>
<span class="cmti-10"> variable instantiations that lead to successful unification. 
</span>
</p>
<ol class="enumerate1">
<li class="enumerate" id="x19-28003x1">
<span class="verb">
<span class="cmtt-10"> bread 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  bread 
</span>
</span>
</li>
<li class="enumerate" id="x19-28005x2">
<span class="verb">
<span class="cmtt-10"> ’Bread’ 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  bread 
</span>
</span>
</li>
<li class="enumerate" id="x19-28007x3">
<span class="verb">
<span class="cmtt-10"> ’bread’ 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  bread 
</span>
</span>
</li>
<li class="enumerate" id="x19-28009x4">
<span class="verb">
<span class="cmtt-10"> Bread 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  bread 
</span>
</span>
</li>
<li class="enumerate" id="x19-28011x5">
<span class="verb">
<span class="cmtt-10"> bread 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  sausage 
</span>
</span>
</li>
<li class="enumerate" id="x19-28013x6">
<span class="verb">
<span class="cmtt-10"> food(bread) 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  bread 
</span>
</span>
</li>
<li class="enumerate" id="x19-28015x7">
<span class="verb">
<span class="cmtt-10"> food(bread) 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  X 
</span>
</span>
</li>
<li class="enumerate" id="x19-28017x8">
<span class="verb">
<span class="cmtt-10"> food(X) 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  food(bread) 
</span>
</span>
</li>
<li class="enumerate" id="x19-28019x9">
<span class="verb">
<span class="cmtt-10"> food(bread,X) 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  food(Y,sausage) 
</span>
</span>
</li>
<li class="enumerate" id="x19-28021x10">
<span class="verb">
<span class="cmtt-10"> food(bread,X,beer) 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  food(Y,sausage,X) 
</span>
</span>
</li>
<li class="enumerate" id="x19-28023x11">
<span class="verb">
<span class="cmtt-10"> food(bread,X,beer) 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  food(Y,kahuna_burger) 
</span>
</span>
</li>
<li class="enumerate" id="x19-28025x12">
<span class="verb">
<span class="cmtt-10"> food(X) 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  X 
</span>
</span>
</li>
<li class="enumerate" id="x19-28027x13">
<span class="verb">
<span class="cmtt-10"> meal(food(bread),drink(beer)) 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  meal(X,Y) 
</span>
</span>
</li>
<li class="enumerate" id="x19-28029x14">
<span class="verb">
<span class="cmtt-10"> meal(food(bread),X) 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  meal(X,drink(beer)) 
</span>
</span>
</li>
</ol>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="newtheorem">
<!--l. 925-->
<p class="noindent">
<span class="head">
<span class="cmbx-10"> <strong>Exercise</strong>
</span>
<span class="cmbx-10">  2.2 
</span>
</span>
<a id="x19-280302">
</a>
<span class="cmti-10"> We are working with the following knowledge base: 
</span>
</p>
<div class="fancyvrb" id="fancyvrb99">
<a id="x19-28032r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  house_elf(dobby). 
</span>
<br class="fancyvrb"/>
<a id="x19-28034r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  witch(hermione). 
</span>
<br class="fancyvrb"/>
<a id="x19-28036r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  witch(’McGonagall’). 
</span>
<br class="fancyvrb"/>
<a id="x19-28038r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  witch(rita_skeeter). 
</span>
<br class="fancyvrb"/>
<a id="x19-28040r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  magic(X):- 
</span>
<span class="cmtt-10">  house_elf(X). 
</span>
<br class="fancyvrb"/>
<a id="x19-28042r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  magic(X):- 
</span>
<span class="cmtt-10">  wizard(X). 
</span>
<br class="fancyvrb"/>
<a id="x19-28044r7">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  magic(X):- 
</span>
<span class="cmtt-10">  witch(X). 
</span>
</div>
<!--l. 937-->
<p class="indent">
<span class="cmti-10"> Which of the following queries are satisfied? Where relevant, give all the variable 
</span>
<span class="cmti-10"> instantiations that lead to success. 
</span>
</p>
<ol class="enumerate1">
<li class="enumerate" id="x19-28046x1">
<span class="verb">
<span class="cmtt-10"> ?- 
</span>
<span class="cmtt-10">  magic(house_elf). 
</span>
</span>
</li>
<li class="enumerate" id="x19-28048x2">
<span class="verb">
<span class="cmtt-10"> ?- 
</span>
<span class="cmtt-10">  wizard(harry). 
</span>
</span>
</li>
<li class="enumerate" id="x19-28050x3">
<span class="verb">
<span class="cmtt-10"> ?- 
</span>
<span class="cmtt-10">  magic(wizard). 
</span>
</span>
</li>
<li class="enumerate" id="x19-28052x4">
<span class="verb">
<span class="cmtt-10"> ?- 
</span>
<span class="cmtt-10">  magic(’McGonagall’). 
</span>
</span>
</li>
<li class="enumerate" id="x19-28054x5">
<span class="verb">
<span class="cmtt-10"> ?- 
</span>
<span class="cmtt-10">  magic(Hermione). 
</span>
</span>
</li>
</ol>
<!--l. 946-->
<p class="noindent">
<span class="cmti-10"> Draw the search tree for the query 
</span>
<span class="verb">
<span class="cmtt-10"> magic(Hermione) 
</span>
</span>
<span class="cmti-10"> . 
</span>
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="newtheorem">
<!--l. 950-->
<p class="noindent">
<span class="head">
<span class="cmbx-10"> <strong>Exercise</strong>
</span>
<span class="cmbx-10">  2.3 
</span>
</span>
<a id="x19-280553">
</a>
<span class="cmti-10"> Here is a tiny lexicon (that is, information about individual 
</span>
<span class="cmti-10"> words) and a mini grammar consisting of one syntactic rule (which defines 
</span>
<span class="cmti-10"> a sentence to be an entity consisting of five words in the following order: a 
</span>
<span class="cmti-10"> determiner, a noun, a verb, a determiner, a noun). 
</span>
</p>
<!--l. 956-->
<p class="indent">
</p>
<div class="fancyvrb" id="fancyvrb100">
<a id="x19-28057r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  word(determiner,a). 
</span>
<br class="fancyvrb"/>
<a id="x19-28059r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  word(determiner,every). 
</span>
<br class="fancyvrb"/>
<a id="x19-28061r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  word(noun,criminal). 
</span>
<br class="fancyvrb"/>
<a id="x19-28063r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  word(noun,’big 
</span>
<span class="cmtt-10">  kahuna 
</span>
<span class="cmtt-10">  burger’). 
</span>
<br class="fancyvrb"/>
<a id="x19-28065r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  word(verb,eats). 
</span>
<br class="fancyvrb"/>
<a id="x19-28067r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  word(verb,likes). 
</span>
<br class="fancyvrb"/>
<a id="x19-28069r7">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x19-28071r8">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  sentence(Word1,Word2,Word3,Word4,Word5):- 
</span>
<br class="fancyvrb"/>
<a id="x19-28073r9">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  word(determiner,Word1), 
</span>
<br class="fancyvrb"/>
<a id="x19-28075r10">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  word(noun,Word2), 
</span>
<br class="fancyvrb"/>
<a id="x19-28077r11">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  word(verb,Word3), 
</span>
<br class="fancyvrb"/>
<a id="x19-28079r12">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  word(determiner,Word4), 
</span>
<br class="fancyvrb"/>
<a id="x19-28081r13">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  word(noun,Word5). 
</span>
</div>
<!--l. 971-->
<p class="noindent">
<span class="cmti-10"> What query do you have to pose in order to find out which sentences the grammar can 
</span>
<span class="cmti-10"> generate? List all sentences that this grammar can generate in the order that Prolog 
</span>
<span class="cmti-10"> will generate them in. 
</span>
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="newtheorem">
<!--l. 978-->
<p class="noindent">
<span class="head">
<span class="cmbx-10"> <strong>Exercise</strong>
</span>
<span class="cmbx-10">  2.4 
</span>
</span>
<a id="x19-280824">
</a>
<span class="cmti-10"> Here are six Italian words: 
</span>
</p>
<!--l. 980-->
<p class="indent"> astante 
<span class="cmti-10"> , 
</span> astoria 
<span class="cmti-10"> , 
</span> baratto 
<span class="cmti-10"> , 
</span> cobalto 
<span class="cmti-10"> , 
</span> pistola 
<span class="cmti-10"> , 
</span> statale 
<span class="cmti-10"> . 
</span>
</p>
<!--l. 983-->
<p class="noindent">
<span class="cmti-10"> They are to be arranged, crossword puzzle fashion, in the following grid: 
</span>
</p>
<div class="center">
<!--l. 988-->
<p class="noindent">
</p>
<!--l. 989-->
<p class="noindent">
<img alt="*Pic not found*" src="html/crosswd2.eps.png"/>
</p>
</div>
<!--l. 993-->
<p class="indent">
<span class="cmti-10"> The following knowledge base represents a lexicon containing these words: 
</span>
</p>
<div class="fancyvrb" id="fancyvrb101">
<a id="x19-28084r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  word(astante, 
</span>
<span class="cmtt-10">  a,s,t,a,n,t,e). 
</span>
<br class="fancyvrb"/>
<a id="x19-28086r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  word(astoria, 
</span>
<span class="cmtt-10">  a,s,t,o,r,i,a). 
</span>
<br class="fancyvrb"/>
<a id="x19-28088r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  word(baratto, 
</span>
<span class="cmtt-10">  b,a,r,a,t,t,o). 
</span>
<br class="fancyvrb"/>
<a id="x19-28090r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  word(cobalto, 
</span>
<span class="cmtt-10">  c,o,b,a,l,t,o). 
</span>
<br class="fancyvrb"/>
<a id="x19-28092r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  word(pistola, 
</span>
<span class="cmtt-10">  p,i,s,t,o,l,a). 
</span>
<br class="fancyvrb"/>
<a id="x19-28094r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  word(statale, 
</span>
<span class="cmtt-10">  s,t,a,t,a,l,e). 
</span>
</div>
<!--l. 1003-->
<p class="noindent">
<span class="cmti-10"> Write a predicate 
</span>
<span class="verb">
<span class="cmtt-10"> crossword/6 
</span>
</span>
<span class="cmti-10"> that tells us how to fill in the grid. The first three 
</span>
<span class="cmti-10"> arguments should be the vertical words from left to right, and the last three arguments 
</span>
<span class="cmti-10"> the horizontal words from top to bottom. 
</span>
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse8"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse6"> prev 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse6"> prev-tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse7"> front 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch2"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse7"> prev 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse7"> prev-tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=#taillpn-htmlse8"> tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch2"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<h3 class="sectionHead">
<span class="titlemark"> 2.4 
</span>
<a id="x20-290002.4">
</a> Practical Session 
</h3>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> By this stage, you should have had your first taste of running Prolog programs. The purpose of the second practical session is to suggest two sets of keyboard exercises which will help you get familiar with the way Prolog works. The first set has to do with unification, the second with proof search. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> First of all, start up your Prolog interpreter. That is, get a screen displaying the usual “I’m ready to start” prompt, which probably looks something like: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb102">
<a id="x20-29002r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Verify your answers to <strong>Exercise</strong> 2.1, the unification examples. You don’t need to consult any knowledge bases, simply ask Prolog directly whether it is possible to unify the terms by using the built-in 
<span class="verb">
<span class="cmtt-10"> =/2 
</span>
</span> predicate. For example, to test whether 
<span class="verb">
<span class="cmtt-10"> food(bread,X) 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> food(Y,sausage) 
</span>
</span> unify, just type in 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb103">
<a id="x20-29004r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  food(bread,X) 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  food(Y,sausage). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> and hit return. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> You should also look at what happens when your Prolog implementation attempts to unify terms that can’t be unified because it doesn’t carry out an occurs check. For example, see what happens when you give it the following query: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb104">
<a id="x20-29006r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  g(X,Y) 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  Y. 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> If it handles such examples, try the trickier one mentioned in the text: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb105">
<a id="x20-29008r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  f(X), 
</span>
<span class="cmtt-10">  Y 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  f(Y), 
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  Y. 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Once you’ve experimented with that, it’s time to move on to something new. There is another built-in Prolog predicate for answering queries about unification, namely 
<span class="verb">
<span class="cmtt-10"> \=/2 
</span>
</span> (that is: the 2-place predicate 
<span class="verb">
<span class="cmtt-10"> \= 
</span>
</span> ). 
<a id="dx20-29009">
</a> This works in the opposite way to the 
<span class="verb">
<span class="cmtt-10"> =/2 
</span>
</span> predicate: it succeeds when its two arguments do 
<span class="cmti-10"> not 
</span> unify. For example, the terms 
<span class="verb">
<span class="cmtt-10"> a 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> b 
</span>
</span> do not unify, which explains the following dialogue: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb106">
<a id="x20-29011r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  a 
</span>
<span class="cmtt-10">  \= 
</span>
<span class="cmtt-10">  b. 
</span>
<br class="fancyvrb"/>
<a id="x20-29013r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Make sure you understand how 
<span class="verb">
<span class="cmtt-10"> \=/2 
</span>
</span> works by trying it out on (at least) the following examples. But do this actively, not passively. That is, after you type in an example, pause, and try to work out for yourself what Prolog is going to respond. Only then hit return to see if you are right. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<ol class="enumerate1">
<li class="enumerate" id="x20-29015x1">
<span class="verb">
<span class="cmtt-10"> a 
</span>
<span class="cmtt-10">  \= 
</span>
<span class="cmtt-10">  a 
</span>
</span>
</li>
<li class="enumerate" id="x20-29017x2">
<span class="verb">
<span class="cmtt-10"> ’a’ 
</span>
<span class="cmtt-10">  \= 
</span>
<span class="cmtt-10">  a 
</span>
</span>
</li>
<li class="enumerate" id="x20-29019x3">
<span class="verb">
<span class="cmtt-10"> A 
</span>
<span class="cmtt-10">  \= 
</span>
<span class="cmtt-10">  a 
</span>
</span>
</li>
<li class="enumerate" id="x20-29021x4">
<span class="verb">
<span class="cmtt-10"> f(a) 
</span>
<span class="cmtt-10">  \= 
</span>
<span class="cmtt-10">  a 
</span>
</span>
</li>
<li class="enumerate" id="x20-29023x5">
<span class="verb">
<span class="cmtt-10"> f(a) 
</span>
<span class="cmtt-10">  \= 
</span>
<span class="cmtt-10">  A 
</span>
</span>
</li>
<li class="enumerate" id="x20-29025x6">
<span class="verb">
<span class="cmtt-10"> f(A) 
</span>
<span class="cmtt-10">  \= 
</span>
<span class="cmtt-10">  f(a) 
</span>
</span>
</li>
<li class="enumerate" id="x20-29027x7">
<span class="verb">
<span class="cmtt-10"> g(a,B,c) 
</span>
<span class="cmtt-10">  \= 
</span>
<span class="cmtt-10">  g(A,b,C) 
</span>
</span>
</li>
<li class="enumerate" id="x20-29029x8">
<span class="verb">
<span class="cmtt-10"> g(a,b,c) 
</span>
<span class="cmtt-10">  \= 
</span>
<span class="cmtt-10">  g(A,C) 
</span>
</span>
</li>
<li class="enumerate" id="x20-29031x9">
<span class="verb">
<span class="cmtt-10"> f(X) 
</span>
<span class="cmtt-10">  \= 
</span>
<span class="cmtt-10">  X 
</span>
</span>
</li>
</ol>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Thus the 
<span class="verb">
<span class="cmtt-10"> \=/2 
</span>
</span> predicate is (essentially) the negation of the 
<span class="verb">
<span class="cmtt-10"> =/2 
</span>
</span> predicate: a query involving one of these predicates will be satisfied when the corresponding query involving the other is not, and vice versa. This is the first example we have seen of a Prolog mechanism for handling negation. We discuss Prolog negation (and its peculiarities) in Chapter  
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch10"> 10 
<!--tex4ht:ref: CHAPTER10 -->
</a> . 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> It’s time to move on and introduce one of the most helpful tools in Prolog: 
<span class="verb">
<span class="cmtt-10"> trace 
</span>
</span> . 
<a id="dx20-29032">
</a> This is a built-in Prolog predicate that changes the way Prolog runs: it forces Prolog to evaluate queries one step at a time, indicating what it is doing at each step. Prolog waits for you to press return before it moves to the next step, so that you can see exactly what is going on. It was really designed to be used as a debugging tool, but it’s also helpful when you’re learning Prolog: stepping through programs using 
<span class="verb">
<span class="cmtt-10"> trace 
</span>
</span> is an 
<span class="cmti-10"> excellent 
</span> way of learning how Prolog proof search works. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Let’s look at an example. In the text, we looked at the proof search involved when we made the query 
<span class="verb">
<span class="cmtt-10"> k(Y) 
</span>
</span> to the following knowledge base: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb107">
<a id="x20-29034r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  f(a). 
</span>
<br class="fancyvrb"/>
<a id="x20-29036r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  f(b). 
</span>
<br class="fancyvrb"/>
<a id="x20-29038r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x20-29040r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  g(a). 
</span>
<br class="fancyvrb"/>
<a id="x20-29042r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  g(b). 
</span>
<br class="fancyvrb"/>
<a id="x20-29044r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x20-29046r7">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  h(b). 
</span>
<br class="fancyvrb"/>
<a id="x20-29048r8">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x20-29050r9">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  k(X):- 
</span>
<span class="cmtt-10">  f(X), 
</span>
<span class="cmtt-10">  g(X), 
</span>
<span class="cmtt-10">  h(X). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Suppose this knowledge base is in file 
<span class="verb">
<span class="cmtt-10"> proof.pl 
</span>
</span> . We first consult it: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb108">
<a id="x20-29052r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  [proof]. 
</span>
<br class="fancyvrb"/>
<a id="x20-29054r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> We then type 
<span class="verb">
<span class="cmtt-10"> trace 
</span>
</span> , followed by a full stop, and hit return: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb109">
<a id="x20-29056r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  trace. 
</span>
<br class="fancyvrb"/>
<a id="x20-29058r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Prolog is now in trace mode, and will evaluate all queries step by step. For example, if we pose the query 
<span class="verb">
<span class="cmtt-10"> k(X) 
</span>
</span> , and then hit return every time Prolog comes back with a 
<span class="verb">
<span class="cmtt-10"> ? 
</span>
</span> , we obtain (something like) the following: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb110">
<a id="x20-29060r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  [trace] 
</span>
<span class="cmtt-10">  2 
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  k(X). 
</span>
<br class="fancyvrb"/>
<a id="x20-29062r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Call: 
</span>
<span class="cmtt-10">  (6) 
</span>
<span class="cmtt-10">  k(_G34) 
</span>
<span class="cmtt-10">  ? 
</span>
<br class="fancyvrb"/>
<a id="x20-29064r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Call: 
</span>
<span class="cmtt-10">  (7) 
</span>
<span class="cmtt-10">  f(_G34) 
</span>
<span class="cmtt-10">  ? 
</span>
<br class="fancyvrb"/>
<a id="x20-29066r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Exit: 
</span>
<span class="cmtt-10">  (7) 
</span>
<span class="cmtt-10">  f(a) 
</span>
<span class="cmtt-10">  ? 
</span>
<br class="fancyvrb"/>
<a id="x20-29068r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Call: 
</span>
<span class="cmtt-10">  (7) 
</span>
<span class="cmtt-10">  g(a) 
</span>
<span class="cmtt-10">  ? 
</span>
<br class="fancyvrb"/>
<a id="x20-29070r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Exit: 
</span>
<span class="cmtt-10">  (7) 
</span>
<span class="cmtt-10">  g(a) 
</span>
<span class="cmtt-10">  ? 
</span>
<br class="fancyvrb"/>
<a id="x20-29072r7">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Call: 
</span>
<span class="cmtt-10">  (7) 
</span>
<span class="cmtt-10">  h(a) 
</span>
<span class="cmtt-10">  ? 
</span>
<br class="fancyvrb"/>
<a id="x20-29074r8">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Fail: 
</span>
<span class="cmtt-10">  (7) 
</span>
<span class="cmtt-10">  h(a) 
</span>
<span class="cmtt-10">  ? 
</span>
<br class="fancyvrb"/>
<a id="x20-29076r9">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Fail: 
</span>
<span class="cmtt-10">  (7) 
</span>
<span class="cmtt-10">  g(a) 
</span>
<span class="cmtt-10">  ? 
</span>
<br class="fancyvrb"/>
<a id="x20-29078r10">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Redo: 
</span>
<span class="cmtt-10">  (7) 
</span>
<span class="cmtt-10">  f(_G34) 
</span>
<span class="cmtt-10">  ? 
</span>
<br class="fancyvrb"/>
<a id="x20-29080r11">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Exit: 
</span>
<span class="cmtt-10">  (7) 
</span>
<span class="cmtt-10">  f(b) 
</span>
<span class="cmtt-10">  ? 
</span>
<br class="fancyvrb"/>
<a id="x20-29082r12">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Call: 
</span>
<span class="cmtt-10">  (7) 
</span>
<span class="cmtt-10">  g(b) 
</span>
<span class="cmtt-10">  ? 
</span>
<br class="fancyvrb"/>
<a id="x20-29084r13">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Exit: 
</span>
<span class="cmtt-10">  (7) 
</span>
<span class="cmtt-10">  g(b) 
</span>
<span class="cmtt-10">  ? 
</span>
<br class="fancyvrb"/>
<a id="x20-29086r14">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Call: 
</span>
<span class="cmtt-10">  (7) 
</span>
<span class="cmtt-10">  h(b) 
</span>
<span class="cmtt-10">  ? 
</span>
<br class="fancyvrb"/>
<a id="x20-29088r15">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Exit: 
</span>
<span class="cmtt-10">  (7) 
</span>
<span class="cmtt-10">  h(b) 
</span>
<span class="cmtt-10">  ? 
</span>
<br class="fancyvrb"/>
<a id="x20-29090r16">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Exit: 
</span>
<span class="cmtt-10">  (6) 
</span>
<span class="cmtt-10">  k(b) 
</span>
<span class="cmtt-10">  ? 
</span>
<br class="fancyvrb"/>
<a id="x20-29092r17">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x20-29094r18">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  b 
</span>
<br class="fancyvrb"/>
<a id="x20-29096r19">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Study this carefully. That is, try doing the same thing yourself, and relate this output to the discussion of the example in the text, and in particular, to the nodes in the search tree. To get you started, we’ll remark that the third line is where the variable in the query is (wrongly) instantiated to 
<span class="verb">
<span class="cmtt-10"> a 
</span>
</span> . The first line marked 
<span class="verb">
<span class="cmtt-10"> fail 
</span>
</span> is where Prolog realises it’s taken the wrong path and starts to backtrack, and the line marked 
<span class="verb">
<span class="cmtt-10"> redo 
</span>
</span> is where it tries alternatives for the goal 
<span class="verb">
<span class="cmtt-10"> f(_G34) 
</span>
</span> . 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> While learning Prolog, use trace, and use it heavily. It’s a great way to learn. Oh yes: you also need to know how to turn trace off. Simply type notrace 
<a id="dx20-29097">
</a> (followed by a full stop) and hit return: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb111">
<a id="x20-29099r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  notrace. 
</span>
<br class="fancyvrb"/>
<a id="x20-29101r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse7"> prev 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse7"> prev-tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse8"> front 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch2"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse10"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=#taillpn-htmlse9"> tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch3"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<h3 class="sectionHead">
<span class="titlemark"> 3.1 
</span>
<a id="x22-310003.1">
</a> Recursive Definitions 
</h3>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Predicates can be defined recursively. Roughly speaking, a predicate is recursively defined if one or more rules in its definition refers to itself. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent">
</p>
</div>
<div class="nb-cell html" name="htm1">
<h4 class="likesubsectionHead">
<a id="x22-320003.1">
</a> Example 1: Eating 
</h4>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Consider the following knowledge base: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb112">
<a id="x22-32002r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  is_digesting(X,Y) 
</span>
<span class="cmtt-10">  :- 
</span>
<span class="cmtt-10">  just_ate(X,Y). 
</span>
<br class="fancyvrb"/>
<a id="x22-32004r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  is_digesting(X,Y) 
</span>
<span class="cmtt-10">  :- 
</span>
<br class="fancyvrb"/>
<a id="x22-32006r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  just_ate(X,Z), 
</span>
<br class="fancyvrb"/>
<a id="x22-32008r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  is_digesting(Z,Y). 
</span>
<br class="fancyvrb"/>
<a id="x22-32010r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x22-32012r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  just_ate(mosquito,blood(john)). 
</span>
<br class="fancyvrb"/>
<a id="x22-32014r7">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  just_ate(frog,mosquito). 
</span>
<br class="fancyvrb"/>
<a id="x22-32016r8">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  just_ate(stork,frog). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> At first glance this seems pretty ordinary: it’s just a knowledge base containing three facts and two rules. But the definition of the 
<span class="verb">
<span class="cmtt-10"> is_digesting/2 
</span>
</span> predicate is recursive. Note that 
<span class="verb">
<span class="cmtt-10"> is_digesting/2 
</span>
</span> is (at least partially) defined in terms of itself, for the 
<span class="verb">
<span class="cmtt-10"> is_digesting/2 
</span>
</span> functor occurs in both the head and body of the second rule. Crucially, however, there is an ‘escape’ from this circularity. This is provided by the 
<span class="verb">
<span class="cmtt-10"> just_ate/2 
</span>
</span> predicate, which occurs in the first rule. (Significantly, the body of the first rule makes no mention of 
<span class="verb">
<span class="cmtt-10"> is_digesting/2 
</span>
</span> .) Let’s now consider both the declarative and procedural meanings of this definition. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> The word “declarative” is used to talk about the logical meaning of Prolog knowledge bases. That is, the declarative meaning of a Prolog knowledge base is simply “what it says”, or “what it means, if we read it as a collection of logical statements”. And the declarative meaning of this recursive definition is fairly straightforward. The first clause (the escape clause, the one that is not recursive, or as we shall usually call it, the base clause), simply says that: 
<span class="cmti-10"> if 
</span>
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> has just eaten 
<span class="verb">
<span class="cmtt-10"> Y 
</span>
</span> , 
<span class="cmti-10"> then 
</span>
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> is now digesting 
<span class="verb">
<span class="cmtt-10"> Y 
</span>
</span> . This is obviously a sensible definition. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> So what about the second clause, the recursive clause? This says that: 
<span class="cmti-10"> if 
</span>
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> has just eaten 
<span class="verb">
<span class="cmtt-10"> Z 
</span>
</span>
<span class="cmti-10"> and 
</span>
<span class="verb">
<span class="cmtt-10"> Z 
</span>
</span> is digesting 
<span class="verb">
<span class="cmtt-10"> Y 
</span>
</span> , 
<span class="cmti-10"> then 
</span>
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> is digesting 
<span class="verb">
<span class="cmtt-10"> Y 
</span>
</span> , too. Again, this is obviously a sensible definition. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> So now we know what this recursive definition says, but what happens when we pose a query that actually needs to use this definition? That is, what does this definition actually do? To use the normal Prolog terminology, what is its procedural meaning? 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> This is also reasonably straightforward. The base rule is like all the earlier rules we’ve seen. That is, if we ask whether 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> is digesting 
<span class="verb">
<span class="cmtt-10"> Y 
</span>
</span> , Prolog can use this rule to ask instead the question: has 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> just eaten 
<span class="verb">
<span class="cmtt-10"> Y 
</span>
</span> ? 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> What about the recursive clause? This gives Prolog another strategy for determining whether 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> is digesting 
<span class="verb">
<span class="cmtt-10"> Y 
</span>
</span> : 
<span class="cmti-10"> it can try to find some 
</span>
<span class="verb">
<span class="cmtt-10"> Z 
</span>
</span>
<span class="cmti-10"> such that 
</span>
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span>
<span class="cmti-10"> has just 
</span>
<span class="cmti-10"> eaten 
</span>
<span class="verb">
<span class="cmtt-10"> Z 
</span>
</span> , and 
<span class="verb">
<span class="cmtt-10"> Z 
</span>
</span>
<span class="cmti-10"> is digesting 
</span>
<span class="verb">
<span class="cmtt-10"> Y 
</span>
</span> . That is, this rule lets Prolog break the task apart into two subtasks. Hopefully, doing so will eventually lead to simple problems which can be solved by simply looking up the answers in the knowledge base. The following picture sums up the situation: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="center">
<!--l. 94-->
<p class="noindent">
</p>
<!--l. 95-->
<p class="noindent">
<img alt="*Pic not found*" src="html/chap3-pspic3.ps.png"/>
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Let’s see how this works. If we pose the query: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb113">
<a id="x22-32018r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  is_digesting(stork,mosquito). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> then Prolog goes to work as follows. First, it tries to make use of the first rule listed concerning 
<span class="verb">
<span class="cmtt-10"> is_digesting 
</span>
</span> ; that is, the base rule. This tells it that 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> is digesting 
<span class="verb">
<span class="cmtt-10"> Y 
</span>
</span> if 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> just ate 
<span class="verb">
<span class="cmtt-10"> Y 
</span>
</span> , By unifying 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> with 
<span class="verb">
<span class="cmtt-10"> stork 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> Y 
</span>
</span> with 
<span class="verb">
<span class="cmtt-10"> mosquito 
</span>
</span> it obtains the following goal: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb114">
<a id="x22-32020r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  just_ate(stork,mosquito). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> But the knowledge base doesn’t contain the information that the stork just ate the mosquito, so this attempt fails. So Prolog next tries to make use of the second rule. By unifying 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> with 
<span class="verb">
<span class="cmtt-10"> stork 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> Y 
</span>
</span> with 
<span class="verb">
<span class="cmtt-10"> mosquito 
</span>
</span> it obtains the following goals: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb115">
<a id="x22-32022r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  just_ate(stork,Z), 
</span>
<br class="fancyvrb"/>
<a id="x22-32024r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  is_digesting(Z,mosquito). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> That is, to show 
<span class="verb">
<span class="cmtt-10"> is_digesting(stork,mosquito) 
</span>
</span> , Prolog needs to find a value for 
<span class="verb">
<span class="cmtt-10"> Z 
</span>
</span> such that, firstly, 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb116">
<a id="x22-32026r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  just_ate(stork,Z). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> and secondly, 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb117">
<a id="x22-32028r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  is_digesting(Z,mosquito). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> And there 
<span class="cmti-10"> is 
</span> such a value for 
<span class="verb">
<span class="cmtt-10"> Z 
</span>
</span> , namely 
<span class="verb">
<span class="cmtt-10"> frog 
</span>
</span> . It is immediate that 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb118">
<a id="x22-32030r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  just_ate(stork,frog). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> will succeed, for this fact is listed in the knowledge base. And deducing 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb119">
<a id="x22-32032r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  is_digesting(frog,mosquito). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> is almost as simple, for the first clause of 
<span class="verb">
<span class="cmtt-10"> is_digesting/2 
</span>
</span> reduces this goal to deducing 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb120">
<a id="x22-32034r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  just_ate(frog,mosquito). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> and this is a fact listed in the knowledge base. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Well, that’s our first example of a recursive rule definition. We’re going to learn a lot more about them, but one very practical remark should be made right away. Hopefully it’s clear that when you write a recursive predicate, it should always have at least two clauses: a base clause (the clause that stops the recursion at some point), and one that contains the recursion. If you don’t do this, Prolog can spiral off into an unending sequence of useless computations. For example, here’s an extremely simple example of a recursive rule definition: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb121">
<a id="x22-32036r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  p 
</span>
<span class="cmtt-10">  :- 
</span>
<span class="cmtt-10">  p. 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> That’s it. Nothing else. It’s beautiful in its simplicity. And from a declarative perspective it’s an extremely sensible (if rather boring) definition: it says “if property p holds, then property p holds”. You can’t argue with that. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> But from a procedural perspective, this is a wildly dangerous rule. In fact, we have here the ultimate in dangerous recursive rules: exactly the same thing on both sides, and no base clause to let us escape. For consider what happens when we pose the following query: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb122">
<a id="x22-32038r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  p. 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Prolog asks itself: “How do I prove 
<span class="verb">
<span class="cmtt-10"> p 
</span>
</span> ?” and it realises, “Hey, I’ve got a rule for that! To prove 
<span class="verb">
<span class="cmtt-10"> p 
</span>
</span> I just need to prove 
<span class="verb">
<span class="cmtt-10"> p 
</span>
</span> !”. So it asks itself (again): “How do I prove 
<span class="verb">
<span class="cmtt-10"> p 
</span>
</span> ?” and it realises, “Hey, I’ve got a rule for that! To prove 
<span class="verb">
<span class="cmtt-10"> p 
</span>
</span> I just need to prove 
<span class="verb">
<span class="cmtt-10"> p 
</span>
</span> !”. So it asks itself (yet again): “How do I prove 
<span class="verb">
<span class="cmtt-10"> p 
</span>
</span> ?” and it realises, “Hey, I’ve got a rule for that! To prove 
<span class="verb">
<span class="cmtt-10"> p 
</span>
</span> I just need to prove 
<span class="verb">
<span class="cmtt-10"> p 
</span>
</span> !” and so on and so forth. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> If you make this query, Prolog won’t answer you: it will head off, looping desperately away in an unending search. That is, it won’t terminate, and you’ll have to interrupt it. Of course, if you use 
<span class="verb">
<span class="cmtt-10"> trace 
</span>
</span> , you can step through one step at a time, until you get sick of watching Prolog loop. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent">
</p>
</div>
<div class="nb-cell html" name="htm1">
<h4 class="likesubsectionHead">
<a id="x22-330003.1">
</a> Example 2: Descendant 
</h4>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Now that we know something about 
<span class="cmti-10"> what 
</span> recursion in Prolog involves, it is time to ask 
<span class="cmti-10"> why 
</span> it is so important. Actually, this is a question that can be answered on a number of levels, but for now, let’s keep things fairly practical. So: when it comes to writing useful Prolog programs, are recursive definitions really so important? And if so, why? 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Let’s consider an example. Suppose we have a knowledge base recording facts about the child relation: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb123">
<a id="x22-33002r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  child(bridget,caroline). 
</span>
<br class="fancyvrb"/>
<a id="x22-33004r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  child(caroline,donna). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> That is, Caroline is a child of Bridget, and Donna is a child of Caroline. Now suppose we wished to define the descendant relation; that is, the relation of being a child of, or a child of a child of, or a child of a child of a child of, and so on. Here’s a first attempt to do this. We could add the following two 
<span class="cmti-10"> non 
</span> -recursive rules to the knowledge base: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb124">
<a id="x22-33006r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  descend(X,Y) 
</span>
<span class="cmtt-10">  :- 
</span>
<span class="cmtt-10">  child(X,Y). 
</span>
<br class="fancyvrb"/>
<a id="x22-33008r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x22-33010r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  descend(X,Y) 
</span>
<span class="cmtt-10">  :- 
</span>
<span class="cmtt-10">  child(X,Z), 
</span>
<br class="fancyvrb"/>
<a id="x22-33012r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  child(Z,Y). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Now, fairly obviously these definitions work up to a point, but they are clearly limited: they only define the concept of descendant-of for two generations or less. That’s ok for the above knowledge base, but suppose we get some more information about the child-of relation and we expand our list of child-of facts to this: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb125">
<a id="x22-33014r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  child(anne,bridget). 
</span>
<br class="fancyvrb"/>
<a id="x22-33016r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  child(bridget,caroline). 
</span>
<br class="fancyvrb"/>
<a id="x22-33018r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  child(caroline,donna). 
</span>
<br class="fancyvrb"/>
<a id="x22-33020r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  child(donna,emily). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Now our two rules are inadequate. For example, if we pose the queries 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb126">
<a id="x22-33022r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  descend(anne,donna). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> or 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb127">
<a id="x22-33024r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  descend(bridget,emily). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> we get the answer no, which is 
<span class="cmti-10"> not 
</span> what we want. Sure, we could ‘fix’ this by adding the following two rules: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb128">
<a id="x22-33026r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  descend(X,Y) 
</span>
<span class="cmtt-10">  :- 
</span>
<span class="cmtt-10">  child(X,Z_1), 
</span>
<br class="fancyvrb"/>
<a id="x22-33028r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  child(Z_1,Z_2), 
</span>
<br class="fancyvrb"/>
<a id="x22-33030r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  child(Z_2,Y). 
</span>
<br class="fancyvrb"/>
<a id="x22-33032r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x22-33034r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  descend(X,Y) 
</span>
<span class="cmtt-10">  :- 
</span>
<span class="cmtt-10">  child(X,Z_1), 
</span>
<br class="fancyvrb"/>
<a id="x22-33036r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  child(Z_1,Z_2), 
</span>
<br class="fancyvrb"/>
<a id="x22-33038r7">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  child(Z_2,Z_3), 
</span>
<br class="fancyvrb"/>
<a id="x22-33040r8">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  child(Z_3,Y). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> But, let’s face it, this is clumsy and hard to read. Moreover, if we add further child-of facts, we could easily find ourselves having to add more and more rules as our list of child-of facts grow, rules like: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb129">
<a id="x22-33042r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  descend(X,Y) 
</span>
<span class="cmtt-10">  :- 
</span>
<span class="cmtt-10">  child(X,Z_1), 
</span>
<br class="fancyvrb"/>
<a id="x22-33044r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  child(Z_1,Z_2), 
</span>
<br class="fancyvrb"/>
<a id="x22-33046r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  child(Z_2,Z_3), 
</span>
<br class="fancyvrb"/>
<a id="x22-33048r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  . 
</span>
<br class="fancyvrb"/>
<a id="x22-33050r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  . 
</span>
<br class="fancyvrb"/>
<a id="x22-33052r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  . 
</span>
<br class="fancyvrb"/>
<a id="x22-33054r7">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  child(Z_17,Z_18). 
</span>
<br class="fancyvrb"/>
<a id="x22-33056r8">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  child(Z_18,Z_19). 
</span>
<br class="fancyvrb"/>
<a id="x22-33058r9">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  child(Z_19,Y). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> This is not a particularly pleasant (or sensible) way to go! 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> But we don’t need to do this at all. We can avoid having to use ever longer rules entirely. The following recursive predicate definition fixes everything exactly the way we want: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb130">
<a id="x22-33060r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  descend(X,Y) 
</span>
<span class="cmtt-10">  :- 
</span>
<span class="cmtt-10">  child(X,Y). 
</span>
<br class="fancyvrb"/>
<a id="x22-33062r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x22-33064r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  descend(X,Y) 
</span>
<span class="cmtt-10">  :- 
</span>
<span class="cmtt-10">  child(X,Z), 
</span>
<br class="fancyvrb"/>
<a id="x22-33066r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  descend(Z,Y). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> What does this say? The declarative meaning of the base clause is: 
<span class="cmti-10"> if 
</span>
<span class="verb">
<span class="cmtt-10"> Y 
</span>
</span> is a child of 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> , 
<span class="cmti-10"> then 
</span>
<span class="verb">
<span class="cmtt-10"> Y 
</span>
</span> is a descendant of 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> . Obviously sensible. So what about the recursive clause? Its declarative meaning is: 
<span class="cmti-10"> if 
</span>
<span class="verb">
<span class="cmtt-10"> Z 
</span>
</span> is a child of 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> , 
<span class="cmti-10"> and 
</span>
<span class="verb">
<span class="cmtt-10"> Y 
</span>
</span> is a descendant of 
<span class="verb">
<span class="cmtt-10"> Z 
</span>
</span> , 
<span class="cmti-10"> then 
</span>
<span class="verb">
<span class="cmtt-10"> Y 
</span>
</span> is a descendant of 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> . Again, this is obviously true. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> So let’s now look at the procedural meaning of this recursive predicate, by stepping through an example. What happens when we pose the query: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb131">
<a id="x22-33068r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  descend(anne,donna) 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Prolog first tries the first rule. The variable 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> in the head of the rule is unified with 
<span class="verb">
<span class="cmtt-10"> anne 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> Y 
</span>
</span> with 
<span class="verb">
<span class="cmtt-10"> donna 
</span>
</span> and the next goal Prolog tries to prove is 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb132">
<a id="x22-33070r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  child(anne,donna) 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> This attempt fails, however, since the knowledge base neither contains the fact 
<span class="verb">
<span class="cmtt-10"> child(anne,donna) 
</span>
</span> nor any rules that would allow to infer it. So Prolog backtracks and looks for an alternative way of proving 
<span class="verb">
<span class="cmtt-10"> descend(anne,donna) 
</span>
</span> . It finds the second rule in the knowledge base and now has the following subgoals: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb133">
<a id="x22-33072r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  child(anne,_633), 
</span>
<br class="fancyvrb"/>
<a id="x22-33074r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  descend(_633,donna). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Prolog takes the first subgoal and tries to unify it with something in the knowledge base. It finds the fact 
<span class="verb">
<span class="cmtt-10"> child(anne,bridget) 
</span>
</span> and the variable 
<span class="verb">
<span class="cmtt-10"> _633 
</span>
</span> gets instantiated to 
<span class="verb">
<span class="cmtt-10"> bridget 
</span>
</span> . Now that the first subgoal is satisfied, Prolog moves to the second subgoal. It has to prove 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb134">
<a id="x22-33076r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  descend(bridget,donna) 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> This is the first recursive call of the predicate 
<span class="verb">
<span class="cmtt-10"> descend/2 
</span>
</span> . As before, Prolog starts with the first rule, but fails, because the goal 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb135">
<a id="x22-33078r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  child(bridget,donna) 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> cannot be proved. Backtracking, Prolog finds that there is a second possibility to be checked for 
<span class="verb">
<span class="cmtt-10"> descend(bridget,donna) 
</span>
</span> , namely the second rule, which again gives Prolog two new subgoals: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb136">
<a id="x22-33080r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  child(bridget,_1785), 
</span>
<br class="fancyvrb"/>
<a id="x22-33082r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  descend(_1785,donna). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> The first one can be unified with the fact 
<span class="verb">
<span class="cmtt-10"> child(bridget,caroline) 
</span>
</span> of the knowledge base, so that the variable 
<span class="verb">
<span class="cmtt-10"> _1785 
</span>
</span> is instantiated with 
<span class="verb">
<span class="cmtt-10"> caroline 
</span>
</span> . Next Prolog tries to prove 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb137">
<a id="x22-33084r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  descend(caroline,donna). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> This is the second recursive call of predicate 
<span class="verb">
<span class="cmtt-10"> descend/2 
</span>
</span> . As before, it tries the first rule first, obtaining the following new goal: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb138">
<a id="x22-33086r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  child(caroline,donna) 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> This time Prolog succeeds, since 
<span class="verb">
<span class="cmtt-10"> child(caroline,donna) 
</span>
</span> is a fact in the database. Prolog has found a proof for the goal 
<span class="verb">
<span class="cmtt-10"> descend(caroline,donna) 
</span>
</span> (the second recursive call). But this means that 
<span class="verb">
<span class="cmtt-10"> descend(bridget,donna) 
</span>
</span> (the first recursive call) is also true, which means that our original query 
<span class="verb">
<span class="cmtt-10"> descend(anne,donna) 
</span>
</span> is true as well. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Here is the search tree for the query 
<span class="verb">
<span class="cmtt-10"> descend(anne,donna) 
</span>
</span> . Make sure that you understand how it relates to the discussion in the text; that is, how Prolog traverses this search tree when trying to prove this query. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="center">
<!--l. 372-->
<p class="noindent">
</p>
<!--l. 373-->
<p class="noindent">
<img alt="*Pic not found*" src="html/chap3-pspic1.ps.png"/>
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> It should be obvious from this example that no matter how many generations of children we add, we will always be able to work out the descendant relation. That is, the recursive definition is both general and compact: it contains 
<span class="cmti-10"> all 
</span> the information in the non-recursive rules, and much more besides. The non-recursive rules only defined the descendant concept up to some fixed number of generations: we would need to write down infinitely many non-recursive rules if we wanted to capture this concept fully, and of course that’s impossible. But, in effect, that’s what the recursive rule does for us: it bundles up the information needed to cope with arbitrary numbers of generations into just three lines of code. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Recursive rules are really important. They enable to pack an enormous amount of information into a compact form and to define predicates in a natural way. Most of the work you will do as a Prolog programmer will involve writing recursive rules. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent">
</p>
</div>
<div class="nb-cell html" name="htm1">
<h4 class="likesubsectionHead">
<a id="x22-340003.1">
</a> Example 3: Successor 
</h4>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> In the previous chapter we remarked that building structure through unification is a key idea in Prolog programming. Now that we know about recursion, we can give more interesting illustrations of this. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Nowadays, when human beings write numerals, they usually use 
<span class="cmti-10"> decimal 
</span> notation (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, and so on) but as you probably know, there are many other notations. For example, because computer hardware is generally based on digital circuits, computers usually use 
<span class="cmti-10"> binary 
</span> notation to represent numerals (0, 1, 10, 11, 100, 101, 110, 111, 1000, and so on), for the 0 can be implemented as a switch being off, the 1 as a switch being on. Other cultures use different systems. For example, the ancient Babylonians used a base 60 system, while the ancient Romans used a rather ad-hoc system (I, II, III, IV, V, VI, VII, VIII, IX, X). This last example shows that notational issues can be important. If you don’t believe this, try figuring out a systematic way of doing long-division in Roman notation. As you’ll discover, it’s a frustrating task. Apparently the Romans had a group of professionals (analogs of modern accountants) who specialised in this. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Well, here’s yet another way of writing numerals, which is sometimes used in mathematical logic. It makes use of just four symbols: 0, 
<span class="cmti-10"> succ 
</span> , and the left and right parentheses. This style of numeral is defined by the following inductive definition: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<ol class="enumerate1">
<li class="enumerate" id="x22-34002x1"> 0 is a numeral. 
</li>
<li class="enumerate" id="x22-34004x2"> If 
<span class="cmti-10"> X 
</span> is a numeral, then so is 
<span class="cmti-10"> succ(X) 
</span> . 
</li>
</ol>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> As is probably clear, 
<span class="cmti-10"> succ 
</span> can be read as short for 
<span class="cmti-10"> successor 
</span> . That is, 
<span class="cmti-10"> succ(X) 
</span> represents the number obtained by adding one to the number represented by 
<span class="cmti-10"> X 
</span> . So this is a very simple notation: it simply says that 0 is a numeral, and that all other numerals are built by stacking 
<span class="cmti-10"> succ 
</span> symbols in front. (In fact, it’s used in mathematical logic because of this simplicity. Although it wouldn’t be pleasant to do household accounts in this notation, it is a very easy notation to prove things 
<span class="cmti-10"> about 
</span> .) 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Now, by this stage it should be clear that we can turn this definition into a Prolog program. The following knowledge base does this: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb139">
<a id="x22-34006r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  numeral(0). 
</span>
<br class="fancyvrb"/>
<a id="x22-34008r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x22-34010r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  numeral(succ(X)) 
</span>
<span class="cmtt-10">  :- 
</span>
<span class="cmtt-10">  numeral(X). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> So if we pose queries like 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb140">
<a id="x22-34012r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  numeral(succ(succ(succ(0)))). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> we get the answer yes. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> But we can do some more interesting things. Consider what happens when we pose the following query: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb141">
<a id="x22-34014r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  numeral(X). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> That is, we’re saying “Ok, show me some numerals”. Then we can have the following dialogue with Prolog: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb142">
<a id="x22-34016r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  0 
</span>
<span class="cmtt-10">  ; 
</span>
<br class="fancyvrb"/>
<a id="x22-34018r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x22-34020r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  succ(0) 
</span>
<span class="cmtt-10">  ; 
</span>
<br class="fancyvrb"/>
<a id="x22-34022r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x22-34024r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  succ(succ(0)) 
</span>
<span class="cmtt-10">  ; 
</span>
<br class="fancyvrb"/>
<a id="x22-34026r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x22-34028r7">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  succ(succ(succ(0))) 
</span>
<span class="cmtt-10">  ; 
</span>
<br class="fancyvrb"/>
<a id="x22-34030r8">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x22-34032r9">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  succ(succ(succ(succ(0)))) 
</span>
<span class="cmtt-10">  ; 
</span>
<br class="fancyvrb"/>
<a id="x22-34034r10">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x22-34036r11">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  succ(succ(succ(succ(succ(0))))) 
</span>
<span class="cmtt-10">  ; 
</span>
<br class="fancyvrb"/>
<a id="x22-34038r12">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x22-34040r13">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  succ(succ(succ(succ(succ(succ(0)))))) 
</span>
<span class="cmtt-10">  ; 
</span>
<br class="fancyvrb"/>
<a id="x22-34042r14">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x22-34044r15">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  succ(succ(succ(succ(succ(succ(succ(0))))))) 
</span>
<span class="cmtt-10">  ; 
</span>
<br class="fancyvrb"/>
<a id="x22-34046r16">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x22-34048r17">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  succ(succ(succ(succ(succ(succ(succ(succ(0)))))))) 
</span>
<br class="fancyvrb"/>
<a id="x22-34050r18">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Yes, Prolog is counting: but what’s really important is 
<span class="cmti-10"> how 
</span> it’s doing this. Quite simply, it’s backtracking through the recursive definition, and actually 
<span class="cmti-10"> building 
</span> numerals using unification. This is an instructive example, and it is important that you understand it. The best way to do so is to sit down and try it out, with 
<span class="verb">
<span class="cmtt-10"> trace 
</span>
</span> turned on. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Building and binding. Recursion, unification, and proof search. These are ideas that lie at the heart of Prolog programming. Whenever we have to generate or analyse recursively structured objects (such as these numerals) the interplay of these ideas makes Prolog a powerful tool. For example, in the next chapter we shall introduce lists, an extremely important recursive data structure, and we will see that Prolog is a natural list processing language. Many applications (computational linguistics is a prime example) make heavy use of recursively structured objects, such as trees and feature structures. So it’s not particularly surprising that Prolog has proved useful in such applications. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent">
</p>
</div>
<div class="nb-cell html" name="htm1">
<h4 class="likesubsectionHead">
<a id="x22-350003.1">
</a> Example 4: Addition 
</h4>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> As a final example, let’s see whether we can use the representation of numerals that we introduced in the previous section for doing simple arithmetic. Let’s try to define addition. That is, we want to define a predicate 
<span class="verb">
<span class="cmtt-10"> add/3 
</span>
</span> which when given two numerals as the first and second argument returns the result of adding them up as its third argument. For example: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb143">
<a id="x22-35002r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  add(succ(succ(0)),succ(succ(0)), 
</span>
<br class="fancyvrb"/>
<a id="x22-35004r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  succ(succ(succ(succ(0))))). 
</span>
<br class="fancyvrb"/>
<a id="x22-35006r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
<br class="fancyvrb"/>
<a id="x22-35008r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  add(succ(succ(0)),succ(0),Y). 
</span>
<br class="fancyvrb"/>
<a id="x22-35010r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Y 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  succ(succ(succ(0))) 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> There are two things which are important to notice: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<ol class="enumerate1">
<li class="enumerate" id="x22-35012x1"> Whenever the first argument is 
<span class="verb">
<span class="cmtt-10"> 0 
</span>
</span> , the third argument has to be the same as the second argument: 
<div class="fancyvrb" id="fancyvrb144">
<a id="x22-35014r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  add(0,succ(succ(0)),Y). 
</span>
<br class="fancyvrb"/>
<a id="x22-35016r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Y 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  succ(succ(0)) 
</span>
<br class="fancyvrb"/>
<a id="x22-35018r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  add(0,0,Y). 
</span>
<br class="fancyvrb"/>
<a id="x22-35020r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Y 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  0 
</span>
</div>
<!--l. 533-->
<p class="noindent"> This is the case that we want to use for the base clause. 
</p>
</li>
<li class="enumerate" id="x22-35022x2"> Assume that we want to add the two numerals 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> Y 
</span>
</span> (for example 
<span class="verb">
<span class="cmtt-10"> succ(succ(succ(0))) 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> succ(succ(0)) 
</span>
</span> ) and that 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> is not 
<span class="verb">
<span class="cmtt-10"> 0 
</span>
</span> . Now, if 
<span class="verb">
<span class="cmtt-10"> X1 
</span>
</span> is the numeral that has one 
<span class="verb">
<span class="cmtt-10"> succ 
</span>
</span> functor less than 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> (that is, 
<span class="verb">
<span class="cmtt-10"> succ(succ(0)) 
</span>
</span> in our example) and if we know the result – let’s call it 
<span class="verb">
<span class="cmtt-10"> Z 
</span>
</span> – of adding 
<span class="verb">
<span class="cmtt-10"> X1 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> Y 
</span>
</span> (namely 
<span class="verb">
<span class="cmtt-10"> succ(succ(succ(succ(0)))) 
</span>
</span> ), then it is very easy to compute the result of adding 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> Y 
</span>
</span> : we just have to add one 
<span class="verb">
<span class="cmtt-10"> succ 
</span>
</span> -functor to 
<span class="verb">
<span class="cmtt-10"> Z 
</span>
</span> . This is what we want to express with the recursive clause. 
</li>
</ol>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Here is the predicate definition that expresses exactly what we just said: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb145">
<a id="x22-35024r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  add(0,Y,Y). 
</span>
<br class="fancyvrb"/>
<a id="x22-35026r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  add(succ(X),Y,succ(Z)) 
</span>
<span class="cmtt-10">  :- 
</span>
<br class="fancyvrb"/>
<a id="x22-35028r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  add(X,Y,Z). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> So what happens, if we give Prolog this predicate definition and then ask: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb146">
<a id="x22-35030r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  add(succ(succ(succ(0))), 
</span>
<span class="cmtt-10">  succ(succ(0)), 
</span>
<span class="cmtt-10">  R). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Let’s go step by step through the way Prolog processes this query. The trace and search tree for the query are given below. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> The first argument is not 
<span class="verb">
<span class="cmtt-10"> 0 
</span>
</span> , which means that only the second clause for 
<span class="verb">
<span class="cmtt-10"> add/3 
</span>
</span> can be used. This leads to a recursive call of 
<span class="verb">
<span class="cmtt-10"> add/3 
</span>
</span> . The outermost 
<span class="verb">
<span class="cmtt-10"> succ 
</span>
</span> functor is stripped off the first argument of the original query, and the result becomes the first argument of the recursive query. The second argument is passed on unchanged to the recursive query, and the third argument of the recursive query is a variable, the internal variable 
<span class="verb">
<span class="cmtt-10"> _G648 
</span>
</span> in the trace given below. Note that 
<span class="verb">
<span class="cmtt-10"> _G648 
</span>
</span> is not instantiated yet. However it shares values with 
<span class="verb">
<span class="cmtt-10"> R 
</span>
</span> (the variable that we used as the third argument in the original query) because 
<span class="verb">
<span class="cmtt-10"> R 
</span>
</span> was instantiated to 
<span class="verb">
<span class="cmtt-10"> succ(_G648) 
</span>
</span> when the query was unified with the head of the second clause. But that means that 
<span class="verb">
<span class="cmtt-10"> R 
</span>
</span> is not a completely uninstantiated variable anymore. It is now a complex term, that has a (uninstantiated) variable as its argument. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> The next two steps are essentially the same. With every step the first argument becomes one layer of 
<span class="verb">
<span class="cmtt-10"> succ 
</span>
</span> smaller; both the trace and the search tree given below show this nicely. At the same time, a 
<span class="verb">
<span class="cmtt-10"> succ 
</span>
</span> functor is added to 
<span class="verb">
<span class="cmtt-10"> R 
</span>
</span> at every step, but always leaving the innermost variable uninstantiated. After the first recursive call 
<span class="verb">
<span class="cmtt-10"> R 
</span>
</span> is 
<span class="verb">
<span class="cmtt-10"> succ(_G648) 
</span>
</span> . After the second recursive call, 
<span class="verb">
<span class="cmtt-10"> _G648 
</span>
</span> is instantiated with 
<span class="verb">
<span class="cmtt-10"> succ(_G650) 
</span>
</span> , so that 
<span class="verb">
<span class="cmtt-10"> R 
</span>
</span> is 
<span class="verb">
<span class="cmtt-10"> succ(succ(_G650) 
</span>
</span> . After the third recursive call, 
<span class="verb">
<span class="cmtt-10"> _G650 
</span>
</span> is instantiated with 
<span class="verb">
<span class="cmtt-10"> succ(_G652) 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> R 
</span>
</span> therefore becomes 
<span class="verb">
<span class="cmtt-10"> succ(succ(succ(_G652))) 
</span>
</span> . The search tree shows this step by step instantiation. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> At this stage all 
<span class="verb">
<span class="cmtt-10"> succ 
</span>
</span> functors have been stripped off the first argument and we can apply the base clause. The third argument is equated with the second argument, so the ‘hole’ (the uninstantiated variable) in the complex term 
<span class="verb">
<span class="cmtt-10"> R 
</span>
</span> is finally filled, and we are through. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Here’s the complete trace of our query: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb147">
<a id="x22-35032r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Call: 
</span>
<span class="cmtt-10">  (6) 
</span>
<span class="cmtt-10">  add(succ(succ(succ(0))), 
</span>
<span class="cmtt-10">  succ(succ(0)), 
</span>
<span class="cmtt-10">  R) 
</span>
<br class="fancyvrb"/>
<a id="x22-35034r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x22-35036r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Call: 
</span>
<span class="cmtt-10">  (7) 
</span>
<span class="cmtt-10">  add(succ(succ(0)), 
</span>
<span class="cmtt-10">  succ(succ(0)), 
</span>
<span class="cmtt-10">  _G648) 
</span>
<br class="fancyvrb"/>
<a id="x22-35038r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x22-35040r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Call: 
</span>
<span class="cmtt-10">  (8) 
</span>
<span class="cmtt-10">  add(succ(0), 
</span>
<span class="cmtt-10">  succ(succ(0)), 
</span>
<span class="cmtt-10">  _G650) 
</span>
<br class="fancyvrb"/>
<a id="x22-35042r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x22-35044r7">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Call: 
</span>
<span class="cmtt-10">  (9) 
</span>
<span class="cmtt-10">  add(0, 
</span>
<span class="cmtt-10">  succ(succ(0)), 
</span>
<span class="cmtt-10">  _G652) 
</span>
<br class="fancyvrb"/>
<a id="x22-35046r8">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x22-35048r9">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Exit: 
</span>
<span class="cmtt-10">  (9) 
</span>
<span class="cmtt-10">  add(0, 
</span>
<span class="cmtt-10">  succ(succ(0)), 
</span>
<span class="cmtt-10">  succ(succ(0))) 
</span>
<br class="fancyvrb"/>
<a id="x22-35050r10">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x22-35052r11">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Exit: 
</span>
<span class="cmtt-10">  (8) 
</span>
<span class="cmtt-10">  add(succ(0), 
</span>
<span class="cmtt-10">  succ(succ(0)), 
</span>
<span class="cmtt-10">  succ(succ(succ(0)))) 
</span>
<br class="fancyvrb"/>
<a id="x22-35054r12">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x22-35056r13">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Exit: 
</span>
<span class="cmtt-10">  (7) 
</span>
<span class="cmtt-10">  add(succ(succ(0)), 
</span>
<span class="cmtt-10">  succ(succ(0)), 
</span>
<br class="fancyvrb"/>
<a id="x22-35058r14">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  succ(succ(succ(succ(0))))) 
</span>
<br class="fancyvrb"/>
<a id="x22-35060r15">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x22-35062r16">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Exit: 
</span>
<span class="cmtt-10">  (6) 
</span>
<span class="cmtt-10">  add(succ(succ(succ(0))), 
</span>
<span class="cmtt-10">  succ(succ(0)), 
</span>
<br class="fancyvrb"/>
<a id="x22-35064r17">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  succ(succ(succ(succ(succ(0)))))) 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> And here’s the search tree: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="center">
<!--l. 615-->
<p class="noindent">
</p>
<!--l. 616-->
<p class="noindent">
<img alt="*Pic not found*" src="html/chap3-pspic2.ps.png"/>
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse10"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse9"> front 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch3"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse11"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse9"> prev 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse9"> prev-tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=#taillpn-htmlse10"> tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch3"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<h3 class="sectionHead">
<span class="titlemark"> 3.2 
</span>
<a id="x23-360003.2">
</a> Rule Ordering, Goal Ordering, and Termination 
</h3>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Prolog was the first reasonably successful attempt to create a logic programming language. Underlying logic programming is a simple (and seductive) vision: the task of the programmer is simply to 
<span class="cmti-10"> describe 
</span> problems. The programmer should write down (in the language of logic) a declarative specification (that is: a knowledge base), which describes the situation of interest. The programmer shouldn’t have to tell the computer 
<span class="cmti-10"> what 
</span> to do. To get information, he or she simply asks the questions. It’s up to the logic programming system to figure out how to get the answer. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Well, that’s the idea, and it should be clear that Prolog has taken some important steps in this direction. But Prolog is 
<span class="cmti-10"> not 
</span> , repeat 
<span class="cmti-10"> not 
</span> , a full logic programming language. If you only think about the declarative meaning of a Prolog program, you are in for a very tough time. As we learned in the previous chapter, Prolog has a very specific way of working out the answers to queries: it searches the knowledge base from top to bottom, clauses from left to right, and uses backtracking to recover from bad choices. These procedural aspects have an important influence on what actually happens when you make a query. We have already seen a dramatic example of a mismatch between the procedural and declarative meaning of a knowledge base (remember the 
<span class="verb">
<span class="cmtt-10"> p:- 
</span>
<span class="cmtt-10">  p 
</span>
</span> program?), and as we shall now see, it is easy to define knowledge bases which (read logically) describe the same situations, but which behave very differently. Let’s consider the matter. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Recall our earlier descendant program (let’s call it 
<span class="verb">
<span class="cmtt-10"> descend1.pl 
</span>
</span> ): 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb148">
<a id="x23-36002r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  child(anne,bridget). 
</span>
<br class="fancyvrb"/>
<a id="x23-36004r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  child(bridget,caroline). 
</span>
<br class="fancyvrb"/>
<a id="x23-36006r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  child(caroline,donna). 
</span>
<br class="fancyvrb"/>
<a id="x23-36008r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  child(donna,emily). 
</span>
<br class="fancyvrb"/>
<a id="x23-36010r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x23-36012r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  descend(X,Y) 
</span>
<span class="cmtt-10">  :- 
</span>
<span class="cmtt-10">  child(X,Y). 
</span>
<br class="fancyvrb"/>
<a id="x23-36014r7">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x23-36016r8">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  descend(X,Y) 
</span>
<span class="cmtt-10">  :- 
</span>
<span class="cmtt-10">  child(X,Z), 
</span>
<br class="fancyvrb"/>
<a id="x23-36018r9">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  descend(Z,Y). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> We’ll make one change to it, and call the result 
<span class="verb">
<span class="cmtt-10"> descend2.pl 
</span>
</span> : 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb149">
<a id="x23-36020r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  child(anne,bridget). 
</span>
<br class="fancyvrb"/>
<a id="x23-36022r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  child(bridget,caroline). 
</span>
<br class="fancyvrb"/>
<a id="x23-36024r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  child(caroline,donna). 
</span>
<br class="fancyvrb"/>
<a id="x23-36026r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  child(donna,emily). 
</span>
<br class="fancyvrb"/>
<a id="x23-36028r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x23-36030r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  descend(X,Y) 
</span>
<span class="cmtt-10">  :- 
</span>
<span class="cmtt-10">  child(X,Z), 
</span>
<br class="fancyvrb"/>
<a id="x23-36032r7">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  descend(Z,Y). 
</span>
<br class="fancyvrb"/>
<a id="x23-36034r8">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x23-36036r9">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  descend(X,Y) 
</span>
<span class="cmtt-10">  :- 
</span>
<span class="cmtt-10">  child(X,Y). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> All we have done is change the rule order. So if we read the program as a purely logical definition, nothing has changed. But does the change give rise to procedural differences? Yes, but nothing significant. For example, if you work through the examples you will see that the first solution that 
<span class="verb">
<span class="cmtt-10"> descend1.pl 
</span>
</span> finds is 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb150">
<a id="x23-36038r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  anne 
</span>
<br class="fancyvrb"/>
<a id="x23-36040r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Y 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  bridget 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> whereas the first solution that 
<span class="verb">
<span class="cmtt-10"> descend2.pl 
</span>
</span> finds is 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb151">
<a id="x23-36042r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  anne 
</span>
<br class="fancyvrb"/>
<a id="x23-36044r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Y 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  emily 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> But (as you should check) both programs generate exactly the same answers, they merely find them in a different order. And this is a general point. Roughly speaking (we’ll add a caveat later on) changing the order of rules in a Prolog program does not change (up to the order in which solutions are found) the program’s behaviour. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> So let’s move on. We’ll make one small change to 
<span class="verb">
<span class="cmtt-10"> descend2.pl 
</span>
</span> , and call the result 
<span class="verb">
<span class="cmtt-10"> descend3.pl 
</span>
</span> : 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb152">
<a id="x23-36046r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  child(anne,bridget). 
</span>
<br class="fancyvrb"/>
<a id="x23-36048r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  child(bridget,caroline). 
</span>
<br class="fancyvrb"/>
<a id="x23-36050r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  child(caroline,donna). 
</span>
<br class="fancyvrb"/>
<a id="x23-36052r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  child(donna,emily). 
</span>
<br class="fancyvrb"/>
<a id="x23-36054r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x23-36056r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  descend(X,Y) 
</span>
<span class="cmtt-10">  :- 
</span>
<span class="cmtt-10">  descend(Z,Y), 
</span>
<br class="fancyvrb"/>
<a id="x23-36058r7">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  child(X,Z). 
</span>
<br class="fancyvrb"/>
<a id="x23-36060r8">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x23-36062r9">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  descend(X,Y) 
</span>
<span class="cmtt-10">  :- 
</span>
<span class="cmtt-10">  child(X,Y). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Note the difference. Here we’ve changed the goal order 
<span class="cmti-10"> within 
</span> a rule, not the rule order. Now, once again, if we read the program as a purely logical definition, nothing has changed; it means the same thing as the previous two versions. But this time the program’s behaviour has changed dramatically. For example, if you pose the query 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb153">
<a id="x23-36064r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  descend(anne,emily). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> you will get an error message (“out of local stack”, or something similar). Prolog is looping. Why? Well, in order to satisfy the query 
<span class="verb">
<span class="cmtt-10"> descend(anne,emily) 
</span>
</span> Prolog uses the first rule. This means that its next goal will be to satisfy the query 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb154">
<a id="x23-36066r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  descend(W1,emily) 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> for some new variable 
<span class="verb">
<span class="cmtt-10"> W1 
</span>
</span> . But to satisfy this new goal, Prolog again has to use the first rule, and this means that its next goal is going to be 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb155">
<a id="x23-36068r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  descend(W2,emily) 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> for some new variable 
<span class="verb">
<span class="cmtt-10"> W2 
</span>
</span> . And of course, this in turn means that its next goal is going to be 
<span class="verb">
<span class="cmtt-10"> descend(W3,emily) 
</span>
</span> and then 
<span class="verb">
<span class="cmtt-10"> descend(W4,emily) 
</span>
</span> , and so on. That is, the (at first glance innocuous) change in the goal order has resulted in procedural disaster. To use the standard terminology, we have here a classic example of a left recursive rule, that is, a rule where the leftmost item of the body is identical (modulo the choice of variables) with the rule’s head. As our example shows, such rules easily give rise to non-terminating computations. Goal order, and in particular left recursion, is the root of all evil when it comes to non-termination. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Still, as we said earlier, we need to make one small caveat about rule ordering. We said earlier that rule ordering only changes the order in which solutions are found. However this may not be true if we are working with non-terminating programs. To see this, consider the fourth (and last) variant of our descendant program, namely 
<span class="verb">
<span class="cmtt-10"> descend4.pl 
</span>
</span> : 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb156">
<a id="x23-36070r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  child(anne,bridget). 
</span>
<br class="fancyvrb"/>
<a id="x23-36072r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  child(bridget,caroline). 
</span>
<br class="fancyvrb"/>
<a id="x23-36074r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  child(caroline,donna). 
</span>
<br class="fancyvrb"/>
<a id="x23-36076r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  child(donna,emily). 
</span>
<br class="fancyvrb"/>
<a id="x23-36078r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x23-36080r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  descend(X,Y) 
</span>
<span class="cmtt-10">  :- 
</span>
<span class="cmtt-10">  child(X,Y). 
</span>
<br class="fancyvrb"/>
<a id="x23-36082r7">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x23-36084r8">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  descend(X,Y) 
</span>
<span class="cmtt-10">  :- 
</span>
<span class="cmtt-10">  descend(Z,Y), 
</span>
<br class="fancyvrb"/>
<a id="x23-36086r9">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  child(X,Z). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> This program is 
<span class="verb">
<span class="cmtt-10"> descend3.pl 
</span>
</span> with the rule ordering reversed. Now (once again) this program has the same declarative meaning as the other variants, but it is also procedurally different from its relatives. First, and most obviously, it is very different procedurally from both 
<span class="verb">
<span class="cmtt-10"> descend1.pl 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> descend2.pl 
</span>
</span> . In particular, because it contains a left recursive rule, this new program does not terminate on some input. For example (just like 
<span class="verb">
<span class="cmtt-10"> descend3.pl 
</span>
</span> ) this new program does not terminate when we pose the query 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb157">
<a id="x23-36088r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  descend(anne,emily). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> But 
<span class="verb">
<span class="cmtt-10"> descend4.pl 
</span>
</span> is not procedurally identical to 
<span class="verb">
<span class="cmtt-10"> descend3.pl 
</span>
</span> . The rule ordering reversal does make a difference. For example, 
<span class="verb">
<span class="cmtt-10"> descend3.pl 
</span>
</span> will not terminate if we pose the query 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb158">
<a id="x23-36090r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  descend(anne,bridget). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> However 
<span class="verb">
<span class="cmtt-10"> descend4.pl 
</span>
</span> will terminate in this case, for the rule reversal enables it to apply the non-recursive rule and halt. So when it comes to non-terminating programs, rule ordering changes can lead to some extra solutions being found. Nonetheless, goal ordering, not rule ordering, is what is truly procedurally significant. To ensure termination, we need to pay attention to the order of goals within the bodies of rules. Tinkering with rule orderings does not get to grips with the roots of termination problems — at best it can yield some extra solutions. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Summing up, our four variant descendant programs are Prolog knowledge bases which describe exactly the same situations, but behave differently. The difference in behaviour between 
<span class="verb">
<span class="cmtt-10"> descend1.pl 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> descend2.pl 
</span>
</span> (which differ only in the way rules are ordered) is relatively minor: they generate the same solutions, but in a different order. But 
<span class="verb">
<span class="cmtt-10"> descend3.pl 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> descend4.pl 
</span>
</span> are procedurally very different from their two cousins, and this is because they differ from them in the way their goals are ordered. In particular, both these variants contain left recursive rules, and in both cases this leads to non-terminating behaviour. The change in rule ordering between 
<span class="verb">
<span class="cmtt-10"> descend3.pl 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> descend4.pl 
</span>
</span> merely means that 
<span class="verb">
<span class="cmtt-10"> descend4.pl 
</span>
</span> will terminate in some cases where 
<span class="verb">
<span class="cmtt-10"> descend3.pl 
</span>
</span> will not. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> What are the ramifications of our discussion for the practicalities of producing working Prolog programs? It’s probably best to say the following. Often you can get the overall idea (the big picture) of how to write the program by thinking declaratively, that is, by thinking in terms of describing the problem accurately. This is an excellent way to approach problems, and certainly the one most in keeping with the spirit of logic programming. But once you’ve done that, you need to think about how Prolog will work with knowledge bases you have written. In particular, to ensure termination, you need to check that the goal orderings you have given are sensible. The basic rule of thumb is never to write as the leftmost goal of the body something that is identical (modulo variable names) with the goal given in the head. Rather, place such goals (which trigger recursive calls) as far as possible towards the right of the tail. That is, place them after the goals which test for the various (non-recursive) termination conditions. Doing this gives Prolog a sporting chance of fighting it’s way through your recursive definitions to find solutions. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse11"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse9"> prev 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse9"> prev-tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse10"> front 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch3"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse12"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse10"> prev 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse10"> prev-tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=#taillpn-htmlse11"> tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch3"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<h3 class="sectionHead">
<span class="titlemark"> 3.3 
</span>
<a id="x24-370003.3">
</a> <strong>Exercise</strong>s 
</h3>
</div>
<div class="nb-cell html" name="htm1">
<div class="newtheorem">
<!--l. 827-->
<p class="noindent">
<span class="head">
<span class="cmbx-10"> <strong>Exercise</strong>
</span>
<span class="cmbx-10">  3.1 
</span>
</span>
<a id="x24-370011">
</a>
<span class="cmti-10"> In the text, we discussed the predicate 
</span>
</p>
<div class="fancyvrb" id="fancyvrb159">
<a id="x24-37003r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  descend(X,Y) 
</span>
<span class="cmtt-10">  :- 
</span>
<span class="cmtt-10">  child(X,Y). 
</span>
<br class="fancyvrb"/>
<a id="x24-37005r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  descend(X,Y) 
</span>
<span class="cmtt-10">  :- 
</span>
<span class="cmtt-10">  child(X,Z), 
</span>
<br class="fancyvrb"/>
<a id="x24-37007r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  descend(Z,Y). 
</span>
</div>
<!--l. 833-->
<p class="noindent">
<span class="cmti-10"> Suppose we reformulated this predicate as follows: 
</span>
</p>
<div class="fancyvrb" id="fancyvrb160">
<a id="x24-37009r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  descend(X,Y) 
</span>
<span class="cmtt-10">  :- 
</span>
<span class="cmtt-10">  child(X,Y). 
</span>
<br class="fancyvrb"/>
<a id="x24-37011r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  descend(X,Y) 
</span>
<span class="cmtt-10">  :- 
</span>
<span class="cmtt-10">  descend(X,Z), 
</span>
<br class="fancyvrb"/>
<a id="x24-37013r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  descend(Z,Y). 
</span>
</div>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Would this be problematic? 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="newtheorem">
<!--l. 843-->
<p class="noindent">
<span class="head">
<span class="cmbx-10"> <strong>Exercise</strong>
</span>
<span class="cmbx-10">  3.2 
</span>
</span>
<a id="x24-370142">
</a>
<span class="cmti-10"> Do you know these wooden Russian dolls (Matryoshka dolls) 
</span>
<span class="cmti-10"> where the smaller ones are contained in bigger ones? Here is a schematic picture: 
</span>
</p>
<!--l. 847-->
<p class="indent">
<img alt="*Pic not found*" src="html/dolls.eps.png"/>
</p>
<!--l. 849-->
<p class="indent">
<span class="cmti-10"> First, write a knowledge base using the predicate 
</span>
<span class="verb">
<span class="cmtt-10"> directlyIn/2 
</span>
</span>
<span class="cmti-10"> which 
</span>
<span class="cmti-10"> encodes which doll is directly contained in which other doll. Then, define a 
</span>
<span class="cmti-10"> recursive predicate 
</span>
<span class="verb">
<span class="cmtt-10"> in/2 
</span>
</span>
<span class="cmti-10"> , that tells us which doll is (directly or indirectly) 
</span>
<span class="cmti-10"> contained in which other dolls. For example, the query 
</span>
<span class="verb">
<span class="cmtt-10"> in(katarina,natasha) 
</span>
</span>
<span class="cmti-10"> should evaluate to true, while 
</span>
<span class="verb">
<span class="cmtt-10"> in(olga, 
</span>
<span class="cmtt-10">  katarina) 
</span>
</span>
<span class="cmti-10"> should fail. 
</span>
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="newtheorem">
<!--l. 858-->
<p class="noindent">
<span class="head">
<span class="cmbx-10"> <strong>Exercise</strong>
</span>
<span class="cmbx-10">  3.3 
</span>
</span>
<a id="x24-370153">
</a>
<span class="cmti-10"> We have the following knowledge base: 
</span>
</p>
<div class="fancyvrb" id="fancyvrb161">
<a id="x24-37017r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  directTrain(saarbruecken,dudweiler). 
</span>
<br class="fancyvrb"/>
<a id="x24-37019r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  directTrain(forbach,saarbruecken). 
</span>
<br class="fancyvrb"/>
<a id="x24-37021r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  directTrain(freyming,forbach). 
</span>
<br class="fancyvrb"/>
<a id="x24-37023r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  directTrain(stAvold,freyming). 
</span>
<br class="fancyvrb"/>
<a id="x24-37025r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  directTrain(fahlquemont,stAvold). 
</span>
<br class="fancyvrb"/>
<a id="x24-37027r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  directTrain(metz,fahlquemont). 
</span>
<br class="fancyvrb"/>
<a id="x24-37029r7">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  directTrain(nancy,metz). 
</span>
</div>
<!--l. 869-->
<p class="indent">
<span class="cmti-10"> That is, this knowledge base holds facts about towns it is possible to travel between 
</span>
<span class="cmti-10"> by taking a 
</span> direct 
<span class="cmti-10"> train. But of course, we can travel further by chaining together 
</span>
<span class="cmti-10"> direct train journeys. Write a recursive predicate 
</span>
<span class="verb">
<span class="cmtt-10"> travelFromTo/2 
</span>
</span>
<span class="cmti-10"> that tells us 
</span>
<span class="cmti-10"> when we can travel by train between two towns. For example, when given the 
</span>
<span class="cmti-10"> query 
</span>
</p>
<div class="fancyvrb" id="fancyvrb162">
<a id="x24-37031r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  travelFromTo(nancy,saarbruecken). 
</span>
</div>
<!--l. 877-->
<p class="noindent">
<span class="cmti-10"> it should reply yes. 
</span>
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="newtheorem">
<!--l. 881-->
<p class="noindent">
<span class="head">
<span class="cmbx-10"> <strong>Exercise</strong>
</span>
<span class="cmbx-10">  3.4 
</span>
</span>
<a id="x24-370324">
</a>
<span class="cmti-10"> Define a predicate 
</span>
<span class="verb">
<span class="cmtt-10"> greater_than/2 
</span>
</span>
<span class="cmti-10"> that takes two numerals in the 
</span>
<span class="cmti-10"> notation that we introduced in the text (that is, 0, succ(0), succ(succ(0)), and so on) 
</span>
<span class="cmti-10"> as arguments and decides whether the first one is greater than the second one. For 
</span>
<span class="cmti-10"> example: 
</span>
</p>
<div class="fancyvrb" id="fancyvrb163">
<a id="x24-37034r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  greater_than(succ(succ(succ(0))),succ(0)). 
</span>
<br class="fancyvrb"/>
<a id="x24-37036r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
<br class="fancyvrb"/>
<a id="x24-37038r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  greater_than(succ(succ(0)),succ(succ(succ(0)))). 
</span>
<br class="fancyvrb"/>
<a id="x24-37040r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  no 
</span>
</div>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="newtheorem">
<!--l. 892-->
<p class="noindent">
<span class="head">
<span class="cmbx-10"> <strong>Exercise</strong>
</span>
<span class="cmbx-10">  3.5 
</span>
</span>
<a id="x24-370415">
</a>
<span class="cmti-10"> Binary trees are trees where all internal nodes have exactly 
</span>
<span class="cmti-10"> two children. The smallest binary trees consist of only one leaf node. We 
</span>
<span class="cmti-10"> will represent leaf nodes as 
</span>
<span class="verb">
<span class="cmtt-10"> leaf(Label) 
</span>
</span>
<span class="cmti-10"> . For instance, 
</span>
<span class="verb">
<span class="cmtt-10"> leaf(3) 
</span>
</span>
<span class="cmti-10"> and 
</span>
<span class="verb">
<span class="cmtt-10"> leaf(7) 
</span>
</span>
<span class="cmti-10"> are leaf nodes, and therefore small binary trees. Given two binary trees 
</span>
<span class="verb">
<span class="cmtt-10"> B1 
</span>
</span>
<span class="cmti-10"> and 
</span>
<span class="verb">
<span class="cmtt-10"> B2 
</span>
</span>
<span class="cmti-10"> we can combine them into one binary tree using the functor 
</span>
<span class="verb">
<span class="cmtt-10"> tree/2 
</span>
</span>
<span class="cmti-10"> as follows: 
</span>
<span class="verb">
<span class="cmtt-10"> tree(B1,B2) 
</span>
</span>
<span class="cmti-10"> . So, from the leaves 
</span>
<span class="verb">
<span class="cmtt-10"> leaf(1) 
</span>
</span>
<span class="cmti-10"> and 
</span>
<span class="verb">
<span class="cmtt-10"> leaf(2) 
</span>
</span>
<span class="cmti-10"> we can build the binary tree 
</span>
<span class="verb">
<span class="cmtt-10"> tree(leaf(1),leaf(2)) 
</span>
</span>
<span class="cmti-10"> . And from the binary 
</span>
<span class="cmti-10"> trees 
</span>
<span class="verb">
<span class="cmtt-10"> tree(leaf(1),leaf(2)) 
</span>
</span>
<span class="cmti-10"> and 
</span>
<span class="verb">
<span class="cmtt-10"> leaf(4) 
</span>
</span>
<span class="cmti-10"> we can build the binary tree 
</span>
<span class="verb">
<span class="cmtt-10"> tree(tree(leaf(1), 
</span>
<span class="cmtt-10">  leaf(2)),leaf(4)) 
</span>
</span>
<span class="cmti-10"> . 
</span>
</p>
<!--l. 905-->
<p class="indent">
<span class="cmti-10"> Now, define a predicate 
</span>
<span class="verb">
<span class="cmtt-10"> swap/2 
</span>
</span>
<span class="cmti-10"> , which produces the mirror image of the binary 
</span>
<span class="cmti-10"> tree that is its first argument. For example: 
</span>
</p>
<div class="fancyvrb" id="fancyvrb164">
<a id="x24-37043r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  swap(tree(tree(leaf(1), 
</span>
<span class="cmtt-10">  leaf(2)), 
</span>
<span class="cmtt-10">  leaf(4)),T). 
</span>
<br class="fancyvrb"/>
<a id="x24-37045r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  T 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  tree(leaf(4), 
</span>
<span class="cmtt-10">  tree(leaf(2), 
</span>
<span class="cmtt-10">  leaf(1))). 
</span>
<br class="fancyvrb"/>
<a id="x24-37047r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
</div>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse12"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse10"> prev 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse10"> prev-tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse11"> front 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch3"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse11"> prev 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse11"> prev-tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=#taillpn-htmlse12"> tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch3"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<h3 class="sectionHead">
<span class="titlemark"> 3.4 
</span>
<a id="x25-380003.4">
</a> Practical Session 
</h3>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> By now, you should feel more at home with writing and running basic Prolog programs. In this practical session we first suggest two series of keyboard exercises which will help you get familiar with recursive definitions in Prolog, and then give you some programming problems to solve. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> First the keyboard exercises. As recursive programming is so fundamental to Prolog, it is important that you have a firm grasp of what it involves. In particular, it is important that you understand the process of variable instantiation when recursive definitions are used, and that you understand why the order of goals in rules can make the difference between termination and non-termination. So: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<ol class="enumerate1">
<li class="enumerate" id="x25-38002x1"> Load 
<span class="verb">
<span class="cmtt-10"> descend1.pl 
</span>
</span> , turn on 
<span class="verb">
<span class="cmtt-10"> trace 
</span>
</span> , and pose the query 
<span class="verb">
<span class="cmtt-10"> descend(anne,emily) 
</span>
</span> . Count how many steps it takes Prolog to work out the answer (that is, how many times do you have to hit the return key). Now turn 
<span class="verb">
<span class="cmtt-10"> trace 
</span>
</span> off and pose the query 
<span class="verb">
<span class="cmtt-10"> descend(X,Y) 
</span>
</span> . How many answers are there? 
</li>
<li class="enumerate" id="x25-38004x2"> Load 
<span class="verb">
<span class="cmtt-10"> descend2.pl 
</span>
</span> . This is the variant of 
<span class="verb">
<span class="cmtt-10"> descend1.pl 
</span>
</span> with the rule order reversed. Repeat the traces you have carried out for 
<span class="verb">
<span class="cmtt-10"> descend1.pl 
</span>
</span> , and compare the results. 
</li>
<li class="enumerate" id="x25-38006x3"> Load 
<span class="verb">
<span class="cmtt-10"> descend3.pl 
</span>
</span> . This is the variant of 
<span class="verb">
<span class="cmtt-10"> descend2.pl 
</span>
</span> in which the goal order within the recursive rule is switched, resulting in a left recursive rule. Because of this, even for such simple queries as 
<span class="verb">
<span class="cmtt-10"> descend(anne,bridget) 
</span>
</span> , Prolog will not terminate. Step through an example, using 
<span class="verb">
<span class="cmtt-10"> trace 
</span>
</span> , to confirm this. 
</li>
<li class="enumerate" id="x25-38008x4"> Load 
<span class="verb">
<span class="cmtt-10"> descend4.pl 
</span>
</span> . This is the variant of 
<span class="verb">
<span class="cmtt-10"> descend3.pl 
</span>
</span> obtained by switching the rule order. So 
<span class="verb">
<span class="cmtt-10"> descend4.pl 
</span>
</span> also contains a left recursive rule, and does not terminate on all input. But it does terminate on some input where 
<span class="verb">
<span class="cmtt-10"> descend3.pl 
</span>
</span> does not. Which extra solutions does it find? 
</li>
</ol>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> As we said in the text, goal ordering, not rule ordering is what is truly procedurally significant. But with non-terminating programs, rule ordering changes can have unexpected effects. Recall the successor program discussed in the text (let’s call it 
<span class="verb">
<span class="cmtt-10"> numeral1.pl 
</span>
</span> ): 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb165">
<a id="x25-38010r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  numeral(0). 
</span>
<br class="fancyvrb"/>
<a id="x25-38012r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  numeral(succ(X)) 
</span>
<span class="cmtt-10">  :- 
</span>
<span class="cmtt-10">  numeral(X). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Let’s swap the order of the two clauses, and call the result 
<span class="verb">
<span class="cmtt-10"> numeral2.pl 
</span>
</span> : 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb166">
<a id="x25-38014r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  numeral(succ(X)) 
</span>
<span class="cmtt-10">  :- 
</span>
<span class="cmtt-10">  numeral(X). 
</span>
<br class="fancyvrb"/>
<a id="x25-38016r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  numeral(0). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Clearly the declarative, or logical, content of this program is exactly the same as the earlier version. But what are the procedural differences, if any? 
</p>
</div>
<div class="nb-cell html" name="htm1">
<ol class="enumerate1">
<li class="enumerate" id="x25-38018x1"> Create a file containing 
<span class="verb">
<span class="cmtt-10"> numeral2.pl 
</span>
</span> , load it, and investigate what happens if we pose queries about 
<span class="cmti-10"> specific 
</span> numerals. For example, suppose we ask: 
<div class="fancyvrb" id="fancyvrb167">
<a id="x25-38020r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  numeral(succ(succ(succ(0)))). 
</span>
</div>
<!--l. 988-->
<p class="noindent"> Do 
<span class="verb">
<span class="cmtt-10"> numeral1.pl 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> numeral2.pl 
</span>
</span> behave in the same way on such input? 
</p>
</li>
<li class="enumerate" id="x25-38022x2"> Second, look at what happens if we try to 
<span class="cmti-10"> generate 
</span> numerals, that is, suppose we pose the query 
<div class="fancyvrb" id="fancyvrb168">
<a id="x25-38024r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  numeral(X). 
</span>
</div>
<!--l. 997-->
<p class="noindent"> Do the programs display identical behaviour? 
</p>
</li>
</ol>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Here are some programs for you to try your hand at. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<ol class="enumerate1">
<li class="enumerate" id="x25-38026x1"> Imagine that the following knowledge base describes a maze. The facts determine which points are connected, that is, from which points you can get to which other points in one step. Furthermore, imagine that all paths are one-way streets, so that you can only walk them in one direction. So, you can get from point 1 to point 2, but not the other way round. 
<div class="fancyvrb" id="fancyvrb169">
<a id="x25-38028r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  connected(1,2). 
</span>
<br class="fancyvrb"/>
<a id="x25-38030r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  connected(3,4). 
</span>
<br class="fancyvrb"/>
<a id="x25-38032r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  connected(5,6). 
</span>
<br class="fancyvrb"/>
<a id="x25-38034r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  connected(7,8). 
</span>
<br class="fancyvrb"/>
<a id="x25-38036r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  connected(9,10). 
</span>
<br class="fancyvrb"/>
<a id="x25-38038r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  connected(12,13). 
</span>
<br class="fancyvrb"/>
<a id="x25-38040r7">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  connected(13,14). 
</span>
<br class="fancyvrb"/>
<a id="x25-38042r8">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  connected(15,16). 
</span>
<br class="fancyvrb"/>
<a id="x25-38044r9">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  connected(17,18). 
</span>
<br class="fancyvrb"/>
<a id="x25-38046r10">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  connected(19,20). 
</span>
<br class="fancyvrb"/>
<a id="x25-38048r11">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  connected(4,1). 
</span>
<br class="fancyvrb"/>
<a id="x25-38050r12">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  connected(6,3). 
</span>
<br class="fancyvrb"/>
<a id="x25-38052r13">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  connected(4,7). 
</span>
<br class="fancyvrb"/>
<a id="x25-38054r14">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  connected(6,11). 
</span>
<br class="fancyvrb"/>
<a id="x25-38056r15">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  connected(14,9). 
</span>
<br class="fancyvrb"/>
<a id="x25-38058r16">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  connected(11,15). 
</span>
<br class="fancyvrb"/>
<a id="x25-38060r17">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  connected(16,12). 
</span>
<br class="fancyvrb"/>
<a id="x25-38062r18">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  connected(14,17). 
</span>
<br class="fancyvrb"/>
<a id="x25-38064r19">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  connected(16,19). 
</span>
</div>
<!--l. 1030-->
<p class="noindent"> Write a predicate 
<span class="verb">
<span class="cmtt-10"> path/2 
</span>
</span> that tells you from which points in the maze you can get to which other points when chaining together connections given in the above knowledge base. Can you get from point 5 to point 10? Which other point can you get to when starting at point 1? And which points can be reached from point 13? 
</p>
</li>
<li class="enumerate" id="x25-38066x2"> We are given the following knowledge base of travel information: 
<div class="fancyvrb" id="fancyvrb170">
<a id="x25-38068r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  byCar(auckland,hamilton). 
</span>
<br class="fancyvrb"/>
<a id="x25-38070r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  byCar(hamilton,raglan). 
</span>
<br class="fancyvrb"/>
<a id="x25-38072r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  byCar(valmont,saarbruecken). 
</span>
<br class="fancyvrb"/>
<a id="x25-38074r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  byCar(valmont,metz). 
</span>
<br class="fancyvrb"/>
<a id="x25-38076r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x25-38078r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  byTrain(metz,frankfurt). 
</span>
<br class="fancyvrb"/>
<a id="x25-38080r7">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  byTrain(saarbruecken,frankfurt). 
</span>
<br class="fancyvrb"/>
<a id="x25-38082r8">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  byTrain(metz,paris). 
</span>
<br class="fancyvrb"/>
<a id="x25-38084r9">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  byTrain(saarbruecken,paris). 
</span>
<br class="fancyvrb"/>
<a id="x25-38086r10">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x25-38088r11">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  byPlane(frankfurt,bangkok). 
</span>
<br class="fancyvrb"/>
<a id="x25-38090r12">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  byPlane(frankfurt,singapore). 
</span>
<br class="fancyvrb"/>
<a id="x25-38092r13">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  byPlane(paris,losAngeles). 
</span>
<br class="fancyvrb"/>
<a id="x25-38094r14">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  byPlane(bangkok,auckland). 
</span>
<br class="fancyvrb"/>
<a id="x25-38096r15">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  byPlane(singapore,auckland). 
</span>
<br class="fancyvrb"/>
<a id="x25-38098r16">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  byPlane(losAngeles,auckland). 
</span>
</div>
<!--l. 1055-->
<p class="noindent"> Write a predicate 
<span class="verb">
<span class="cmtt-10"> travel/2 
</span>
</span> which determines whether it is possible to travel from one place to another by chaining together car, train, and plane journeys. For example, your program should answer yes to the query 
<span class="verb">
<span class="cmtt-10"> travel(valmont,raglan) 
</span>
</span> . 
</p>
</li>
<li class="enumerate" id="x25-38100x3"> So, by using 
<span class="verb">
<span class="cmtt-10"> travel/2 
</span>
</span> to query the above database, you can find out that it is possible to go from Valmont to Raglan. If you are planning such a voyage, that’s already something useful to know, but you would probably prefer to have the precise route from Valmont to Raglan. Write a predicate 
<span class="verb">
<span class="cmtt-10"> travel/3 
</span>
</span> which tells you which route to take when travelling from one place to another. For example, the program should respond 
<div class="fancyvrb" id="fancyvrb171">
<a id="x25-38102r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  go(valmont,metz, 
</span>
<br class="fancyvrb"/>
<a id="x25-38104r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  go(metz,paris, 
</span>
<br class="fancyvrb"/>
<a id="x25-38106r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  go(paris,losAngeles))) 
</span>
</div>
<!--l. 1072-->
<p class="noindent"> to the query 
<span class="verb">
<span class="cmtt-10"> travel(valmont,losAngeles,X) 
</span>
</span> . 
</p>
</li>
<li class="enumerate" id="x25-38108x4"> Extend the predicate 
<span class="verb">
<span class="cmtt-10"> travel/3 
</span>
</span> so that it not only tells you the route to take to get from one place to another, but also 
<span class="cmti-10"> how 
</span> you have to travel. That is, the new program should let us know, for each stage of the voyage, whether we need to travel by car, train, or plane. 
</li>
</ol>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse11"> prev 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse11"> prev-tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse12"> front 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch3"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse14"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=#taillpn-htmlse13"> tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch4"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<h3 class="sectionHead">
<span class="titlemark"> 4.1 
</span>
<a id="x27-400004.1">
</a> Lists 
</h3>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> As its name suggests, a list is just a plain old list of items. Slightly more precisely, it is a finite sequence of elements. Here are some examples of lists in Prolog: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb172">
<a id="x27-40002r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  [mia, 
</span>
<span class="cmtt-10">  vincent, 
</span>
<span class="cmtt-10">  jules, 
</span>
<span class="cmtt-10">  yolanda] 
</span>
<br class="fancyvrb"/>
<a id="x27-40004r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x27-40006r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  [mia, 
</span>
<span class="cmtt-10">  robber(honey_bunny), 
</span>
<span class="cmtt-10">  X, 
</span>
<span class="cmtt-10">  2, 
</span>
<span class="cmtt-10">  mia] 
</span>
<br class="fancyvrb"/>
<a id="x27-40008r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x27-40010r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  [] 
</span>
<br class="fancyvrb"/>
<a id="x27-40012r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x27-40014r7">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  [mia, 
</span>
<span class="cmtt-10">  [vincent, 
</span>
<span class="cmtt-10">  jules], 
</span>
<span class="cmtt-10">  [butch, 
</span>
<span class="cmtt-10">  girlfriend(butch)]] 
</span>
<br class="fancyvrb"/>
<a id="x27-40016r8">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x27-40018r9">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  [[], 
</span>
<span class="cmtt-10">  dead(z), 
</span>
<span class="cmtt-10">  [2, 
</span>
<span class="cmtt-10">  [b, 
</span>
<span class="cmtt-10">  c]], 
</span>
<span class="cmtt-10">  [], 
</span>
<span class="cmtt-10">  Z, 
</span>
<span class="cmtt-10">  [2, 
</span>
<span class="cmtt-10">  [b, 
</span>
<span class="cmtt-10">  c]]] 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> We can learn some important things from these examples. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<ol class="enumerate1">
<li class="enumerate" id="x27-40020x1"> We can specify lists in Prolog by enclosing the elements of the list in square brackets (that is, the symbols 
<span class="verb">
<span class="cmtt-10"> [ 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> ] 
</span>
</span> ). The elements are separated by commas. For example, the first list shown above, 
<span class="verb">
<span class="cmtt-10"> [mia, 
</span>
<span class="cmtt-10">  vincent, 
</span>
<span class="cmtt-10">  jules, 
</span>
<span class="cmtt-10">  yolanda] 
</span>
</span> , is a list with four elements, namely 
<span class="verb">
<span class="cmtt-10"> mia 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> vincent 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> jules 
</span>
</span> , and 
<span class="verb">
<span class="cmtt-10"> yolanda 
</span>
</span> . The length of a list is the number of elements it has, so our first example is a list of length four. 
</li>
<li class="enumerate" id="x27-40022x2"> From 
<span class="verb">
<span class="cmtt-10"> [mia,robber(honey_bunny),X,2,mia] 
</span>
</span> , our second example, we learn that all sorts of Prolog objects can be elements of a list. The first element of this list is 
<span class="verb">
<span class="cmtt-10"> mia 
</span>
</span> , an atom; the second element is 
<span class="verb">
<span class="cmtt-10"> robber(honey_bunny) 
</span>
</span> , a complex term; the third element is 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> , a variable; the fourth element is 
<span class="verb">
<span class="cmtt-10"> 2 
</span>
</span> , a number. Moreover, we also learn that the same item may occur more than once in the same list: for example, the fifth element of this list is 
<span class="verb">
<span class="cmtt-10"> mia 
</span>
</span> , which is same as the first element. 
</li>
<li class="enumerate" id="x27-40024x3"> The third example shows that there is a special list, the empty list. The empty list (as its name suggests) is the list that contains no elements. What is the length of the empty list? Zero, of course (for the length of a list is the number of members it contains, and the empty list contains nothing). 
</li>
<li class="enumerate" id="x27-40026x4"> The fourth example teaches us something extremely important: lists can contain other lists as elements. For example, the second element of 
<div class="fancyvrb" id="fancyvrb173">
<a id="x27-40028r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  [mia, 
</span>
<span class="cmtt-10">  [vincent, 
</span>
<span class="cmtt-10">  jules], 
</span>
<span class="cmtt-10">  [butch,girlfriend(butch)] 
</span>
</div>
<!--l. 75-->
<p class="noindent"> is 
<span class="verb">
<span class="cmtt-10"> [vincent,jules] 
</span>
</span> . The third is 
<span class="verb">
<span class="cmtt-10"> [butch,girlfriend(butch)] 
</span>
</span> . 
</p>
<!--l. 79-->
<p class="noindent"> What is the length of the fourth list? The answer is: three. If you thought it was five (or indeed, anything else) you’re not thinking about lists in the right way. The elements of the list are the things between the outermost square brackets separated by commas. So this list contains 
<span class="cmti-10"> three 
</span> elements: the first element is 
<span class="verb">
<span class="cmtt-10"> mia 
</span>
</span> , the second element is 
<span class="verb">
<span class="cmtt-10"> [vincent, 
</span>
<span class="cmtt-10">  jules] 
</span>
</span> , and the third element is 
<span class="verb">
<span class="cmtt-10"> [butch, 
</span>
<span class="cmtt-10">  girlfriend(butch)] 
</span>
</span> . 
</p>
</li>
<li class="enumerate" id="x27-40030x5"> The last example mixes all these ideas together. We have here a list which contains the empty list (in fact, it contains it twice), the complex term 
<span class="verb">
<span class="cmtt-10"> dead(z) 
</span>
</span> , two copies of the list 
<span class="verb">
<span class="cmtt-10"> [2, 
</span>
<span class="cmtt-10">  [b, 
</span>
<span class="cmtt-10">  c]] 
</span>
</span> , and the variable 
<span class="verb">
<span class="cmtt-10"> Z 
</span>
</span> . Note that the third (and the last) elements are lists which themselves contain lists (namely 
<span class="verb">
<span class="cmtt-10"> [b, 
</span>
<span class="cmtt-10">  c] 
</span>
</span> ). 
</li>
</ol>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Now for an important point. Any non-empty list can be thought of as consisting of two parts: the head and the tail. The head is simply the first item in the list; the tail is everything else. To put it more precisely, the tail is the list that remains when we take the first element away; that is, 
<span class="cmti-10"> the tail of a list is always a list 
</span> . For example, the head of 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb174">
<a id="x27-40032r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  [mia, 
</span>
<span class="cmtt-10">  vincent, 
</span>
<span class="cmtt-10">  jules, 
</span>
<span class="cmtt-10">  yolanda] 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> is 
<span class="verb">
<span class="cmtt-10"> mia 
</span>
</span> and the tail is 
<span class="verb">
<span class="cmtt-10">  [vincent, 
</span>
<span class="cmtt-10">  jules, 
</span>
<span class="cmtt-10">  yolanda] 
</span>
</span> . Similarly, the head of 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb175">
<a id="x27-40034r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  [[], 
</span>
<span class="cmtt-10">  dead(z), 
</span>
<span class="cmtt-10">  [2, 
</span>
<span class="cmtt-10">  [b, 
</span>
<span class="cmtt-10">  c]], 
</span>
<span class="cmtt-10">  [], 
</span>
<span class="cmtt-10">  Z, 
</span>
<span class="cmtt-10">  [2, 
</span>
<span class="cmtt-10">  [b, 
</span>
<span class="cmtt-10">  c]]] 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> is 
<span class="verb">
<span class="cmtt-10"> [] 
</span>
</span> , and the tail is 
<span class="verb">
<span class="cmtt-10"> [dead(z), 
</span>
<span class="cmtt-10">  [2,[b,c]],[],Z,[2,[b, 
</span>
<span class="cmtt-10">  c]]] 
</span>
</span> . And what are the head and the tail of the list 
<span class="verb">
<span class="cmtt-10"> [dead(z)] 
</span>
</span> ? Well, the head is the first element of the list, which is 
<span class="verb">
<span class="cmtt-10"> dead(z) 
</span>
</span> , and the tail is the list that remains if we take the head away, which, in this case, is the empty list 
<span class="verb">
<span class="cmtt-10"> [] 
</span>
</span> . 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> What about the empty list? It has neither a head nor a tail. That is, the empty list has no internal structure; for Prolog, 
<span class="verb">
<span class="cmtt-10"> [] 
</span>
</span> is a special, particularly simple, list. As we shall learn when we start writing recursive list processing programs, this fact plays an important role in Prolog programming. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Prolog has a special built-in operator 
<span class="verb">
<span class="cmtt-10"> | 
</span>
</span> which can be used to decompose a list into its head and tail. It is important to get to know how to use 
<span class="verb">
<span class="cmtt-10"> | 
</span>
</span> , for it is a key tool for writing Prolog list manipulation programs. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> The most obvious use of 
<span class="verb">
<span class="cmtt-10"> | 
</span>
</span> is to extract information from lists. We do this by using 
<span class="verb">
<span class="cmtt-10"> | 
</span>
</span> together with unification. For example, to get hold of the head and tail of 
<span class="verb">
<span class="cmtt-10"> [mia,vincent, 
</span>
</span>
<span class="verb">
<span class="cmtt-10"> jules,yolanda] 
</span>
</span> we can pose the following query: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb176">
<a id="x27-40036r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  [Head|Tail] 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [mia, 
</span>
<span class="cmtt-10">  vincent, 
</span>
<span class="cmtt-10">  jules, 
</span>
<span class="cmtt-10">  yolanda]. 
</span>
<br class="fancyvrb"/>
<a id="x27-40038r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x27-40040r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Head 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  mia 
</span>
<br class="fancyvrb"/>
<a id="x27-40042r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Tail 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [vincent,jules,yolanda] 
</span>
<br class="fancyvrb"/>
<a id="x27-40044r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> That is, the head of the list has become bound to 
<span class="verb">
<span class="cmtt-10"> Head 
</span>
</span> and the tail of the list has become bound to 
<span class="verb">
<span class="cmtt-10"> Tail 
</span>
</span> . Note that there is nothing special about 
<span class="verb">
<span class="cmtt-10"> Head 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> Tail 
</span>
</span> , they are simply variables. We could just as well have posed the query: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb177">
<a id="x27-40046r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  [X|Y] 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [mia, 
</span>
<span class="cmtt-10">  vincent, 
</span>
<span class="cmtt-10">  jules, 
</span>
<span class="cmtt-10">  yolanda]. 
</span>
<br class="fancyvrb"/>
<a id="x27-40048r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x27-40050r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  mia 
</span>
<br class="fancyvrb"/>
<a id="x27-40052r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Y 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [vincent,jules,yolanda] 
</span>
<br class="fancyvrb"/>
<a id="x27-40054r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> As we mentioned above, only non-empty lists have heads and tails. If we try to use 
<span class="verb">
<span class="cmtt-10"> | 
</span>
</span> to pull 
<span class="verb">
<span class="cmtt-10"> [] 
</span>
</span> apart, Prolog will fail: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb178">
<a id="x27-40056r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  [X|Y] 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  []. 
</span>
<br class="fancyvrb"/>
<a id="x27-40058r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x27-40060r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  no 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> That is, Prolog treats 
<span class="verb">
<span class="cmtt-10"> [] 
</span>
</span> as a special list. This observation is extremely important. We’ll see why later. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Let’s look at some other examples. We can extract the head and tail of the following list just as we saw above: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb179">
<a id="x27-40062r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  [X|Y] 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [[], 
</span>
<span class="cmtt-10">  dead(z), 
</span>
<span class="cmtt-10">  [2, 
</span>
<span class="cmtt-10">  [b, 
</span>
<span class="cmtt-10">  c]], 
</span>
<span class="cmtt-10">  [], 
</span>
<span class="cmtt-10">  Z]. 
</span>
<br class="fancyvrb"/>
<a id="x27-40064r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x27-40066r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [] 
</span>
<br class="fancyvrb"/>
<a id="x27-40068r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Y 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [dead(z),[2,[b,c]],[],_7800] 
</span>
<br class="fancyvrb"/>
<a id="x27-40070r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Z 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  _7800 
</span>
<br class="fancyvrb"/>
<a id="x27-40072r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> That is: the head of the list is bound to 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> , the tail is bound to 
<span class="verb">
<span class="cmtt-10"> Y 
</span>
</span> . (We also learn that Prolog has bound 
<span class="verb">
<span class="cmtt-10"> Z 
</span>
</span> to the internal variable 
<span class="verb">
<span class="cmtt-10"> _7800 
</span>
</span> .) 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> But we can do a lot more with 
<span class="verb">
<span class="cmtt-10"> | 
</span>
</span> ; it really is a flexible tool. For example, suppose we wanted to know what the first 
<span class="cmti-10"> two 
</span> elements of the list were, and also the remainder of the list after the second element. Then we’d pose the following query: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb180">
<a id="x27-40074r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  [X,Y 
</span>
<span class="cmtt-10">  | 
</span>
<span class="cmtt-10">  W] 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [[], 
</span>
<span class="cmtt-10">  dead(z), 
</span>
<span class="cmtt-10">  [2, 
</span>
<span class="cmtt-10">  [b, 
</span>
<span class="cmtt-10">  c]], 
</span>
<span class="cmtt-10">  [], 
</span>
<span class="cmtt-10">  Z]. 
</span>
<br class="fancyvrb"/>
<a id="x27-40076r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x27-40078r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [] 
</span>
<br class="fancyvrb"/>
<a id="x27-40080r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Y 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  dead(z) 
</span>
<br class="fancyvrb"/>
<a id="x27-40082r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  W 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [[2,[b,c]],[],_8327] 
</span>
<br class="fancyvrb"/>
<a id="x27-40084r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Z 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  _8327 
</span>
<br class="fancyvrb"/>
<a id="x27-40086r7">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> That is, the head of the list is bound to 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> , the second element is bound to 
<span class="verb">
<span class="cmtt-10"> Y 
</span>
</span> , and the remainder of the list after the second element is bound to 
<span class="verb">
<span class="cmtt-10"> W 
</span>
</span> (that is, 
<span class="verb">
<span class="cmtt-10"> W 
</span>
</span> is the list that remains when we take away the first two elements). So 
<span class="verb">
<span class="cmtt-10"> | 
</span>
</span> can not only be used to split a list into its head and its tail, we can also use it to split a list at any point. To the left of 
<span class="verb">
<span class="cmtt-10"> | 
</span>
</span> we simply indicate how many elements we want to take away from the front of the list, and then to right of the 
<span class="verb">
<span class="cmtt-10"> | 
</span>
</span> we will get what remains. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> This is a good time to introduce the anonymous variable. Suppose we were interested in getting hold of the second and fourth elements of the list: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb181">
<a id="x27-40088r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  [[], 
</span>
<span class="cmtt-10">  dead(z), 
</span>
<span class="cmtt-10">  [2, 
</span>
<span class="cmtt-10">  [b, 
</span>
<span class="cmtt-10">  c]], 
</span>
<span class="cmtt-10">  [], 
</span>
<span class="cmtt-10">  Z]. 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Now, we could find out like this: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb182">
<a id="x27-40090r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  [X1,X2,X3,X4 
</span>
<span class="cmtt-10">  | 
</span>
<span class="cmtt-10">  Tail] 
</span>
<span class="cmtt-10">  = 
</span>
<br class="fancyvrb"/>
<a id="x27-40092r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  [[], 
</span>
<span class="cmtt-10">  dead(z), 
</span>
<span class="cmtt-10">  [2, 
</span>
<span class="cmtt-10">  [b, 
</span>
<span class="cmtt-10">  c]], 
</span>
<span class="cmtt-10">  [], 
</span>
<span class="cmtt-10">  Z]. 
</span>
<br class="fancyvrb"/>
<a id="x27-40094r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x27-40096r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X1 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [] 
</span>
<br class="fancyvrb"/>
<a id="x27-40098r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X2 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  dead(z) 
</span>
<br class="fancyvrb"/>
<a id="x27-40100r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X3 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [2,[b,c]] 
</span>
<br class="fancyvrb"/>
<a id="x27-40102r7">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X4 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [] 
</span>
<br class="fancyvrb"/>
<a id="x27-40104r8">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Tail 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [_8910] 
</span>
<br class="fancyvrb"/>
<a id="x27-40106r9">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Z 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  _8910 
</span>
<br class="fancyvrb"/>
<a id="x27-40108r10">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Ok, we have got the information we wanted: the values we are interested in are bound to the variables 
<span class="verb">
<span class="cmtt-10"> X2 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> X4 
</span>
</span> . But we’ve got a lot of other information too (namely the values bound to 
<span class="verb">
<span class="cmtt-10"> X1 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> X3 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> Tail 
</span>
</span> ). And perhaps we’re not interested in all this other stuff. If so, it’s a bit silly having to explicitly introduce variables 
<span class="verb">
<span class="cmtt-10"> X1 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> X3 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> Tail 
</span>
</span> to deal with it. And in fact, there is a simpler way to obtain 
<span class="cmti-10"> only 
</span> the information we want: we can pose the following query instead: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb183">
<a id="x27-40110r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  [_,X,_,Y|_] 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [[], 
</span>
<span class="cmtt-10">  dead(z), 
</span>
<span class="cmtt-10">  [2, 
</span>
<span class="cmtt-10">  [b, 
</span>
<span class="cmtt-10">  c]], 
</span>
<span class="cmtt-10">  [], 
</span>
<span class="cmtt-10">  Z]. 
</span>
<br class="fancyvrb"/>
<a id="x27-40112r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x27-40114r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  dead(z) 
</span>
<br class="fancyvrb"/>
<a id="x27-40116r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Y 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [] 
</span>
<br class="fancyvrb"/>
<a id="x27-40118r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Z 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  _9593 
</span>
<br class="fancyvrb"/>
<a id="x27-40120r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> The 
<span class="verb">
<span class="cmtt-10"> _ 
</span>
</span> symbol (that is, underscore) is the anonymous variable. We use it when we need to use a variable, but we’re not interested in what Prolog instantiates the variable to. As you can see in the above example, Prolog didn’t bother telling us what 
<span class="verb">
<span class="cmtt-10"> _ 
</span>
</span> was bound to. Moreover, note that each occurrence of 
<span class="verb">
<span class="cmtt-10"> _ 
</span>
</span> is 
<span class="cmti-10"> independent 
</span> : each is bound to something different. This couldn’t happen with an ordinary variable of course, but then the anonymous variable isn’t meant to be ordinary. It’s simply a way of telling Prolog to bind something to a given position, completely independently of any other bindings. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Let’s look at one last example. The third element of our working example is a list (namely 
<span class="verb">
<span class="cmtt-10"> [2, 
</span>
<span class="cmtt-10">  [b, 
</span>
<span class="cmtt-10">  c]] 
</span>
</span> ). Suppose we wanted to extract the tail of this internal list, and that we are not interested in any other information. How could we do this? As follows: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb184">
<a id="x27-40122r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  [_,_,[_|X]|_] 
</span>
<span class="cmtt-10">  = 
</span>
<br class="fancyvrb"/>
<a id="x27-40124r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  [[], 
</span>
<span class="cmtt-10">  dead(z), 
</span>
<span class="cmtt-10">  [2, 
</span>
<span class="cmtt-10">  [b, 
</span>
<span class="cmtt-10">  c]], 
</span>
<span class="cmtt-10">  [], 
</span>
<span class="cmtt-10">  Z, 
</span>
<span class="cmtt-10">  [2, 
</span>
<span class="cmtt-10">  [b, 
</span>
<span class="cmtt-10">  c]]]. 
</span>
<br class="fancyvrb"/>
<a id="x27-40126r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x27-40128r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [[b,c]] 
</span>
<br class="fancyvrb"/>
<a id="x27-40130r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Z 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  _10087 
</span>
<br class="fancyvrb"/>
<a id="x27-40132r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse14"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse13"> front 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch4"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse15"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse13"> prev 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse13"> prev-tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=#taillpn-htmlse14"> tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch4"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<h3 class="sectionHead">
<span class="titlemark"> 4.2 
</span>
<a id="x28-410004.2">
</a> Member 
</h3>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> It’s time to look at our first example of a recursive Prolog program for manipulating lists. One of the most basic things we would like to know is whether something is an element of a list or not. So let’s write a program that, when given as inputs an arbitrary object 
<span class="cmti-10"> X 
</span> and a list 
<span class="cmti-10"> L 
</span> , tells us whether or not 
<span class="cmti-10"> X 
</span> belongs to 
<span class="cmti-10"> L 
</span> . The program that does this is usually called member 
<a id="dx28-41001">
</a> , and it is the simplest example of a Prolog program that exploits the recursive structure of lists. Here it is: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb185">
<a id="x28-41003r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  member(X,[X|T]). 
</span>
<br class="fancyvrb"/>
<a id="x28-41005r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  member(X,[H|T]) 
</span>
<span class="cmtt-10">  :- 
</span>
<span class="cmtt-10">  member(X,T). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> That’s all there is to it: one fact (namely 
<span class="verb">
<span class="cmtt-10"> member(X,[X|T]) 
</span>
</span> ) and one rule (namely 
<span class="verb">
<span class="cmtt-10"> member(X,[H|T]) 
</span>
<span class="cmtt-10">  :- 
</span>
<span class="cmtt-10">  member(X,T) 
</span>
</span> ). But note that the rule is recursive (after all, the functor 
<span class="verb">
<span class="cmtt-10"> member 
</span>
</span> occurs in both the rule’s head and body) and it is this that explains why such a short program is all that is required. Let’s take a closer look. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> We’ll start by reading the program declaratively. And read this way, it is obviously sensible. The first clause (the fact) simply says: an object 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> is a member of a list if it is the head of that list. Note that we used the built-in 
<span class="verb">
<span class="cmtt-10"> | 
</span>
</span> operator to state this (simple but important) principle about lists. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> What about the second clause, the recursive rule? This says: an object 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> is member of a list if it is a member of the tail of the list. Again, note that we used the 
<span class="verb">
<span class="cmtt-10"> | 
</span>
</span> operator to state this principle. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Now, clearly this definition makes good declarative sense. But does this program actually 
<span class="cmti-10"> do 
</span> what it is supposed to do? That is, will it really tell us whether an object 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> belongs to a list 
<span class="verb">
<span class="cmtt-10"> L 
</span>
</span> ? And if so, how exactly does it do this? To answer such questions, we need to think about its procedural meaning. Let’s work our way through a few examples. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Suppose we posed the following query: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb186">
<a id="x28-41007r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  member(yolanda,[yolanda,trudy,vincent,jules]). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Prolog will immediately answer yes. Why? Because it can unify 
<span class="verb">
<span class="cmtt-10"> yolanda 
</span>
</span> with both occurrences of 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> in the first clause (the fact) in the definition of 
<span class="verb">
<span class="cmtt-10"> member/2 
</span>
</span> , so it succeeds immediately. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Next consider the following query: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb187">
<a id="x28-41009r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  member(vincent,[yolanda,trudy,vincent,jules]). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Now the first rule won’t help ( 
<span class="verb">
<span class="cmtt-10"> vincent 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> yolanda 
</span>
</span> are distinct atoms) so Prolog goes to the second clause, the recursive rule. This gives Prolog a new goal: it now has to see if 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb188">
<a id="x28-41011r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  member(vincent,[trudy,vincent,jules]). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Once again the first clause won’t help, so Prolog goes (again) to the recursive rule. This gives it a new goal, namely 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb189">
<a id="x28-41013r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  member(vincent,[vincent,jules]). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> This time, the first clause does help, and the query succeeds. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> So far so good, but we need to ask an important question. What happens when we pose a query that 
<span class="cmti-10"> fails 
</span> ? For example, what happens if we pose the query 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb190">
<a id="x28-41015r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  member(zed,[yolanda,trudy,vincent,jules]). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Now, this should obviously fail (after all, 
<span class="verb">
<span class="cmtt-10"> zed 
</span>
</span> is not on the list). So how does Prolog handle this? In particular, how can we be sure that Prolog really will 
<span class="cmti-10"> stop 
</span> , and say 
<span class="cmti-10"> no 
</span> , instead going into an endless recursive loop? 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Let’s think this through systematically. Once again, the first clause cannot help, so Prolog uses the recursive rule, which gives it a new goal 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb191">
<a id="x28-41017r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  member(zed,[trudy,vincent,jules]). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Again, the first clause doesn’t help, so Prolog reuses the recursive rule and tries to show that 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb192">
<a id="x28-41019r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  member(zed,[vincent,jules]). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Similarly, the first rule doesn’t help, so Prolog reuses the second rule yet again and tries the goal 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb193">
<a id="x28-41021r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  member(zed,[jules]). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Again the first clause doesn’t help, so Prolog uses the second rule, which gives it the goal 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb194">
<a id="x28-41023r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  member(zed,[]) 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> And 
<span class="cmti-10"> this 
</span> is where things get interesting. Obviously the first clause can’t help here. But note: 
<span class="cmti-10"> the recursive rule can’t do anything more either 
</span> . Why not? Simple: the recursive rule relies on splitting the list into a head and a tail, but as we have already seen, the empty list 
<span class="cmti-10"> can’t 
</span> be split up in this way. So the recursive rule cannot be applied either, and Prolog stops searching for more solutions and announces no. That is, it tells us that 
<span class="verb">
<span class="cmtt-10"> zed 
</span>
</span> does not belong to the list, which is just what it ought to do. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> We could summarise the 
<span class="verb">
<span class="cmtt-10"> member/2 
</span>
</span> predicate as follows. It is a recursive predicate, which systematically searches down the length of the list for the required item. It does this by stepwise breaking down the list into smaller lists, and looking at the first item of each smaller list. This mechanism that drives this search is recursion, and the reason that this recursion is safe (that is, the reason it does not go on forever) is that at the end of the line Prolog has to ask a question about the empty list. The empty list 
<span class="cmti-10"> cannot 
</span> be broken down into smaller parts, and this allows a way out of the recursion. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Well, we’ve now seen why 
<span class="verb">
<span class="cmtt-10"> member/2 
</span>
</span> works, but in fact it’s far more useful than the previous example might suggest. Up till now we’ve only been using it to answer yes/no questions. But we can also pose questions containing variables. For example, we can have the following dialog with Prolog: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb195">
<a id="x28-41025r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  member(X,[yolanda,trudy,vincent,jules]). 
</span>
<br class="fancyvrb"/>
<a id="x28-41027r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x28-41029r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  yolanda 
</span>
<span class="cmtt-10">  ; 
</span>
<br class="fancyvrb"/>
<a id="x28-41031r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x28-41033r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  trudy 
</span>
<span class="cmtt-10">  ; 
</span>
<br class="fancyvrb"/>
<a id="x28-41035r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x28-41037r7">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  vincent 
</span>
<span class="cmtt-10">  ; 
</span>
<br class="fancyvrb"/>
<a id="x28-41039r8">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x28-41041r9">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  jules 
</span>
<span class="cmtt-10">  ; 
</span>
<br class="fancyvrb"/>
<a id="x28-41043r10">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x28-41045r11">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  no 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> That is, Prolog has told us what every member of a list is. This is an extremely common use of 
<span class="verb">
<span class="cmtt-10"> member/2 
</span>
</span> . In effect, by using the variable we are saying to Prolog: “Quick! Give me some element of the list!”. In many applications we need to be able to extract members of a list, and this is the way it is typically done. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> One final remark. The way we defined 
<span class="verb">
<span class="cmtt-10"> member/2 
</span>
</span> above is certainly correct, but in one respect it is a little messy. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Think about it. The first clause is there to deal with the head of the list. But although the tail is irrelevant to the first clause, we named the tail using the variable 
<span class="verb">
<span class="cmtt-10"> T 
</span>
</span> . Similarly, the recursive rule is there to deal with the tail of the list. But although the head is irrelevant here, we named it using the variable 
<span class="verb">
<span class="cmtt-10"> H 
</span>
</span> . These unnecessary variable names are distracting: it’s better to write predicates in a way that focuses attention on what is really important in each clause, and the anonymous variable gives us a nice way of doing this. That is, we can rewrite 
<span class="verb">
<span class="cmtt-10"> member/2 
</span>
</span> as follows: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb196">
<a id="x28-41047r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  member(X,[X|_]). 
</span>
<br class="fancyvrb"/>
<a id="x28-41049r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  member(X,[_|T]) 
</span>
<span class="cmtt-10">  :- 
</span>
<span class="cmtt-10">  member(X,T). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> This version is exactly the same, both declaratively and procedurally. But it’s just that little bit clearer: when you read it, you are forced to concentrate on what is essential. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse15"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse13"> prev 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse13"> prev-tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse14"> front 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch4"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse16"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse14"> prev 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse14"> prev-tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=#taillpn-htmlse15"> tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch4"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<h3 class="sectionHead">
<span class="titlemark"> 4.3 
</span>
<a id="x29-420004.3">
</a> Recursing down Lists 
</h3>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> The 
<span class="verb">
<span class="cmtt-10"> member/2 
</span>
</span> predicate works by recursively working its way down a list, doing something to the head, and then recursively doing the same thing to the tail. Recursing down a list (or indeed, several lists) in this way is extremely common in Prolog; so common, in fact, that it is important that you really master the technique. So let’s look at another example. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> When working with lists, we often want to compare one list with another, or to copy bits of one list into another, or to translate the contents of one list into another, or something similar. Here’s an example. Let’s suppose we need a predicate 
<span class="verb">
<span class="cmtt-10"> a2b/2 
</span>
</span> that takes two lists as arguments, and succeeds if the first argument is a list of 
<span class="verb">
<span class="cmtt-10"> a 
</span>
</span> s, and the second argument is a list of 
<span class="verb">
<span class="cmtt-10"> b 
</span>
</span> s of exactly the same length. For example, if we pose the following query 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb197">
<a id="x29-42002r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  a2b([a,a,a,a],[b,b,b,b]). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> we want Prolog to say yes. On the other hand, if we pose the query 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb198">
<a id="x29-42004r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  a2b([a,a,a,a],[b,b,b]). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> or the query 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb199">
<a id="x29-42006r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  a2b([a,c,a,a],[b,b,5,4]). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> we want Prolog to say no. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> When faced with such tasks, often the best way to set about solving them is to start by thinking about the simplest possible case. Now, when working with lists, thinking about the simplest case often means thinking about the empty list, and it certainly means this here. After all: what is the shortest possible list of 
<span class="verb">
<span class="cmtt-10"> a 
</span>
</span> s? It’s the empty list. Why? Because it contains no 
<span class="verb">
<span class="cmtt-10"> a 
</span>
</span> s at all. And what is the shortest possible list of 
<span class="verb">
<span class="cmtt-10"> b 
</span>
</span> s? Again, the empty list: no 
<span class="verb">
<span class="cmtt-10"> b 
</span>
</span> s whatsoever in that. So the most basic information our definition needs to contain is 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb200">
<a id="x29-42008r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  a2b([],[]). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> This records the obvious fact that the empty list contains exactly as many 
<span class="verb">
<span class="cmtt-10"> a 
</span>
</span> s as 
<span class="verb">
<span class="cmtt-10"> b 
</span>
</span> s. But although obvious, this fact turns out to play an important role in our program, as we shall see. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> So far so good: but how do we proceed? Here’s the idea: for longer lists, 
<span class="cmti-10"> think 
</span>
<span class="cmti-10"> recursively 
</span> . So: when should 
<span class="verb">
<span class="cmtt-10"> a2b/2 
</span>
</span> decide that two non-empty lists are a list of 
<span class="verb">
<span class="cmtt-10"> a 
</span>
</span> s and a list of 
<span class="verb">
<span class="cmtt-10"> b 
</span>
</span> s of exactly the same length? Simple: when the head of the first list is an 
<span class="verb">
<span class="cmtt-10"> a 
</span>
</span> , and the head of the second list is a 
<span class="verb">
<span class="cmtt-10"> b 
</span>
</span> , and 
<span class="verb">
<span class="cmtt-10"> a2b/2 
</span>
</span> decides that the two tails are lists of 
<span class="verb">
<span class="cmtt-10"> a 
</span>
</span> s and 
<span class="verb">
<span class="cmtt-10"> b 
</span>
</span> s of exactly the same length! This immediately gives us the following rule: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb201">
<a id="x29-42010r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  a2b([a|Ta],[b|Tb]) 
</span>
<span class="cmtt-10">  :- 
</span>
<span class="cmtt-10">  a2b(Ta,Tb). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> This says: the 
<span class="verb">
<span class="cmtt-10"> a2b/2 
</span>
</span> predicate should succeed if its first argument is a list with head 
<span class="verb">
<span class="cmtt-10"> a 
</span>
</span> , its second argument is a list with head 
<span class="verb">
<span class="cmtt-10"> b 
</span>
</span> , and 
<span class="verb">
<span class="cmtt-10"> a2b/2 
</span>
</span> succeeds on the two tails. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Now, this definition make good sense declaratively. It is a simple and natural recursive predicate, the base clause dealing with the empty list, the recursive clause dealing with non-empty lists. But how does it work in practice? That is, what is its procedural meaning? For example, if we pose the query 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb202">
<a id="x29-42012r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  a2b([a,a,a],[b,b,b]). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Prolog will say yes, which is what we want — but 
<span class="cmti-10"> why 
</span> exactly does this happen? 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Let’s work the example through. In this query, neither list is empty, so the fact does not help. Thus Prolog goes on to try the recursive rule. Now, the query does match the rule (after all, the head of the first list is 
<span class="verb">
<span class="cmtt-10"> a 
</span>
</span> and the head of the second is 
<span class="verb">
<span class="cmtt-10"> b 
</span>
</span> ) so Prolog now has a new goal, namely 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb203">
<a id="x29-42014r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  a2b([a,a],[b,b]). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Once again, the fact does not help with this, but the recursive rule can be used again, leading to the following goal: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb204">
<a id="x29-42016r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  a2b([a],[b]). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Yet again the fact does not help, but the recursive rule does, so we get the following goal: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb205">
<a id="x29-42018r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  a2b([],[]). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> At last we can use the fact: this tells us that, yes, we really do have two lists here that contain exactly the same number of 
<span class="verb">
<span class="cmtt-10"> a 
</span>
</span> s and 
<span class="verb">
<span class="cmtt-10"> b 
</span>
</span> s (namely, none at all). And because this goal succeeds, this means that the goal 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb206">
<a id="x29-42020r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  a2b([a],[b]). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> succeeds too. This in turn means that the goal 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb207">
<a id="x29-42022r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  a2b([a,a],[b,b]). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> succeeds, and thus that the original goal 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb208">
<a id="x29-42024r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  a2b([a,a,a],[b,b,b]). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> is satisfied. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> We could summarise this process as follows. Prolog started with two lists. It peeled the head off each of them, and checked that they were an 
<span class="verb">
<span class="cmtt-10"> a 
</span>
</span> and a 
<span class="verb">
<span class="cmtt-10"> b 
</span>
</span> , respectively, as required. It then recursively analysed the tails of both lists. That is, it worked its way down both tails simultaneously, checking that at each stage the tails were headed by an 
<span class="verb">
<span class="cmtt-10"> a 
</span>
</span> and a 
<span class="verb">
<span class="cmtt-10"> b 
</span>
</span> . Why did the process stop? Because at each recursive step we had to work with shorter lists (namely the tails of the lists examined at the previous step) and eventually we ended up with empty lists. At this point, our rather trivial looking fact was able to play a vital role: it said yes. This halted the recursion, and ensured that the original query succeeded. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> It’s is also important to think about what happens with queries that 
<span class="cmti-10"> fail 
</span> . For example, if we pose the query 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb209">
<a id="x29-42026r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  a2b([a,a,a,a],[b,b,b]). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Prolog will correctly say no. Why? because after carrying out the peel-off-the-head-and-recursively-examine-the-tail process three times, it will be left with the query 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb210">
<a id="x29-42028r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  a2b([a],[]). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> But this goal cannot be satisfied. And if we pose the query 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb211">
<a id="x29-42030r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  a2b([a,c,a,a],[b,b,5,4]). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> after carrying out the peel-off-the-head-and-recursively-examine-the-tail process once, Prolog will have the goal 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb212">
<a id="x29-42032r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  a2b([c,a,a],[b,5,4]). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> and again, this cannot be satisfied. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Well, that’s how 
<span class="verb">
<span class="cmtt-10"> a2b/2 
</span>
</span> works in simple cases, but we haven’t exhausted its possibilities yet. As always with Prolog, it’s a good idea to investigate what happens when variables as used as input. And with 
<span class="verb">
<span class="cmtt-10"> a2b/2 
</span>
</span> something interesting happens: it acts as a translator, translating lists of 
<span class="verb">
<span class="cmtt-10"> a 
</span>
</span> s to lists of 
<span class="verb">
<span class="cmtt-10"> b 
</span>
</span> s, and vice versa. For example the query 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb213">
<a id="x29-42034r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  a2b([a,a,a,a],X). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> yields the response 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb214">
<a id="x29-42036r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [b,b,b,b]. 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> That is, the list of 
<span class="verb">
<span class="cmtt-10"> a 
</span>
</span> s has been translated to a list of 
<span class="verb">
<span class="cmtt-10"> b 
</span>
</span> s. Similarly, by using a variable in the first argument position, we can use it to translate lists of 
<span class="verb">
<span class="cmtt-10"> b 
</span>
</span> s to lists of 
<span class="verb">
<span class="cmtt-10"> a 
</span>
</span> s: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb215">
<a id="x29-42038r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  a2b(X,[b,b,b,b]). 
</span>
<br class="fancyvrb"/>
<a id="x29-42040r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x29-42042r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [a,a,a,a] 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> And of course, we can use variables in both argument positions: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb216">
<a id="x29-42044r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  a2b(X,Y). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Can you work out what happens in this case? 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> To sum up: 
<span class="verb">
<span class="cmtt-10"> a2b/2 
</span>
</span> is an extremely simple example of a program that works by recursing its way down a pair of lists. But don’t be fooled by its simplicity: the kind of programming it illustrates is fundamental to Prolog. Both its declarative form (a base clause dealing with the empty list, a recursive clause dealing with non-empty lists) and the procedural idea it trades on (do something to the heads, and then recursively do the same thing to the tails) come up again and again in Prolog programming. In fact, in the course of your Prolog career, you’ll find that you’ll write what is essentially the 
<span class="verb">
<span class="cmtt-10"> a2b/2 
</span>
</span> predicate, or a more complex variant of it, many times over in many different guises. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse16"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse14"> prev 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse14"> prev-tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse15"> front 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch4"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse17"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse15"> prev 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse15"> prev-tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=#taillpn-htmlse16"> tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch4"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<h3 class="sectionHead">
<span class="titlemark"> 4.4 
</span>
<a id="x30-430004.4">
</a> <strong>Exercise</strong>s 
</h3>
</div>
<div class="nb-cell html" name="htm1">
<div class="newtheorem">
<!--l. 653-->
<p class="noindent">
<span class="head">
<span class="cmbx-10"> <strong>Exercise</strong>
</span>
<span class="cmbx-10">  4.1 
</span>
</span>
<a id="x30-430011">
</a>
<span class="cmti-10"> How does Prolog respond to the following queries? 
</span>
</p>
<ol class="enumerate1">
<li class="enumerate" id="x30-43003x1">
<span class="verb">
<span class="cmtt-10"> [a,b,c,d] 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [a,[b,c,d]]. 
</span>
</span>
</li>
<li class="enumerate" id="x30-43005x2">
<span class="verb">
<span class="cmtt-10"> [a,b,c,d] 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [a|[b,c,d]]. 
</span>
</span>
</li>
<li class="enumerate" id="x30-43007x3">
<span class="verb">
<span class="cmtt-10"> [a,b,c,d] 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [a,b,[c,d]]. 
</span>
</span>
</li>
<li class="enumerate" id="x30-43009x4">
<span class="verb">
<span class="cmtt-10"> [a,b,c,d] 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [a,b|[c,d]]. 
</span>
</span>
</li>
<li class="enumerate" id="x30-43011x5">
<span class="verb">
<span class="cmtt-10"> [a,b,c,d] 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [a,b,c,[d]]. 
</span>
</span>
</li>
<li class="enumerate" id="x30-43013x6">
<span class="verb">
<span class="cmtt-10"> [a,b,c,d] 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [a,b,c|[d]]. 
</span>
</span>
</li>
<li class="enumerate" id="x30-43015x7">
<span class="verb">
<span class="cmtt-10"> [a,b,c,d] 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [a,b,c,d,[]]. 
</span>
</span>
</li>
<li class="enumerate" id="x30-43017x8">
<span class="verb">
<span class="cmtt-10"> [a,b,c,d] 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [a,b,c,d|[]]. 
</span>
</span>
</li>
<li class="enumerate" id="x30-43019x9">
<span class="verb">
<span class="cmtt-10"> [] 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  _. 
</span>
</span>
</li>
<li class="enumerate" id="x30-43021x10">
<span class="verb">
<span class="cmtt-10"> [] 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [_]. 
</span>
</span>
</li>
<li class="enumerate" id="x30-43023x11">
<span class="verb">
<span class="cmtt-10"> [] 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [_|[]]. 
</span>
</span>
</li>
</ol>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="newtheorem">
<!--l. 668-->
<p class="noindent">
<span class="head">
<span class="cmbx-10"> <strong>Exercise</strong>
</span>
<span class="cmbx-10">  4.2 
</span>
</span>
<a id="x30-430242">
</a>
<span class="cmti-10"> Which of the following are syntactically correct lists? If the 
</span>
<span class="cmti-10"> representation is correct, how many elements does the list have? 
</span>
</p>
<!--l. 670-->
<p class="indent">
</p>
<ol class="enumerate1">
<li class="enumerate" id="x30-43026x1">
<span class="verb">
<span class="cmtt-10"> [1|[2,3,4]] 
</span>
</span>
</li>
<li class="enumerate" id="x30-43028x2">
<span class="verb">
<span class="cmtt-10"> [1,2,3|[]] 
</span>
</span>
</li>
<li class="enumerate" id="x30-43030x3">
<span class="verb">
<span class="cmtt-10"> [1|2,3,4] 
</span>
</span>
</li>
<li class="enumerate" id="x30-43032x4">
<span class="verb">
<span class="cmtt-10"> [1|[2|[3|[4]]]] 
</span>
</span>
</li>
<li class="enumerate" id="x30-43034x5">
<span class="verb">
<span class="cmtt-10"> [1,2,3,4|[]] 
</span>
</span>
</li>
<li class="enumerate" id="x30-43036x6">
<span class="verb">
<span class="cmtt-10"> [[]|[]] 
</span>
</span>
</li>
<li class="enumerate" id="x30-43038x7">
<span class="verb">
<span class="cmtt-10"> [[1,2]|4] 
</span>
</span>
</li>
<li class="enumerate" id="x30-43040x8">
<span class="verb">
<span class="cmtt-10"> [[1,2],[3,4]|[5,6,7]] 
</span>
</span>
</li>
</ol>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="newtheorem">
<!--l. 687-->
<p class="noindent">
<span class="head">
<span class="cmbx-10"> <strong>Exercise</strong>
</span>
<span class="cmbx-10">  4.3 
</span>
</span>
<a id="x30-430413">
</a>
<span class="cmti-10"> Write a predicate 
</span>
<span class="verb">
<span class="cmtt-10"> second(X,List) 
</span>
</span>
<span class="cmti-10"> which checks whether 
</span>
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span>
<span class="cmti-10"> is 
</span>
<span class="cmti-10"> the second element of 
</span>
<span class="verb">
<span class="cmtt-10"> List 
</span>
</span>
<span class="cmti-10"> . 
</span>
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="newtheorem">
<!--l. 693-->
<p class="noindent">
<span class="head">
<span class="cmbx-10"> <strong>Exercise</strong>
</span>
<span class="cmbx-10">  4.4 
</span>
</span>
<a id="x30-430424">
</a>
<span class="cmti-10"> Write a predicate 
</span>
<span class="verb">
<span class="cmtt-10"> swap12(List1,List2) 
</span>
</span>
<span class="cmti-10"> which checks whether 
</span>
<span class="verb">
<span class="cmtt-10"> List1 
</span>
</span>
<span class="cmti-10"> is identical to 
</span>
<span class="verb">
<span class="cmtt-10"> List2 
</span>
</span>
<span class="cmti-10"> , except that the first two elements are exchanged. 
</span>
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="newtheorem">
<!--l. 700-->
<p class="noindent">
<span class="head">
<span class="cmbx-10"> <strong>Exercise</strong>
</span>
<span class="cmbx-10">  4.5 
</span>
</span>
<a id="x30-430435">
</a>
<span class="cmti-10"> Suppose we are given a knowledge base with the following facts: 
</span>
</p>
<!--l. 702-->
<p class="indent">
</p>
<div class="fancyvrb" id="fancyvrb217">
<a id="x30-43045r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  tran(eins,one). 
</span>
<br class="fancyvrb"/>
<a id="x30-43047r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  tran(zwei,two). 
</span>
<br class="fancyvrb"/>
<a id="x30-43049r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  tran(drei,three). 
</span>
<br class="fancyvrb"/>
<a id="x30-43051r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  tran(vier,four). 
</span>
<br class="fancyvrb"/>
<a id="x30-43053r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  tran(fuenf,five). 
</span>
<br class="fancyvrb"/>
<a id="x30-43055r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  tran(sechs,six). 
</span>
<br class="fancyvrb"/>
<a id="x30-43057r7">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  tran(sieben,seven). 
</span>
<br class="fancyvrb"/>
<a id="x30-43059r8">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  tran(acht,eight). 
</span>
<br class="fancyvrb"/>
<a id="x30-43061r9">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  tran(neun,nine). 
</span>
</div>
<!--l. 716-->
<p class="indent">
<span class="cmti-10"> Write a predicate 
</span>
<span class="verb">
<span class="cmtt-10"> listtran(G,E) 
</span>
</span>
<span class="cmti-10"> which translates a list of German number words 
</span>
<span class="cmti-10"> to the corresponding list of English number words. For example: 
</span>
</p>
<div class="fancyvrb" id="fancyvrb218">
<a id="x30-43063r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  listtran([eins,neun,zwei],X). 
</span>
</div>
<!--l. 722-->
<p class="noindent">
<span class="cmti-10"> should give: 
</span>
</p>
<div class="fancyvrb" id="fancyvrb219">
<a id="x30-43065r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [one,nine,two]. 
</span>
</div>
<!--l. 727-->
<p class="indent">
<span class="cmti-10"> Your program should also work in the other direction. For example, if you give it 
</span>
<span class="cmti-10"> the query 
</span>
</p>
<div class="fancyvrb" id="fancyvrb220">
<a id="x30-43067r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  listtran(X,[one,seven,six,two]). 
</span>
</div>
<!--l. 732-->
<p class="noindent">
<span class="cmti-10"> it should return: 
</span>
</p>
<div class="fancyvrb" id="fancyvrb221">
<a id="x30-43069r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [eins,sieben,sechs,zwei]. 
</span>
</div>
<!--l. 738-->
<p class="indent">
<span class="cmti-10"> (Hint: to answer this question, first ask yourself “How do I translate the 
</span> empty 
<span class="cmti-10"> list of number words?”. That’s the base case. For non-empty lists, first translate the 
</span>
<span class="cmti-10"> head of the list, then use recursion to translate the tail.) 
</span>
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="newtheorem">
<!--l. 745-->
<p class="noindent">
<span class="head">
<span class="cmbx-10"> <strong>Exercise</strong>
</span>
<span class="cmbx-10">  4.6 
</span>
</span>
<a id="x30-430706">
</a>
<span class="cmti-10"> Write a predicate 
</span>
<span class="verb">
<span class="cmtt-10"> twice(In,Out) 
</span>
</span>
<span class="cmti-10"> whose left argument is a list, and 
</span>
<span class="cmti-10"> whose right argument is a list consisting of every element in the left list written twice. 
</span>
<span class="cmti-10"> For example, the query 
</span>
</p>
<div class="fancyvrb" id="fancyvrb222">
<a id="x30-43072r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  twice([a,4,buggle],X). 
</span>
</div>
<!--l. 752-->
<p class="noindent">
<span class="cmti-10"> should return 
</span>
</p>
<div class="fancyvrb" id="fancyvrb223">
<a id="x30-43074r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [a,a,4,4,buggle,buggle]). 
</span>
</div>
<!--l. 756-->
<p class="noindent">
<span class="cmti-10"> And the query 
</span>
</p>
<div class="fancyvrb" id="fancyvrb224">
<a id="x30-43076r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  twice([1,2,1,1],X). 
</span>
</div>
<!--l. 760-->
<p class="noindent">
<span class="cmti-10"> should return 
</span>
</p>
<div class="fancyvrb" id="fancyvrb225">
<a id="x30-43078r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [1,1,2,2,1,1,1,1]. 
</span>
</div>
<!--l. 765-->
<p class="indent">
<span class="cmti-10"> (Hint: to answer this question, first ask yourself “What should happen when the 
</span>
<span class="cmti-10"> first argument is the 
</span> empty 
<span class="cmti-10"> list?”. That’s the base case. For non-empty lists, think 
</span>
<span class="cmti-10"> about what you should do with the head, and use recursion to handle the 
</span>
<span class="cmti-10"> tail.) 
</span>
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="newtheorem">
<!--l. 772-->
<p class="noindent">
<span class="head">
<span class="cmbx-10"> <strong>Exercise</strong>
</span>
<span class="cmbx-10">  4.7 
</span>
</span>
<a id="x30-430797">
</a>
<span class="cmti-10"> Draw the search trees for the following three queries: 
</span>
</p>
<!--l. 774-->
<p class="indent">
</p>
<div class="fancyvrb" id="fancyvrb226">
<a id="x30-43081r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  member(a,[c,b,a,y]). 
</span>
<br class="fancyvrb"/>
<a id="x30-43083r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x30-43085r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  member(x,[a,b,c]). 
</span>
<br class="fancyvrb"/>
<a id="x30-43087r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x30-43089r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  member(X,[a,b,c]). 
</span>
<br class="fancyvrb"/>
<a id="x30-43091r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
</div>
<!--l. 782-->
<p class="noindent">
<span class="cmti-10"> (Search trees were introduced in Chapter 
</span>
<span class="cmti-10">   
</span>
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch2">
<span class="cmti-10"> 2 
</span>
<!--tex4ht:ref: CHAPTER2 -->
</a>
<span class="cmti-10"> .) 
</span>
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse17"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse15"> prev 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse15"> prev-tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse16"> front 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch4"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse16"> prev 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse16"> prev-tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=#taillpn-htmlse17"> tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch4"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<h3 class="sectionHead">
<span class="titlemark"> 4.5 
</span>
<a id="x31-440004.5">
</a> Practical Session 
</h3>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> The purpose of Practical Session 4 is to help you get familiar with the idea of recursing down lists. We first suggest some traces for you to carry out, and then some programming exercises. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> First, systematically carry out a number of traces on 
<span class="verb">
<span class="cmtt-10"> a2b/2 
</span>
</span> to make sure you fully understand how it works. In particular: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<ol class="enumerate1">
<li class="enumerate" id="x31-44002x1"> Trace some examples, not involving variables, that succeed. For example, trace the query 
<span class="verb">
<span class="cmtt-10"> a2b([a,a,a,a],[b,b,b,b]) 
</span>
</span> and relate the output to the discussion in the text. 
</li>
<li class="enumerate" id="x31-44004x2"> Trace some simple examples that fail. Try examples involving lists of different lengths (such as 
<span class="verb">
<span class="cmtt-10"> a2b([a,a,a,a],[b,b,b]) 
</span>
</span> ) and examples involving symbols other than 
<span class="verb">
<span class="cmtt-10"> a 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> b 
</span>
</span> (such as 
<span class="verb">
<span class="cmtt-10"> a2b([a,c,a,a],[b,b,5,4]) 
</span>
</span> ). 
</li>
<li class="enumerate" id="x31-44006x3"> Trace some examples involving variables. For example, try tracing 
<span class="verb">
<span class="cmtt-10"> a2b([a,a,a,a],X) 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> a2b(X,[b,b,b,b]) 
</span>
</span> . 
</li>
<li class="enumerate" id="x31-44008x4"> Make sure you understand what happens when both arguments in the query are variables. For example, carry out a trace on the query 
<span class="verb">
<span class="cmtt-10"> a2b(X,Y) 
</span>
</span> . 
</li>
<li class="enumerate" id="x31-44010x5"> Carry out a series of similar traces involving 
<span class="verb">
<span class="cmtt-10"> member/2 
</span>
</span> . That is, carry out traces involving simple queries that succeed (such as 
<span class="verb">
<span class="cmtt-10"> member(a,[1,2,a,b]) 
</span>
</span> ), simple queries that fail (such as 
<span class="verb">
<span class="cmtt-10"> member(z,[1,2,a,b]) 
</span>
</span> ), and queries involving variables (such as 
<span class="verb">
<span class="cmtt-10"> member(X,[1,2,a,b]) 
</span>
</span> ). In all cases, make sure that you understand why the recursion halts. 
</li>
</ol>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Having done this, try the following. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<ol class="enumerate1">
<li class="enumerate" id="x31-44012x1"> Write a 3-place predicate 
<span class="verb">
<span class="cmtt-10"> combine1 
</span>
</span> which takes three lists as arguments and combines the elements of the first two lists into the third as follows: 
<div class="fancyvrb" id="fancyvrb227">
<a id="x31-44014r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  combine1([a,b,c],[1,2,3],X). 
</span>
<br class="fancyvrb"/>
<a id="x31-44016r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x31-44018r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [a,1,b,2,c,3] 
</span>
<br class="fancyvrb"/>
<a id="x31-44020r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x31-44022r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  combine1([f,b,yip,yup],[glu,gla,gli,glo],Result). 
</span>
<br class="fancyvrb"/>
<a id="x31-44024r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x31-44026r7">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Result 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [f,glu,b,gla,yip,gli,yup,glo] 
</span>
</div>
</li>
<li class="enumerate" id="x31-44028x2"> Now write a 3-place predicate 
<span class="verb">
<span class="cmtt-10"> combine2 
</span>
</span> which takes three lists as arguments and combines the elements of the first two lists into the third as follows: 
<div class="fancyvrb" id="fancyvrb228">
<a id="x31-44030r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  combine2([a,b,c],[1,2,3],X). 
</span>
<br class="fancyvrb"/>
<a id="x31-44032r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x31-44034r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [[a,1],[b,2],[c,3]] 
</span>
<br class="fancyvrb"/>
<a id="x31-44036r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x31-44038r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  combine2([f,b,yip,yup],[glu,gla,gli,glo],Result). 
</span>
<br class="fancyvrb"/>
<a id="x31-44040r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x31-44042r7">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Result 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [[f,glu],[b,gla],[yip,gli],[yup,glo]] 
</span>
</div>
</li>
<li class="enumerate" id="x31-44044x3"> Finally, write a 3-place predicate 
<span class="verb">
<span class="cmtt-10"> combine3 
</span>
</span> which takes three lists as arguments and combines the elements of the first two lists into the third as follows: 
<div class="fancyvrb" id="fancyvrb229">
<a id="x31-44046r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  combine3([a,b,c],[1,2,3],X). 
</span>
<br class="fancyvrb"/>
<a id="x31-44048r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x31-44050r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [j(a,1),j(b,2),j(c,3)] 
</span>
<br class="fancyvrb"/>
<a id="x31-44052r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x31-44054r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  combine3([f,b,yip,yup],[glu,gla,gli,glo],R). 
</span>
<br class="fancyvrb"/>
<a id="x31-44056r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x31-44058r7">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  R 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [j(f,glu),j(b,gla),j(yip,gli),j(yup,glo)] 
</span>
</div>
</li>
</ol>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> All three programs are pretty much the same as 
<span class="verb">
<span class="cmtt-10"> a2b/2 
</span>
</span> (though they manipulate three lists, not two). That is, all three can be written by recursing down the lists, doing something to the heads, and then recursively doing the same thing to the tails. Indeed, once you have written 
<span class="verb">
<span class="cmtt-10"> combine1 
</span>
</span> , you just need to change what you do to the heads to get 
<span class="verb">
<span class="cmtt-10"> combine2 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> combine3 
</span>
</span> . 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse16"> prev 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse16"> prev-tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse17"> front 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch4"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse19"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=#taillpn-htmlse18"> tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch5"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<h3 class="sectionHead">
<span class="titlemark"> 5.1 
</span>
<a id="x33-460005.1">
</a> Arithmetic in Prolog 
</h3>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Prolog provides a number of basic arithmetic tools for manipulating integers (that is, numbers of the form ...-3, -2, -1, 0, 1, 2, 3, 4...). Most Prolog implementation also provide tools for handling real numbers (or floating point numbers) such as 1.53 or 6 
<span class="cmmi-10"> . 
</span> 35 
<span class="cmsy-10"> × 
</span> 10 
<sup>
<span class="cmr-7"> 5 
</span>
</sup> , but we’re not going to discuss these, for they are not particularly useful for the symbolic processing tasks discussed in this book. Integers, on the other hand, are useful in connection with symbolic tasks (we use them to state the length of lists, for example) so it is important to understand how to work with them. We’ll start by looking at how Prolog handles the four basic operations of addition, multiplication, subtraction, and division. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="center">
<!--l. 34-->
<p class="noindent">
</p>
<div class="tabular">
<table cellpadding="0" cellspacing="0" class="tabular" id="TBL-1">
<colgroup id="TBL-1-1g">
<col id="TBL-1-1"/>
<col id="TBL-1-2"/>
</colgroup>
<tr id="TBL-1-1-" style="vertical-align:baseline;">
<td class="td11" id="TBL-1-1-1" style="white-space:nowrap; text-align:left;"> Arithmetic examples 
</td>
<td class="td11" id="TBL-1-1-2" style="white-space:nowrap; text-align:left;"> Prolog Notation 
</td>
</tr>
<tr id="TBL-1-2-" style="vertical-align:baseline;">
<td class="td11" id="TBL-1-2-1" style="white-space:nowrap; text-align:left;"> 6 + 2 = 8 
</td>
<td class="td11" id="TBL-1-2-2" style="white-space:nowrap; text-align:left;">
<span class="verb">
<span class="cmtt-10"> 8 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  6+2. 
</span>
</span>
</td>
</tr>
<tr id="TBL-1-3-" style="vertical-align:baseline;">
<td class="td11" id="TBL-1-3-1" style="white-space:nowrap; text-align:left;"> 6 
<span class="cmsy-10"> ∗ 
</span> 2 = 12 
</td>
<td class="td11" id="TBL-1-3-2" style="white-space:nowrap; text-align:left;">
<span class="verb">
<span class="cmtt-10"> 12 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  6*2. 
</span>
</span>
</td>
</tr>
<tr id="TBL-1-4-" style="vertical-align:baseline;">
<td class="td11" id="TBL-1-4-1" style="white-space:nowrap; text-align:left;"> 6 
<span class="cmsy-10"> − 
</span> 2 = 4 
</td>
<td class="td11" id="TBL-1-4-2" style="white-space:nowrap; text-align:left;">
<span class="verb">
<span class="cmtt-10"> 4 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  6-2. 
</span>
</span>
</td>
</tr>
<tr id="TBL-1-5-" style="vertical-align:baseline;">
<td class="td11" id="TBL-1-5-1" style="white-space:nowrap; text-align:left;"> 6 
<span class="cmsy-10"> − 
</span> 8 = 
<span class="cmsy-10"> − 
</span> 2 
</td>
<td class="td11" id="TBL-1-5-2" style="white-space:nowrap; text-align:left;">
<span class="verb">
<span class="cmtt-10"> -2 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  6-8. 
</span>
</span>
</td>
</tr>
<tr id="TBL-1-6-" style="vertical-align:baseline;">
<td class="td11" id="TBL-1-6-1" style="white-space:nowrap; text-align:left;"> 6 
<span class="cmsy-10"> ÷ 
</span> 2 = 3 
</td>
<td class="td11" id="TBL-1-6-2" style="white-space:nowrap; text-align:left;">
<span class="verb">
<span class="cmtt-10"> 3 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  6/2. 
</span>
</span>
</td>
</tr>
<tr id="TBL-1-7-" style="vertical-align:baseline;">
<td class="td11" id="TBL-1-7-1" style="white-space:nowrap; text-align:left;"> 7 
<span class="cmsy-10"> ÷ 
</span> 2 = 3 
</td>
<td class="td11" id="TBL-1-7-2" style="white-space:nowrap; text-align:left;">
<span class="verb">
<span class="cmtt-10"> 3 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  7/2. 
</span>
</span>
</td>
</tr>
<tr id="TBL-1-8-" style="vertical-align:baseline;">
<td class="td11" id="TBL-1-8-1" style="white-space:nowrap; text-align:left;"> 1 is the remainder when 7 is divided by 2 
</td>
<td class="td11" id="TBL-1-8-2" style="white-space:nowrap; text-align:left;">
<span class="verb">
<span class="cmtt-10"> 1 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  mod(7,2). 
</span>
</span>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Note that as we are working with integers, division gives us back an integer answer. Thus 7 
<span class="cmsy-10"> ÷ 
</span> 2 gives 3 as an answer, leaving remainder 1. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Posing the following queries yields the following responses 
<a id="dx33-46001">
</a> : 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb230">
<a id="x33-46003r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  8 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  6+2. 
</span>
<br class="fancyvrb"/>
<a id="x33-46005r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
<br class="fancyvrb"/>
<a id="x33-46007r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x33-46009r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  12 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  6*2. 
</span>
<br class="fancyvrb"/>
<a id="x33-46011r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
<br class="fancyvrb"/>
<a id="x33-46013r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x33-46015r7">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  -2 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  6-8. 
</span>
<br class="fancyvrb"/>
<a id="x33-46017r8">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
<br class="fancyvrb"/>
<a id="x33-46019r9">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x33-46021r10">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  3 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  6/2. 
</span>
<br class="fancyvrb"/>
<a id="x33-46023r11">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
<br class="fancyvrb"/>
<a id="x33-46025r12">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x33-46027r13">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  1 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  mod(7,2). 
</span>
<br class="fancyvrb"/>
<a id="x33-46029r14">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> More importantly, we can work out the answers to arithmetic questions by using variables. For example: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb231">
<a id="x33-46031r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  6+2. 
</span>
<br class="fancyvrb"/>
<a id="x33-46033r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x33-46035r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  8 
</span>
<br class="fancyvrb"/>
<a id="x33-46037r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x33-46039r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  6*2. 
</span>
<br class="fancyvrb"/>
<a id="x33-46041r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x33-46043r7">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  12 
</span>
<br class="fancyvrb"/>
<a id="x33-46045r8">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x33-46047r9">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  R 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  mod(7,2). 
</span>
<br class="fancyvrb"/>
<a id="x33-46049r10">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x33-46051r11">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  R 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  1 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Moreover, we can use arithmetic operations when we define predicates. Here’s a simple example. Let’s define a predicate 
<span class="verb">
<span class="cmtt-10"> add_3_and_double/2 
</span>
</span> whose arguments are both integers. This predicate takes its first argument, adds three to it, doubles the result, and returns the number obtained as the second argument. We define this predicate as follows: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb232">
<a id="x33-46053r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  add_3_and_double(X,Y) 
</span>
<span class="cmtt-10">  :- 
</span>
<span class="cmtt-10">  Y 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  (X+3)*2. 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> And indeed, this works: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb233">
<a id="x33-46055r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  add_3_and_double(1,X). 
</span>
<br class="fancyvrb"/>
<a id="x33-46057r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x33-46059r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  8 
</span>
<br class="fancyvrb"/>
<a id="x33-46061r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x33-46063r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  add_3_and_double(2,X). 
</span>
<br class="fancyvrb"/>
<a id="x33-46065r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x33-46067r7">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  10 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> One other thing. Prolog understands the usual conventions we use for disambiguating arithmetical expressions. For example, when we write 3 + 2 
<span class="cmsy-10"> × 
</span> 4 we mean 3 + (2 
<span class="cmsy-10"> × 
</span> 4) and not (3 + 2) 
<span class="cmsy-10"> × 
</span> 4, and Prolog knows this convention: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb234">
<a id="x33-46069r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  3+2*4. 
</span>
<br class="fancyvrb"/>
<a id="x33-46071r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x33-46073r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  11 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse19"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse18"> front 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch5"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse20"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse18"> prev 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse18"> prev-tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=#taillpn-htmlse19"> tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch5"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<h3 class="sectionHead">
<span class="titlemark"> 5.2 
</span>
<a id="x34-470005.2">
</a> A Closer Look 
</h3>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> That’s the basics, but we need to know more. The most important to grasp is this: +, *, -, 
<span class="cmsy-10"> ÷ 
</span> and 
<span class="verb">
<span class="cmtt-10"> mod 
</span>
</span> do 
<span class="cmti-10"> not 
</span> carry out any arithmetic. In fact, expressions such as 
<span class="verb">
<span class="cmtt-10"> 3+2 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> 3-2 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> 3*2 
</span>
</span> are simply terms. The functors of these terms are 
<span class="verb">
<span class="cmtt-10"> + 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> - 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> * 
</span>
</span> respectively, and the arguments are 
<span class="verb">
<span class="cmtt-10"> 3 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> 2 
</span>
</span> . Apart from the fact that the functors go between their arguments (instead of in front of them) these are ordinary Prolog terms, and unless we do something special, Prolog will not actually do any arithmetic. In particular, if we pose the query 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb235">
<a id="x34-47002r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  3+2 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> we don’t get back the answer 
<span class="verb">
<span class="cmtt-10"> X=5 
</span>
</span> . Instead we get back 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb236">
<a id="x34-47004r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  3+2 
</span>
<br class="fancyvrb"/>
<a id="x34-47006r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> That is, Prolog has simply unified the variable 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> to the complex term 
<span class="verb">
<span class="cmtt-10"> 3+2 
</span>
</span> . It has 
<span class="cmti-10"> not 
</span> carried out any arithmetic. It has simply done what it usually does when 
<span class="cmtt-10"> =/2 
</span> is used: performed unification. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Similarly, if we pose the query 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb237">
<a id="x34-47008r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  3+2*5 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  X 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> we get the response 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb238">
<a id="x34-47010r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  3+2*5 
</span>
<br class="fancyvrb"/>
<a id="x34-47012r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Again, Prolog has simply bound the variable 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> to the complex term 
<span class="verb">
<span class="cmtt-10"> 3+2*5 
</span>
</span> . It did not evaluate this expression to 13. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> To force Prolog to actually evaluate arithmetic expressions we have to use 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb239">
<a id="x34-47014r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  is 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> just as we did in our earlier examples. In fact, 
<span class="verb">
<span class="cmtt-10"> is 
</span>
</span> does something very special: it sends a signal to Prolog that says “Hey! Don’t treat this expression as an ordinary complex term! Call up your built-in arithmetic capabilities and carry out the calculations!” 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> In short, 
<span class="verb">
<span class="cmtt-10"> is 
</span>
</span> forces Prolog to act in an unusual way. Normally Prolog is quite happy just unifying variables to structures: that’s its job, after all. Arithmetic is something extra that has been bolted on to the basic Prolog engine because it is useful. Unsurprisingly, there are some restrictions on this extra ability, and we need to know what they are. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> For a start, the arithmetic expressions to be evaluated must be on the right hand side of 
<span class="verb">
<span class="cmtt-10"> is 
</span>
</span> . In our earlier examples we carefully posed the query 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb240">
<a id="x34-47016r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  6+2. 
</span>
<br class="fancyvrb"/>
<a id="x34-47018r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x34-47020r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  8 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> which is the right way to do it. If instead we had asked 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb241">
<a id="x34-47022r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  6+2 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  X. 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> we would have got a message saying 
<span class="verb">
<span class="cmtt-10"> instantiation_error 
</span>
</span> , or something similar. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Moreover, although we are free to use variables on the right hand side of 
<span class="verb">
<span class="cmtt-10"> is 
</span>
</span> , when we actually carry out evaluation, the variable must already have been instantiated to a variable-free arithmetic expression. If the variable is uninstantiated, or if it is instantiated to something other than an integer, we will get some sort of 
<span class="verb">
<span class="cmtt-10"> instantiation_error 
</span>
</span> message. This is because arithmetic isn’t performed using Prolog’s usual unification and knowledge base search mechanisms: it’s done by calling up a special black box which knows about integer arithmetic. If we hand the black box the wrong kind of data, it’s going to complain. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Here’s an example. Recall our “add 3 and double it” predicate. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb242">
<a id="x34-47024r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  add_3_and_double(X,Y) 
</span>
<span class="cmtt-10">  :- 
</span>
<span class="cmtt-10">  Y 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  (X+3)*2. 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> When we described this predicate, we carefully said that it added 3 to its first argument, doubled the result, and returned the answer in its second argument. For example, 
<span class="verb">
<span class="cmtt-10"> add_3_and_double(3,X) 
</span>
</span> returns 
<span class="verb">
<span class="cmtt-10"> X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  12 
</span>
</span> . We didn’t say anything about using this predicate in the reverse direction. For example, we might hope that posing the query 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb243">
<a id="x34-47026r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  add_3_and_double(X,12). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> would return the answer 
<span class="verb">
<span class="cmtt-10"> X=3 
</span>
</span> . But it doesn’t. Instead we get the 
<span class="verb">
<span class="cmtt-10"> instantiation_error 
</span>
</span> message. Why? Well, when we pose the query this way round, we are asking Prolog to evaluate 
<span class="verb">
<span class="cmtt-10"> 12 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  (X+3)*2 
</span>
</span> , which it 
<span class="cmti-10"> can’t 
</span> do as 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> is not instantiated. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Two final remarks. As we’ve already mentioned, for Prolog 
<span class="verb">
<span class="cmtt-10"> 3 
</span>
<span class="cmtt-10">  + 
</span>
<span class="cmtt-10">  2 
</span>
</span> is just a term. In fact, for Prolog, it really 
<span class="cmti-10"> is 
</span> the term 
<span class="cmti-10"> +(3,2) 
</span> . The expression 
<span class="verb">
<span class="cmtt-10"> 3 
</span>
<span class="cmtt-10">  + 
</span>
<span class="cmtt-10">  2 
</span>
</span> is just a user-friendly notation that’s nicer for us to use. This means that, if you want to, you can give Prolog queries like 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb244">
<a id="x34-47028r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  +(3,2) 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> and Prolog will correctly reply 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb245">
<a id="x34-47030r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  5 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Actually, you can even given Prolog the query 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb246">
<a id="x34-47032r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  is(X,+(3,2)) 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> and Prolog will respond 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb247">
<a id="x34-47034r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  5 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> This is because, for Prolog, the expression 
<span class="verb">
<span class="cmtt-10"> X 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  +(3,2) 
</span>
</span> really is the term 
<span class="verb">
<span class="cmtt-10"> is(X,+(3,2)) 
</span>
</span> . The expression 
<span class="verb">
<span class="cmtt-10"> X 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  +(3,2) 
</span>
</span> is just user-friendly notation. Underneath, as always, Prolog is just working away with terms. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Summing up, arithmetic in Prolog is easy to use. Pretty much all you have to remember is to use 
<span class="verb">
<span class="cmtt-10"> is 
</span>
</span> to force evaluation, that stuff to be evaluated must go to the right of 
<span class="verb">
<span class="cmtt-10"> is 
</span>
</span> , and to take care that any variables are correctly instantiated. But there is a deeper point that is worth reflecting on: bolting on the extra capability to do arithmetic in this way has further widened the gap between the procedural and declarative meanings of Prolog programs. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse20"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse18"> prev 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse18"> prev-tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse19"> front 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch5"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse21"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse19"> prev 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse19"> prev-tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=#taillpn-htmlse20"> tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch5"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<h3 class="sectionHead">
<span class="titlemark"> 5.3 
</span>
<a id="x35-480005.3">
</a> Arithmetic and Lists 
</h3>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Probably the most important use of arithmetic in this book is to tell us useful facts about data-structures, such as lists. For example, it can be useful to know how long a list is. We’ll give some examples of using lists together with arithmetic capabilities. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> How long is a list? Here’s a recursive definition. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<ol class="enumerate1">
<li class="enumerate" id="x35-48002x1"> The empty list has length zero. 
</li>
<li class="enumerate" id="x35-48004x2"> A non-empty list has length 1 + 
<span class="cmti-10"> len 
</span> (T), where 
<span class="cmti-10"> len 
</span> (T) is the length of its tail. 
</li>
</ol>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> This definition is practically a Prolog program already. Here’s the code we need: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb248">
<a id="x35-48006r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  len([],0). 
</span>
<br class="fancyvrb"/>
<a id="x35-48008r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  len([_|T],N) 
</span>
<span class="cmtt-10">  :- 
</span>
<span class="cmtt-10">  len(T,X), 
</span>
<span class="cmtt-10">  N 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  X+1. 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> This predicate works in the expected way. For example: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb249">
<a id="x35-48010r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  len([a,b,c,d,e,[a,b],g],X). 
</span>
<br class="fancyvrb"/>
<a id="x35-48012r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x35-48014r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  7 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Now, this is quite a good program: it’s easy to understand and efficient. But there is another method of finding the length of a list. We’ll now look at this alternative, because it introduces the idea of accumulators. If you’re used to other programming languages, you’re probably used to the idea of using variables to hold intermediate results. An accumulator is the Prolog analog of this idea. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Here’s how to use an accumulator to calculate the length of a list. We shall define a predicate 
<span class="verb">
<span class="cmtt-10"> accLen 
</span>
</span> /3 which takes the following arguments. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb250">
<a id="x35-48016r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  accLen(List,Acc,Length) 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Here 
<span class="verb">
<span class="cmtt-10"> List 
</span>
</span> is the list whose length we want to find, and 
<span class="verb">
<span class="cmtt-10"> Length 
</span>
</span> is its length (an integer). What about 
<span class="verb">
<span class="cmtt-10"> Acc 
</span>
</span> ? This is the accumulator we will use to keep track of intermediate values for length (so it will also be an integer). Here’s what we do. When we call this predicate, we are going to give 
<span class="verb">
<span class="cmtt-10"> Acc 
</span>
</span> an initial value of 
<span class="verb">
<span class="cmtt-10"> 0 
</span>
</span> . We then recursively work our way down the list, adding 
<span class="verb">
<span class="cmtt-10"> 1 
</span>
</span> to 
<span class="verb">
<span class="cmtt-10"> Acc 
</span>
</span> each time we find a head element, until we reach the empty list. When we reach the empty list, 
<span class="verb">
<span class="cmtt-10"> Acc 
</span>
</span> will contain the length of the list. Here’s the code: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb251">
<a id="x35-48018r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  accLen([_|T],A,L) 
</span>
<span class="cmtt-10">  :- 
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Anew 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  A+1, 
</span>
<span class="cmtt-10">  accLen(T,Anew,L). 
</span>
<br class="fancyvrb"/>
<a id="x35-48020r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  accLen([],A,A). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> The base case of the definition, unifies the second and third arguments. Why? Because this trivial unification is a nice way of making sure that the result, that is, the length of the list, is returned. When we reach the end of the list, the accumulator (the second variable) contains the length of the list. So we give this value (via unification) to the length variable (the third variable). Here’s an example trace. You can clearly see how the length variable gets its value at the bottom of the recursion and passes it upwards as Prolog is coming out of the recursion. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb252">
<a id="x35-48022r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  accLen([a,b,c],0,L). 
</span>
<br class="fancyvrb"/>
<a id="x35-48024r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Call: 
</span>
<span class="cmtt-10">  (6) 
</span>
<span class="cmtt-10">  accLen([a, 
</span>
<span class="cmtt-10">  b, 
</span>
<span class="cmtt-10">  c], 
</span>
<span class="cmtt-10">  0, 
</span>
<span class="cmtt-10">  _G449) 
</span>
<span class="cmtt-10">  ? 
</span>
<br class="fancyvrb"/>
<a id="x35-48026r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Call: 
</span>
<span class="cmtt-10">  (7) 
</span>
<span class="cmtt-10">  _G518 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  0+1 
</span>
<span class="cmtt-10">  ? 
</span>
<br class="fancyvrb"/>
<a id="x35-48028r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Exit: 
</span>
<span class="cmtt-10">  (7) 
</span>
<span class="cmtt-10">  1 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  0+1 
</span>
<span class="cmtt-10">  ? 
</span>
<br class="fancyvrb"/>
<a id="x35-48030r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Call: 
</span>
<span class="cmtt-10">  (7) 
</span>
<span class="cmtt-10">  accLen([b, 
</span>
<span class="cmtt-10">  c], 
</span>
<span class="cmtt-10">  1, 
</span>
<span class="cmtt-10">  _G449) 
</span>
<span class="cmtt-10">  ? 
</span>
<br class="fancyvrb"/>
<a id="x35-48032r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Call: 
</span>
<span class="cmtt-10">  (8) 
</span>
<span class="cmtt-10">  _G521 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  1+1 
</span>
<span class="cmtt-10">  ? 
</span>
<br class="fancyvrb"/>
<a id="x35-48034r7">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Exit: 
</span>
<span class="cmtt-10">  (8) 
</span>
<span class="cmtt-10">  2 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  1+1 
</span>
<span class="cmtt-10">  ? 
</span>
<br class="fancyvrb"/>
<a id="x35-48036r8">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Call: 
</span>
<span class="cmtt-10">  (8) 
</span>
<span class="cmtt-10">  accLen([c], 
</span>
<span class="cmtt-10">  2, 
</span>
<span class="cmtt-10">  _G449) 
</span>
<span class="cmtt-10">  ? 
</span>
<br class="fancyvrb"/>
<a id="x35-48038r9">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Call: 
</span>
<span class="cmtt-10">  (9) 
</span>
<span class="cmtt-10">  _G524 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  2+1 
</span>
<span class="cmtt-10">  ? 
</span>
<br class="fancyvrb"/>
<a id="x35-48040r10">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Exit: 
</span>
<span class="cmtt-10">  (9) 
</span>
<span class="cmtt-10">  3 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  2+1 
</span>
<span class="cmtt-10">  ? 
</span>
<br class="fancyvrb"/>
<a id="x35-48042r11">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Call: 
</span>
<span class="cmtt-10">  (9) 
</span>
<span class="cmtt-10">  accLen([], 
</span>
<span class="cmtt-10">  3, 
</span>
<span class="cmtt-10">  _G449) 
</span>
<span class="cmtt-10">  ? 
</span>
<br class="fancyvrb"/>
<a id="x35-48044r12">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Exit: 
</span>
<span class="cmtt-10">  (9) 
</span>
<span class="cmtt-10">  accLen([], 
</span>
<span class="cmtt-10">  3, 
</span>
<span class="cmtt-10">  3) 
</span>
<span class="cmtt-10">  ? 
</span>
<br class="fancyvrb"/>
<a id="x35-48046r13">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Exit: 
</span>
<span class="cmtt-10">  (8) 
</span>
<span class="cmtt-10">  accLen([c], 
</span>
<span class="cmtt-10">  2, 
</span>
<span class="cmtt-10">  3) 
</span>
<span class="cmtt-10">  ? 
</span>
<br class="fancyvrb"/>
<a id="x35-48048r14">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Exit: 
</span>
<span class="cmtt-10">  (7) 
</span>
<span class="cmtt-10">  accLen([b, 
</span>
<span class="cmtt-10">  c], 
</span>
<span class="cmtt-10">  1, 
</span>
<span class="cmtt-10">  3) 
</span>
<span class="cmtt-10">  ? 
</span>
<br class="fancyvrb"/>
<a id="x35-48050r15">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Exit: 
</span>
<span class="cmtt-10">  (6) 
</span>
<span class="cmtt-10">  accLen([a, 
</span>
<span class="cmtt-10">  b, 
</span>
<span class="cmtt-10">  c], 
</span>
<span class="cmtt-10">  0, 
</span>
<span class="cmtt-10">  3) 
</span>
<span class="cmtt-10">  ? 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> As a final step, we’ll define a predicate which calls 
<span class="verb">
<span class="cmtt-10"> accLen 
</span>
</span> for us, and gives it the initial value of 0: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb253">
<a id="x35-48052r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  leng(List,Length) 
</span>
<span class="cmtt-10">  :- 
</span>
<span class="cmtt-10">  accLen(List,0,Length). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> So now we can pose queries like this: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb254">
<a id="x35-48054r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  leng([a,b,c,d,e,[a,b],g],X). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Accumulators are extremely common in Prolog programs. (We’ll see another accumulator based program in this chapter, and some more in later chapters.) But why is this? In what way is 
<span class="verb">
<span class="cmtt-10"> accLen 
</span>
</span> better than 
<span class="verb">
<span class="cmtt-10"> len 
</span>
</span> ? After all, it looks more difficult. The answer is that 
<span class="verb">
<span class="cmtt-10"> accLen 
</span>
</span> is tail recursive while 
<span class="verb">
<span class="cmtt-10"> len 
</span>
</span> is not. In tail recursive programs, the result is fully calculated once we reached the bottom of the recursion and just has to be passed up. In recursive programs which are not tail recursive, there are goals at other levels of recursion which have to wait for the answer from a lower level of recursion before they can be evaluated. To understand this, compare the traces for the queries 
<span class="verb">
<span class="cmtt-10"> accLen([a,b,c],0,L) 
</span>
</span> (see above) and 
<span class="verb">
<span class="cmtt-10"> len([a,b,c],0,L) 
</span>
</span> (given below). In the first case the result is built while going into the recursion — once the bottom is reached at 
<span class="verb">
<span class="cmtt-10"> accLen([],3,_G449) 
</span>
</span> , the result is there and only has to be passed up. In the second case the result is built while coming out of the recursion; the result of 
<span class="verb">
<span class="cmtt-10"> len([b,c], 
</span>
<span class="cmtt-10">  _G481) 
</span>
</span> , for instance, is only computed after the recursive call of 
<span class="verb">
<span class="cmtt-10"> len 
</span>
</span> has been completed and the result of 
<span class="verb">
<span class="cmtt-10"> len([c],_G489) 
</span>
</span> is known. In short, tail recursive programs have less bookkeeping overhead, and this makes them more efficient. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb255">
<a id="x35-48056r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  len([a,b,c],L). 
</span>
<br class="fancyvrb"/>
<a id="x35-48058r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Call: 
</span>
<span class="cmtt-10">  (6) 
</span>
<span class="cmtt-10">  len([a, 
</span>
<span class="cmtt-10">  b, 
</span>
<span class="cmtt-10">  c], 
</span>
<span class="cmtt-10">  _G418) 
</span>
<span class="cmtt-10">  ? 
</span>
<br class="fancyvrb"/>
<a id="x35-48060r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Call: 
</span>
<span class="cmtt-10">  (7) 
</span>
<span class="cmtt-10">  len([b, 
</span>
<span class="cmtt-10">  c], 
</span>
<span class="cmtt-10">  _G481) 
</span>
<span class="cmtt-10">  ? 
</span>
<br class="fancyvrb"/>
<a id="x35-48062r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Call: 
</span>
<span class="cmtt-10">  (8) 
</span>
<span class="cmtt-10">  len([c], 
</span>
<span class="cmtt-10">  _G486) 
</span>
<span class="cmtt-10">  ? 
</span>
<br class="fancyvrb"/>
<a id="x35-48064r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Call: 
</span>
<span class="cmtt-10">  (9) 
</span>
<span class="cmtt-10">  len([], 
</span>
<span class="cmtt-10">  _G489) 
</span>
<span class="cmtt-10">  ? 
</span>
<br class="fancyvrb"/>
<a id="x35-48066r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Exit: 
</span>
<span class="cmtt-10">  (9) 
</span>
<span class="cmtt-10">  len([], 
</span>
<span class="cmtt-10">  0) 
</span>
<span class="cmtt-10">  ? 
</span>
<br class="fancyvrb"/>
<a id="x35-48068r7">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Call: 
</span>
<span class="cmtt-10">  (9) 
</span>
<span class="cmtt-10">  _G486 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  0+1 
</span>
<span class="cmtt-10">  ? 
</span>
<br class="fancyvrb"/>
<a id="x35-48070r8">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Exit: 
</span>
<span class="cmtt-10">  (9) 
</span>
<span class="cmtt-10">  1 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  0+1 
</span>
<span class="cmtt-10">  ? 
</span>
<br class="fancyvrb"/>
<a id="x35-48072r9">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Exit: 
</span>
<span class="cmtt-10">  (8) 
</span>
<span class="cmtt-10">  len([c], 
</span>
<span class="cmtt-10">  1) 
</span>
<span class="cmtt-10">  ? 
</span>
<br class="fancyvrb"/>
<a id="x35-48074r10">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Call: 
</span>
<span class="cmtt-10">  (8) 
</span>
<span class="cmtt-10">  _G481 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  1+1 
</span>
<span class="cmtt-10">  ? 
</span>
<br class="fancyvrb"/>
<a id="x35-48076r11">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Exit: 
</span>
<span class="cmtt-10">  (8) 
</span>
<span class="cmtt-10">  2 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  1+1 
</span>
<span class="cmtt-10">  ? 
</span>
<br class="fancyvrb"/>
<a id="x35-48078r12">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Exit: 
</span>
<span class="cmtt-10">  (7) 
</span>
<span class="cmtt-10">  len([b, 
</span>
<span class="cmtt-10">  c], 
</span>
<span class="cmtt-10">  2) 
</span>
<span class="cmtt-10">  ? 
</span>
<br class="fancyvrb"/>
<a id="x35-48080r13">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Call: 
</span>
<span class="cmtt-10">  (7) 
</span>
<span class="cmtt-10">  _G418 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  2+1 
</span>
<span class="cmtt-10">  ? 
</span>
<br class="fancyvrb"/>
<a id="x35-48082r14">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Exit: 
</span>
<span class="cmtt-10">  (7) 
</span>
<span class="cmtt-10">  3 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  2+1 
</span>
<span class="cmtt-10">  ? 
</span>
<br class="fancyvrb"/>
<a id="x35-48084r15">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Exit: 
</span>
<span class="cmtt-10">  (6) 
</span>
<span class="cmtt-10">  len([a, 
</span>
<span class="cmtt-10">  b, 
</span>
<span class="cmtt-10">  c], 
</span>
<span class="cmtt-10">  3) 
</span>
<span class="cmtt-10">  ? 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse21"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse19"> prev 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse19"> prev-tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse20"> front 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch5"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse22"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse20"> prev 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse20"> prev-tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=#taillpn-htmlse21"> tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch5"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<h3 class="sectionHead">
<span class="titlemark"> 5.4 
</span>
<a id="x36-490005.4">
</a> Comparing Integers 
</h3>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Some Prolog arithmetic predicates actually do carry out arithmetic all by themselves (that is, without the assistance of 
<span class="verb">
<span class="cmtt-10"> is 
</span>
</span> ). These are the operators that compare integers. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="center">
<!--l. 405-->
<p class="noindent">
</p>
<div class="tabular">
<table cellpadding="0" cellspacing="0" class="tabular" id="TBL-2">
<colgroup id="TBL-2-1g">
<col id="TBL-2-1"/>
<col id="TBL-2-2"/>
</colgroup>
<tr id="TBL-2-1-" style="vertical-align:baseline;">
<td class="td11" id="TBL-2-1-1" style="white-space:nowrap; text-align:left;"> Arithmetic examples 
</td>
<td class="td11" id="TBL-2-1-2" style="white-space:nowrap; text-align:left;"> Prolog Notation 
</td>
</tr>
<tr id="TBL-2-2-" style="vertical-align:baseline;">
<td class="td11" id="TBL-2-2-1" style="white-space:nowrap; text-align:left;">
<span class="cmmi-10"> x &lt; y 
</span>
</td>
<td class="td11" id="TBL-2-2-2" style="white-space:nowrap; text-align:left;">
<span class="verb">
<span class="cmtt-10"> X 
</span>
<span class="cmtt-10">  &lt; 
</span>
<span class="cmtt-10">  Y. 
</span>
</span>
</td>
</tr>
<tr id="TBL-2-3-" style="vertical-align:baseline;">
<td class="td11" id="TBL-2-3-1" style="white-space:nowrap; text-align:left;">
<a id="dx36-49001">
</a>
<span class="cmmi-10"> x 
</span>
<span class="cmsy-10"> ≤ 
</span>
<span class="cmmi-10"> y 
</span>
</td>
<td class="td11" id="TBL-2-3-2" style="white-space:nowrap; text-align:left;">
<span class="verb">
<span class="cmtt-10"> X 
</span>
<span class="cmtt-10">  =&lt; 
</span>
<span class="cmtt-10">  Y. 
</span>
</span>
</td>
</tr>
<tr id="TBL-2-4-" style="vertical-align:baseline;">
<td class="td11" id="TBL-2-4-1" style="white-space:nowrap; text-align:left;">
<a id="dx36-49002">
</a>
<span class="cmmi-10"> x 
</span> = 
<span class="cmmi-10"> y 
</span>
</td>
<td class="td11" id="TBL-2-4-2" style="white-space:nowrap; text-align:left;">
<span class="verb">
<span class="cmtt-10"> X 
</span>
<span class="cmtt-10">  =:= 
</span>
<span class="cmtt-10">  Y. 
</span>
</span>
</td>
</tr>
<tr id="TBL-2-5-" style="vertical-align:baseline;">
<td class="td11" id="TBL-2-5-1" style="white-space:nowrap; text-align:left;">
<a id="dx36-49003">
</a>
<span class="cmmi-10"> x 
</span>
<span class="cmsy-10"> ⁄ 
</span> = 
<span class="cmmi-10"> y 
</span>
</td>
<td class="td11" id="TBL-2-5-2" style="white-space:nowrap; text-align:left;">
<span class="verb">
<span class="cmtt-10"> X 
</span>
<span class="cmtt-10">  =\= 
</span>
<span class="cmtt-10">  Y. 
</span>
</span>
</td>
</tr>
<tr id="TBL-2-6-" style="vertical-align:baseline;">
<td class="td11" id="TBL-2-6-1" style="white-space:nowrap; text-align:left;">
<a id="dx36-49004">
</a>
<span class="cmmi-10"> x 
</span>
<span class="cmsy-10"> ≥ 
</span>
<span class="cmmi-10"> y 
</span>
</td>
<td class="td11" id="TBL-2-6-2" style="white-space:nowrap; text-align:left;">
<span class="verb">
<span class="cmtt-10"> X 
</span>
<span class="cmtt-10">  &gt;= 
</span>
<span class="cmtt-10">  Y 
</span>
</span>
</td>
</tr>
<tr id="TBL-2-7-" style="vertical-align:baseline;">
<td class="td11" id="TBL-2-7-1" style="white-space:nowrap; text-align:left;">
<a id="dx36-49005">
</a>
<span class="cmmi-10"> x &gt; y 
</span>
</td>
<td class="td11" id="TBL-2-7-2" style="white-space:nowrap; text-align:left;">
<span class="verb">
<span class="cmtt-10"> X 
</span>
<span class="cmtt-10">  &gt; 
</span>
<span class="cmtt-10">  Y 
</span>
</span>
<a id="dx36-49006">
</a>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> These operators have the obvious meaning: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb256">
<a id="x36-49008r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  2 
</span>
<span class="cmtt-10">  &lt; 
</span>
<span class="cmtt-10">  4. 
</span>
<br class="fancyvrb"/>
<a id="x36-49010r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
<br class="fancyvrb"/>
<a id="x36-49012r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x36-49014r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  2 
</span>
<span class="cmtt-10">  =&lt; 
</span>
<span class="cmtt-10">  4. 
</span>
<br class="fancyvrb"/>
<a id="x36-49016r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
<br class="fancyvrb"/>
<a id="x36-49018r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x36-49020r7">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  4 
</span>
<span class="cmtt-10">  =&lt; 
</span>
<span class="cmtt-10">  4. 
</span>
<br class="fancyvrb"/>
<a id="x36-49022r8">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
<br class="fancyvrb"/>
<a id="x36-49024r9">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x36-49026r10">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  4=:=4. 
</span>
<br class="fancyvrb"/>
<a id="x36-49028r11">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
<br class="fancyvrb"/>
<a id="x36-49030r12">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x36-49032r13">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  4=\=5. 
</span>
<br class="fancyvrb"/>
<a id="x36-49034r14">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
<br class="fancyvrb"/>
<a id="x36-49036r15">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x36-49038r16">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  4=\=4. 
</span>
<br class="fancyvrb"/>
<a id="x36-49040r17">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  no 
</span>
<br class="fancyvrb"/>
<a id="x36-49042r18">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x36-49044r19">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  4 
</span>
<span class="cmtt-10">  &gt;= 
</span>
<span class="cmtt-10">  4. 
</span>
<br class="fancyvrb"/>
<a id="x36-49046r20">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
<br class="fancyvrb"/>
<a id="x36-49048r21">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x36-49050r22">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  4 
</span>
<span class="cmtt-10">  &gt; 
</span>
<span class="cmtt-10">  2. 
</span>
<br class="fancyvrb"/>
<a id="x36-49052r23">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Moreover, they force both their right hand and left hand arguments to be evaluated: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb257">
<a id="x36-49054r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  2 
</span>
<span class="cmtt-10">  &lt; 
</span>
<span class="cmtt-10">  4+1. 
</span>
<br class="fancyvrb"/>
<a id="x36-49056r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
<br class="fancyvrb"/>
<a id="x36-49058r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x36-49060r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  2+1 
</span>
<span class="cmtt-10">  &lt; 
</span>
<span class="cmtt-10">  4. 
</span>
<br class="fancyvrb"/>
<a id="x36-49062r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
<br class="fancyvrb"/>
<a id="x36-49064r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x36-49066r7">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  2+1 
</span>
<span class="cmtt-10">  &lt; 
</span>
<span class="cmtt-10">  3+2. 
</span>
<br class="fancyvrb"/>
<a id="x36-49068r8">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Note that 
<span class="verb">
<span class="cmtt-10"> =:= 
</span>
</span> is different from 
<span class="verb">
<span class="cmtt-10"> = 
</span>
</span> , as the following examples show: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb258">
<a id="x36-49070r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  4=4. 
</span>
<br class="fancyvrb"/>
<a id="x36-49072r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
<br class="fancyvrb"/>
<a id="x36-49074r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x36-49076r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  2+2 
</span>
<span class="cmtt-10">  =4. 
</span>
<br class="fancyvrb"/>
<a id="x36-49078r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  no 
</span>
<br class="fancyvrb"/>
<a id="x36-49080r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x36-49082r7">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  2+2 
</span>
<span class="cmtt-10">  =:= 
</span>
<span class="cmtt-10">  4. 
</span>
<br class="fancyvrb"/>
<a id="x36-49084r8">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> That is, 
<span class="verb">
<span class="cmtt-10"> = 
</span>
</span> tries to unify its arguments; it does 
<span class="cmti-10"> not 
</span> force arithmetic evaluation. That’s 
<span class="verb">
<span class="cmtt-10"> =:= 
</span>
</span> ’s job. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Whenever we use these operators, we have to take care that any variables are instantiated. For example, all the following queries lead to instantiation errors. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb259">
<a id="x36-49086r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  &lt; 
</span>
<span class="cmtt-10">  3. 
</span>
<br class="fancyvrb"/>
<a id="x36-49088r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x36-49090r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  3 
</span>
<span class="cmtt-10">  &lt; 
</span>
<span class="cmtt-10">  Y. 
</span>
<br class="fancyvrb"/>
<a id="x36-49092r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x36-49094r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  =:= 
</span>
<span class="cmtt-10">  X. 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Moreover, variables have to be instantiated to 
<span class="cmti-10"> integers 
</span> . The query 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb260">
<a id="x36-49096r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  3, 
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  &lt; 
</span>
<span class="cmtt-10">  4. 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> succeeds. But the query 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb261">
<a id="x36-49098r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  b, 
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  &lt; 
</span>
<span class="cmtt-10">  4. 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> fails. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Ok, let’s now look at an example which puts Prolog’s abilities to compare numbers to work. We’re going to define a predicate which takes a non-empty list of non-negative integers as its first argument, and returns the maximum integer in the list as its last argument. Again, we’ll use an accumulator. As we work our way down the list, the accumulator will keep track of the highest integer found so far. If we find a higher value, the accumulator will be updated to this new value. When we call the program, we set the accumulator to an initial value of 0. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Here’s the code. Note that there are 
<span class="cmti-10"> two 
</span> recursive clauses: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb262">
<a id="x36-49100r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  accMax([H|T],A,Max) 
</span>
<span class="cmtt-10">  :- 
</span>
<br class="fancyvrb"/>
<a id="x36-49102r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  H 
</span>
<span class="cmtt-10">  &gt; 
</span>
<span class="cmtt-10">  A, 
</span>
<br class="fancyvrb"/>
<a id="x36-49104r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  accMax(T,H,Max). 
</span>
<br class="fancyvrb"/>
<a id="x36-49106r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x36-49108r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  accMax([H|T],A,Max) 
</span>
<span class="cmtt-10">  :- 
</span>
<br class="fancyvrb"/>
<a id="x36-49110r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  H 
</span>
<span class="cmtt-10">  =&lt; 
</span>
<span class="cmtt-10">  A, 
</span>
<br class="fancyvrb"/>
<a id="x36-49112r7">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  accMax(T,A,Max). 
</span>
<br class="fancyvrb"/>
<a id="x36-49114r8">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x36-49116r9">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  accMax([],A,A). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> The first clause tests if the head of the list is larger than the largest value found so far. If it is, we set the accumulator to this new value, and then recursively work through the tail of the list. The second clause applies when the head is less than or equal to the accumulator; in this case we recursively work through the tail of the list using the old accumulator value. Finally, the base clause unifies the second and third arguments; it gives the highest value we found while going through the list to the last argument. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Here’s an example query: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb263">
<a id="x36-49118r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  accMax([1,0,5,4],0,Max). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Here the first clause of 
<span class="verb">
<span class="cmtt-10"> accMax 
</span>
</span> applies, resulting in the following goal: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb264">
<a id="x36-49120r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  accMax([0,5,4],1,Max). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Note the value of the accumulator has changed to 1. Now the second clause of 
<span class="verb">
<span class="cmtt-10"> accMax 
</span>
</span> applies, as 0 (the next element of the list) is smaller than 1, the value of the accumulator. This process is repeated until we reach the empty list: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb265">
<a id="x36-49122r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  accMax([5,4],1,Max). 
</span>
<br class="fancyvrb"/>
<a id="x36-49124r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x36-49126r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  accMax([4],5,Max). 
</span>
<br class="fancyvrb"/>
<a id="x36-49128r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x36-49130r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  accMax([],5,Max). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Now the third clause applies, unifying the variable 
<span class="verb">
<span class="cmtt-10"> Max 
</span>
</span> with the value of the accumulator: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb266">
<a id="x36-49132r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Max 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  5. 
</span>
<br class="fancyvrb"/>
<a id="x36-49134r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Again, it’s nice to define a predicate which calls this, and initialises the accumulator. But wait: what should we initialise the accumulator to? If you say 0, this means you are assuming that all the numbers in the list are positive. But suppose we give a list of negative integers as input. Then we would have 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb267">
<a id="x36-49136r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  accMax([-11,-2,-7,-4,-12],0,Max). 
</span>
<br class="fancyvrb"/>
<a id="x36-49138r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x36-49140r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Max 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  0 
</span>
<br class="fancyvrb"/>
<a id="x36-49142r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> This is 
<span class="cmti-10"> not 
</span> what we want: the biggest number on the list is -2. Our use of 0 as the initial value of the accumulator has ruined everything, because it’s bigger than any number on the list. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> There’s an easy way around this: since our input list will always be a non-empty list of integers, simply initialise the accumulator to the head of the list. That way we guarantee that the accumulator is initialised to a number on the list. The following predicate does this for us: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb268">
<a id="x36-49144r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  max(List,Max) 
</span>
<span class="cmtt-10">  :- 
</span>
<br class="fancyvrb"/>
<a id="x36-49146r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  List 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [H|_], 
</span>
<br class="fancyvrb"/>
<a id="x36-49148r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  accMax(List,H,Max). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> So we can simply say: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb269">
<a id="x36-49150r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  max([1,2,46,53,0],X). 
</span>
<br class="fancyvrb"/>
<a id="x36-49152r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x36-49154r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  53 
</span>
<br class="fancyvrb"/>
<a id="x36-49156r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> And furthermore we have: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb270">
<a id="x36-49158r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  max([-11,-2,-7,-4,-12],X). 
</span>
<br class="fancyvrb"/>
<a id="x36-49160r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x36-49162r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  -2 
</span>
<br class="fancyvrb"/>
<a id="x36-49164r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse22"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse20"> prev 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse20"> prev-tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse21"> front 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch5"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse23"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse21"> prev 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse21"> prev-tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=#taillpn-htmlse22"> tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch5"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<h3 class="sectionHead">
<span class="titlemark"> 5.5 
</span>
<a id="x37-500005.5">
</a> <strong>Exercise</strong>s 
</h3>
</div>
<div class="nb-cell html" name="htm1">
<div class="newtheorem">
<!--l. 596-->
<p class="noindent">
<span class="head">
<span class="cmbx-10"> <strong>Exercise</strong>
</span>
<span class="cmbx-10">  5.1 
</span>
</span>
<a id="x37-500011">
</a>
<span class="cmti-10"> How does Prolog respond to the following queries? 
</span>
</p>
<ol class="enumerate1">
<li class="enumerate" id="x37-50003x1">
<span class="verb">
<span class="cmtt-10"> X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  3*4. 
</span>
</span>
</li>
<li class="enumerate" id="x37-50005x2">
<span class="verb">
<span class="cmtt-10"> X 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  3*4. 
</span>
</span>
</li>
<li class="enumerate" id="x37-50007x3">
<span class="verb">
<span class="cmtt-10"> 4 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  X. 
</span>
</span>
</li>
<li class="enumerate" id="x37-50009x4">
<span class="verb">
<span class="cmtt-10"> X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  Y. 
</span>
</span>
</li>
<li class="enumerate" id="x37-50011x5">
<span class="verb">
<span class="cmtt-10"> 3 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  1+2. 
</span>
</span>
</li>
<li class="enumerate" id="x37-50013x6">
<span class="verb">
<span class="cmtt-10"> 3 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  +(1,2). 
</span>
</span>
</li>
<li class="enumerate" id="x37-50015x7">
<span class="verb">
<span class="cmtt-10"> 3 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  X+2. 
</span>
</span>
</li>
<li class="enumerate" id="x37-50017x8">
<span class="verb">
<span class="cmtt-10"> X 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  1+2. 
</span>
</span>
</li>
<li class="enumerate" id="x37-50019x9">
<span class="verb">
<span class="cmtt-10"> 1+2 
</span>
<span class="cmtt-10">  is 
</span>
<span class="cmtt-10">  1+2. 
</span>
</span>
</li>
<li class="enumerate" id="x37-50021x10">
<span class="verb">
<span class="cmtt-10"> is(X,+(1,2)). 
</span>
</span>
</li>
<li class="enumerate" id="x37-50023x11">
<span class="verb">
<span class="cmtt-10"> 3+2 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  +(3,2). 
</span>
</span>
</li>
<li class="enumerate" id="x37-50025x12">
<span class="verb">
<span class="cmtt-10"> *(7,5) 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  7*5. 
</span>
</span>
</li>
<li class="enumerate" id="x37-50027x13">
<span class="verb">
<span class="cmtt-10"> *(7,+(3,2)) 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  7*(3+2). 
</span>
</span>
</li>
<li class="enumerate" id="x37-50029x14">
<span class="verb">
<span class="cmtt-10"> *(7,(3+2)) 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  7*(3+2). 
</span>
</span>
</li>
<li class="enumerate" id="x37-50031x15">
<span class="verb">
<span class="cmtt-10"> 7*3+2 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  *(7,+(3,2)). 
</span>
</span>
</li>
<li class="enumerate" id="x37-50033x16">
<span class="verb">
<span class="cmtt-10"> *(7,(3+2)) 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  7*(+(3,2)). 
</span>
</span>
</li>
</ol>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="newtheorem">
<!--l. 616-->
<p class="noindent">
<span class="head">
<span class="cmbx-10"> <strong>Exercise</strong>
</span>
<span class="cmbx-10">  5.2 
</span>
</span>
<a id="x37-500342">
</a>
</p>
<ol class="enumerate1">
<li class="enumerate" id="x37-50036x1">
<span class="cmti-10"> Define a 2-place predicate 
</span>
<span class="verb">
<span class="cmtt-10"> increment 
</span>
</span>
<span class="cmti-10"> that holds only when its second 
</span>
<span class="cmti-10"> argument is an integer one larger than its first argument. For example, 
</span>
<span class="verb">
<span class="cmtt-10"> increment(4,5) 
</span>
</span>
<span class="cmti-10"> should hold, but 
</span>
<span class="verb">
<span class="cmtt-10"> increment(4,6) 
</span>
</span>
<span class="cmti-10"> should not. 
</span>
</li>
<li class="enumerate" id="x37-50038x2">
<span class="cmti-10"> Define a 3-place predicate 
</span>
<span class="verb">
<span class="cmtt-10"> sum 
</span>
</span>
<span class="cmti-10"> that holds only when its third argument is 
</span>
<span class="cmti-10"> the sum of the first two arguments. For example, 
</span>
<span class="verb">
<span class="cmtt-10"> sum(4,5,9) 
</span>
</span>
<span class="cmti-10"> should hold, 
</span>
<span class="cmti-10"> but 
</span>
<span class="verb">
<span class="cmtt-10"> sum(4,6,12) 
</span>
</span>
<span class="cmti-10"> should not. 
</span>
</li>
</ol>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="newtheorem">
<!--l. 629-->
<p class="noindent">
<span class="head">
<span class="cmbx-10"> <strong>Exercise</strong>
</span>
<span class="cmbx-10">  5.3 
</span>
</span>
<a id="x37-500393">
</a>
<span class="cmti-10"> Write a predicate 
</span>
<span class="verb">
<span class="cmtt-10"> addone/2 
</span>
</span>
<span class="cmti-10"> whose first argument is a list of integers, 
</span>
<span class="cmti-10"> and whose second argument is the list of integers obtained by adding 1 to each integer 
</span>
<span class="cmti-10"> in the first list. For example, the query 
</span>
</p>
<div class="fancyvrb" id="fancyvrb271">
<a id="x37-50041r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  addone([1,2,7,2],X). 
</span>
</div>
<!--l. 636-->
<p class="noindent">
<span class="cmti-10"> should give 
</span>
</p>
<div class="fancyvrb" id="fancyvrb272">
<a id="x37-50043r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [2,3,8,3]. 
</span>
</div>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse23"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse21"> prev 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse21"> prev-tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse22"> front 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch5"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse22"> prev 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse22"> prev-tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=#taillpn-htmlse23"> tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch5"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<h3 class="sectionHead">
<span class="titlemark"> 5.6 
</span>
<a id="x38-510005.6">
</a> Practical Session 
</h3>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> The purpose of Practical Session 5 is to help you get familiar with Prolog’s arithmetic capabilities, and to give you some further practice in list manipulation. To this end, we suggest the following programming exercises: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<ol class="enumerate1">
<li class="enumerate" id="x38-51002x1"> In the text we discussed the 3-place predicate 
<span class="verb">
<span class="cmtt-10"> accMax 
</span>
</span> which returned the maximum of a list of integers. By changing the code slightly, turn this into a 3-place predicate 
<span class="verb">
<span class="cmtt-10"> accMin 
</span>
</span> which returns the 
<span class="cmti-10"> minimum 
</span> of a list of integers. 
</li>
<li class="enumerate" id="x38-51004x2"> In mathematics, an n-dimensional vector is a list of numbers of length n. For example, 
<span class="verb">
<span class="cmtt-10"> [2,5,12] 
</span>
</span> is a 3-dimensional vector, and 
<span class="verb">
<span class="cmtt-10"> [45,27,3,-4,6] 
</span>
</span> is a 5-dimensional vector. One of the basic operations on vectors is 
<span class="cmti-10"> scalar 
</span>
<span class="cmti-10"> multiplication 
</span> . In this operation, every element of a vector is multiplied by some number. For example, if we scalar multiply the 3-dimensional vector 
<span class="verb">
<span class="cmtt-10"> [2,7,4] 
</span>
</span> by 
<span class="verb">
<span class="cmtt-10"> 3 
</span>
</span> the result is the 3-dimensional vector 
<span class="verb">
<span class="cmtt-10"> [6,21,12] 
</span>
</span> . 
<!--l. 667-->
<p class="noindent"> Write a 3-place predicate 
<span class="verb">
<span class="cmtt-10"> scalarMult 
</span>
</span> whose first argument is an integer, whose second argument is a list of integers, and whose third argument is the result of scalar multiplying the second argument by the first. For example, the query 
</p>
<div class="fancyvrb" id="fancyvrb273">
<a id="x38-51006r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  scalarMult(3,[2,7,4],Result). 
</span>
</div>
<!--l. 675-->
<p class="noindent"> should yield 
</p>
<div class="fancyvrb" id="fancyvrb274">
<a id="x38-51008r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Result 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [6,21,12] 
</span>
</div>
</li>
<li class="enumerate" id="x38-51010x3"> Another fundamental operation on vectors is the 
<span class="cmti-10"> dot product 
</span> . This operation combines two vectors of the same dimension and yields a number as a result. The operation is carried out as follows: the corresponding elements of the two vectors are multiplied, and the results added. For example, the dot product of 
<span class="verb">
<span class="cmtt-10"> [2,5,6] 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> [3,4,1] 
</span>
</span> is 
<span class="verb">
<span class="cmtt-10"> 6+20+6 
</span>
</span> , that is, 
<span class="verb">
<span class="cmtt-10"> 32 
</span>
</span> . Write a 3-place predicate 
<span class="verb">
<span class="cmtt-10"> dot 
</span>
</span> whose first argument is a list of integers, whose second argument is a list of integers of the same length as the first, and whose third argument is the dot product of the first argument with the second. For example, the query 
<div class="fancyvrb" id="fancyvrb275">
<a id="x38-51012r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  dot([2,5,6],[3,4,1],Result). 
</span>
</div>
<!--l. 694-->
<p class="noindent"> should yield 
</p>
<div class="fancyvrb" id="fancyvrb276">
<a id="x38-51014r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Result 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  32 
</span>
</div>
</li>
</ol>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse22"> prev 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse22"> prev-tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse23"> front 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch5"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse25"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=#taillpn-htmlse24"> tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch6"> up 
</a> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<h3 class="sectionHead">
<span class="titlemark"> 6.1 
</span>
<a id="x40-530006.1">
</a> Append 
</h3>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> We shall define an important predicate 
<span class="verb">
<span class="cmtt-10"> append/3 
</span>
</span> whose arguments are all lists. Viewed declaratively, 
<span class="verb">
<span class="cmtt-10"> append(L1,L2,L3) 
</span>
</span> will 
<a id="dx40-53001">
</a> hold when the list 
<span class="verb">
<span class="cmtt-10"> L3 
</span>
</span> is the result of concatenating the lists 
<span class="verb">
<span class="cmtt-10"> L1 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> L2 
</span>
</span> together (concatenating means joining the lists together, end to end). For example, if we pose the query 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb277">
<a id="x40-53003r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  append([a,b,c],[1,2,3],[a,b,c,1,2,3]). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> or the query 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb278">
<a id="x40-53005r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  append([a,[foo,gibble],c],[1,2,[[],b]], 
</span>
<br class="fancyvrb"/>
<a id="x40-53007r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  [a,[foo,gibble],c,1,2,[[],b]). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> we will get the response yes. On the other hand, if we pose the query 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb279">
<a id="x40-53009r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  append([a,b,c],[1,2,3],[a,b,c,1,2]). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> or the query 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb280">
<a id="x40-53011r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  append([a,b,c],[1,2,3],[1,2,3,a,b,c]). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> we will get the answer no. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> From a procedural perspective, the most obvious use of 
<span class="verb">
<span class="cmtt-10"> append/3 
</span>
</span> is to concatenate two lists together. We can do this simply by using a variable as the third argument: the query 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb281">
<a id="x40-53013r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  append([a,b,c],[1,2,3],L3). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> yields the response 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb282">
<a id="x40-53015r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  L3 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [a,b,c,1,2,3] 
</span>
<br class="fancyvrb"/>
<a id="x40-53017r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> But (as we shall soon see) we can also use 
<span class="verb">
<span class="cmtt-10"> append/3 
</span>
</span> to split up a list. In fact, 
<span class="verb">
<span class="cmtt-10"> append/3 
</span>
</span> is a real workhorse. There’s lots we can do with it, and studying it is a good way to gain a better understanding of list processing in Prolog. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent">
</p>
</div>
<div class="nb-cell html" name="htm1">
<h4 class="likesubsectionHead">
<a id="x40-540006.1">
</a> Defining append 
</h4>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Here’s how 
<span class="verb">
<span class="cmtt-10"> append/3 
</span>
</span> is defined: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb283">
<a id="x40-54002r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  append([],L,L). 
</span>
<br class="fancyvrb"/>
<a id="x40-54004r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  append([H|T],L2,[H|L3]) 
</span>
<span class="cmtt-10">  :- 
</span>
<span class="cmtt-10">  append(T,L2,L3). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> This is a recursive definition. The base case simply says that appending the empty list to any list whatsoever yields that same list, which is obviously true. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> But what about the recursive step? This says that when we concatenate a non-empty list 
<span class="verb">
<span class="cmtt-10"> [H|T] 
</span>
</span> with a list 
<span class="verb">
<span class="cmtt-10"> L2 
</span>
</span> , we end up with the list whose head is 
<span class="verb">
<span class="cmtt-10"> H 
</span>
</span> and whose tail is the result of concatenating 
<span class="verb">
<span class="cmtt-10"> T 
</span>
</span> with 
<span class="verb">
<span class="cmtt-10"> L2 
</span>
</span> . It may be useful to think about this definition pictorially: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="quote">
<!--l. 92-->
<p class="noindent"> Input: [ H 
<span class="cmsy-10"> ∣ 
</span>
<span class="fbox">  T   
</span> ] + 
<span class="fbox">  L2   
</span>
<br class="newline"/> Result: [ H 
<span class="cmsy-10"> ∣ 
</span>
<img alt="|----| ◟L ◝3◜-◞-" src="html/lpn-html0x.png"/>
<sub>
<span class="fbox"> T 
</span>
<span class="cmr-7"> + 
</span>
<span class="fbox"> L2 
</span>
</sub> ] 
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> But what is the procedural meaning of this definition? What actually goes on when we use 
<span class="verb">
<span class="cmtt-10"> append/3 
</span>
</span> to glue two lists together? Let’s take a detailed look at what happens when we pose the query 
<span class="verb">
<span class="cmtt-10"> ?- 
</span>
<span class="cmtt-10">  append([a,b,c],[1,2,3],X) 
</span>
</span> . 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> When we pose this query, Prolog will match it to the head of the recursive rule, generating a new internal variable (say 
<span class="verb">
<span class="cmtt-10"> _G518 
</span>
</span> ) in the process. If we carried out a trace of what happens next, we would get something like the following: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb284">
<a id="x40-54006r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  append([a, 
</span>
<span class="cmtt-10">  b, 
</span>
<span class="cmtt-10">  c], 
</span>
<span class="cmtt-10">  [1, 
</span>
<span class="cmtt-10">  2, 
</span>
<span class="cmtt-10">  3], 
</span>
<span class="cmtt-10">  _G518) 
</span>
<br class="fancyvrb"/>
<a id="x40-54008r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  append([b, 
</span>
<span class="cmtt-10">  c], 
</span>
<span class="cmtt-10">  [1, 
</span>
<span class="cmtt-10">  2, 
</span>
<span class="cmtt-10">  3], 
</span>
<span class="cmtt-10">  _G587) 
</span>
<br class="fancyvrb"/>
<a id="x40-54010r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  append([c], 
</span>
<span class="cmtt-10">  [1, 
</span>
<span class="cmtt-10">  2, 
</span>
<span class="cmtt-10">  3], 
</span>
<span class="cmtt-10">  _G590) 
</span>
<br class="fancyvrb"/>
<a id="x40-54012r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  append([], 
</span>
<span class="cmtt-10">  [1, 
</span>
<span class="cmtt-10">  2, 
</span>
<span class="cmtt-10">  3], 
</span>
<span class="cmtt-10">  _G593) 
</span>
<br class="fancyvrb"/>
<a id="x40-54014r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  append([], 
</span>
<span class="cmtt-10">  [1, 
</span>
<span class="cmtt-10">  2, 
</span>
<span class="cmtt-10">  3], 
</span>
<span class="cmtt-10">  [1, 
</span>
<span class="cmtt-10">  2, 
</span>
<span class="cmtt-10">  3]) 
</span>
<br class="fancyvrb"/>
<a id="x40-54016r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  append([c], 
</span>
<span class="cmtt-10">  [1, 
</span>
<span class="cmtt-10">  2, 
</span>
<span class="cmtt-10">  3], 
</span>
<span class="cmtt-10">  [c, 
</span>
<span class="cmtt-10">  1, 
</span>
<span class="cmtt-10">  2, 
</span>
<span class="cmtt-10">  3]) 
</span>
<br class="fancyvrb"/>
<a id="x40-54018r7">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  append([b, 
</span>
<span class="cmtt-10">  c], 
</span>
<span class="cmtt-10">  [1, 
</span>
<span class="cmtt-10">  2, 
</span>
<span class="cmtt-10">  3], 
</span>
<span class="cmtt-10">  [b, 
</span>
<span class="cmtt-10">  c, 
</span>
<span class="cmtt-10">  1, 
</span>
<span class="cmtt-10">  2, 
</span>
<span class="cmtt-10">  3]) 
</span>
<br class="fancyvrb"/>
<a id="x40-54020r8">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  append([a, 
</span>
<span class="cmtt-10">  b, 
</span>
<span class="cmtt-10">  c], 
</span>
<span class="cmtt-10">  [1, 
</span>
<span class="cmtt-10">  2, 
</span>
<span class="cmtt-10">  3], 
</span>
<span class="cmtt-10">  [a, 
</span>
<span class="cmtt-10">  b, 
</span>
<span class="cmtt-10">  c, 
</span>
<span class="cmtt-10">  1, 
</span>
<span class="cmtt-10">  2, 
</span>
<span class="cmtt-10">  3]) 
</span>
<br class="fancyvrb"/>
<a id="x40-54022r9">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x40-54024r10">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [a, 
</span>
<span class="cmtt-10">  b, 
</span>
<span class="cmtt-10">  c, 
</span>
<span class="cmtt-10">  1, 
</span>
<span class="cmtt-10">  2, 
</span>
<span class="cmtt-10">  3] 
</span>
<br class="fancyvrb"/>
<a id="x40-54026r11">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  yes 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> The basic pattern should be clear: in the first four lines we see that Prolog recurses its way down the list in its first argument until it can apply the base case of the recursive definition. Then, as the next four lines show, it then stepwise ‘fills in’ the result. How is this ‘filling in’ process carried out? By successively instantiating the variables 
<span class="verb">
<span class="cmtt-10"> _G593 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> _G590 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> _G587 
</span>
</span> , and 
<span class="verb">
<span class="cmtt-10"> _G518 
</span>
</span> . But while it’s important to grasp this basic pattern, it doesn’t tell us all we need to know about the way 
<span class="verb">
<span class="cmtt-10"> append/3 
</span>
</span> works, so let’s dig deeper. Here is the search tree for the query 
<span class="verb">
<span class="cmtt-10"> append([a,b,c],[1,2,3],X) 
</span>
</span> . We’ll work carefully through all the steps, making a careful note of what our goals are, and what the variables are instantiated to. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="center">
<!--l. 140-->
<p class="noindent">
</p>
<!--l. 141-->
<p class="noindent">
<img alt="*Pic not found*" src="html/chap6-pspic1.ps.png"/>
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<ol class="enumerate1">
<li class="enumerate" id="x40-54028x1"> Goal 1: 
<span class="verb">
<span class="cmtt-10"> append([a,b,c],[1,2,3],_G518) 
</span>
</span> . Prolog matches this to the head of the recursive rule (that is, 
<span class="verb">
<span class="cmtt-10"> append([H|T],L2,[H|L3]) 
</span>
</span> ). Thus 
<span class="verb">
<span class="cmtt-10"> _G518 
</span>
</span> is unified to 
<span class="verb">
<span class="cmtt-10"> [a|L3] 
</span>
</span> , and Prolog has the new goal 
<span class="verb">
<span class="cmtt-10"> append([b,c],[1,2,3],L3) 
</span>
</span> . It generates a new variable 
<span class="verb">
<span class="cmtt-10"> _G587 
</span>
</span> for 
<span class="verb">
<span class="cmtt-10"> L3 
</span>
</span> , thus we have that 
<span class="verb">
<span class="cmtt-10"> _G518 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [a|_G587] 
</span>
</span> . 
</li>
<li class="enumerate" id="x40-54030x2"> Goal 2: 
<span class="verb">
<span class="cmtt-10"> append([b,c],[1,2,3],_G587) 
</span>
</span> . Prolog matches this to the head of the recursive rule, thus 
<span class="verb">
<span class="cmtt-10"> _G587 
</span>
</span> is unified to 
<span class="verb">
<span class="cmtt-10"> [b|L3] 
</span>
</span> , and Prolog has the new goal 
<span class="verb">
<span class="cmtt-10"> append([c],[1,2,3],L3) 
</span>
</span> . It generates the internal variable 
<span class="verb">
<span class="cmtt-10"> _G590 
</span>
</span> for 
<span class="verb">
<span class="cmtt-10"> L3 
</span>
</span> , thus we have that 
<span class="verb">
<span class="cmtt-10"> _G587 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [b|_G590] 
</span>
</span> . 
</li>
<li class="enumerate" id="x40-54032x3"> Goal 3: 
<span class="verb">
<span class="cmtt-10"> append([c],[1,2,3],_G590 
</span>
</span> ). Prolog matches this to the head of the recursive rule, thus 
<span class="verb">
<span class="cmtt-10"> _G590 
</span>
</span> is unified to 
<span class="verb">
<span class="cmtt-10"> [c|L3] 
</span>
</span> , and Prolog has the new goal 
<span class="verb">
<span class="cmtt-10"> append([],[1,2,3],L3) 
</span>
</span> . It generates the internal variable 
<span class="verb">
<span class="cmtt-10"> _G593 
</span>
</span> for 
<span class="verb">
<span class="cmtt-10"> L3 
</span>
</span> , thus we have that 
<span class="verb">
<span class="cmtt-10"> _G590 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [c|_G593] 
</span>
</span> . 
</li>
<li class="enumerate" id="x40-54034x4"> Goal 4: 
<span class="verb">
<span class="cmtt-10"> append([],[1,2,3],_G593 
</span>
</span> ). At last: Prolog can use the base clause (that is, 
<span class="verb">
<span class="cmtt-10"> append([],L,L) 
</span>
</span> ). And in the four successive matching steps, Prolog will obtain answers to Goal 4, Goal 3, Goal 2, and Goal 1. Here’s how. 
</li>
<li class="enumerate" id="x40-54036x5"> Answer to Goal 4: 
<span class="verb">
<span class="cmtt-10"> append([],[1,2,3],[1,2,3]) 
</span>
</span> . This is because when we match Goal 4 (that is, 
<span class="verb">
<span class="cmtt-10"> append([],[1,2,3],_G593) 
</span>
</span> to the base clause, 
<span class="verb">
<span class="cmtt-10"> _G593 
</span>
</span> is unified to 
<span class="verb">
<span class="cmtt-10"> [1,2,3] 
</span>
</span> . 
</li>
<li class="enumerate" id="x40-54038x6"> Answer to Goal 3: 
<span class="verb">
<span class="cmtt-10"> append([c],[1,2,3],[c,1,2,3]) 
</span>
</span> . Why? Because Goal 3 is 
<span class="verb">
<span class="cmtt-10"> append([c],[1,2,3],_G590]) 
</span>
</span> , and 
<span class="verb">
<span class="cmtt-10"> _G590 
</span>
</span> is the list 
<span class="verb">
<span class="cmtt-10"> [c|_G593] 
</span>
</span> , and we have just unified 
<span class="verb">
<span class="cmtt-10"> _G593 
</span>
</span> to 
<span class="verb">
<span class="cmtt-10"> [1,2,3] 
</span>
</span> . So 
<span class="verb">
<span class="cmtt-10"> _G590 
</span>
</span> is unified to 
<span class="verb">
<span class="cmtt-10"> [c,1,2,3] 
</span>
</span> . 
</li>
<li class="enumerate" id="x40-54040x7"> Answer to Goal 2: 
<span class="verb">
<span class="cmtt-10"> append([b,c],[1,2,3],[b,c,1,2,3]) 
</span>
</span> . Why? Because Goal 2 is 
<span class="verb">
<span class="cmtt-10"> append([b,c],[1,2,3],_G587]) 
</span>
</span> , and 
<span class="verb">
<span class="cmtt-10"> _G587 
</span>
</span> is the list 
<span class="verb">
<span class="cmtt-10"> [b|_G590] 
</span>
</span> , and we have just unified 
<span class="verb">
<span class="cmtt-10"> _G590 
</span>
</span> to 
<span class="verb">
<span class="cmtt-10"> [c,1,2,3] 
</span>
</span> . So 
<span class="verb">
<span class="cmtt-10"> _G587 
</span>
</span> is unified to 
<span class="verb">
<span class="cmtt-10"> [b,c,1,2,3] 
</span>
</span> . 
</li>
<li class="enumerate" id="x40-54042x8"> Answer to Goal 1: 
<span class="verb">
<span class="cmtt-10"> append([a,b,c],[1,2,3],[b,c,1,2,3]) 
</span>
</span> . Why? Because Goal 2 is 
<span class="verb">
<span class="cmtt-10"> append([a,b,c],[1,2,3],_G518]) 
</span>
</span> , and 
<span class="verb">
<span class="cmtt-10"> _G518 
</span>
</span> is the list 
<span class="verb">
<span class="cmtt-10"> [a|_G587] 
</span>
</span> , and we have just unified 
<span class="verb">
<span class="cmtt-10"> _G587 
</span>
</span> to 
<span class="verb">
<span class="cmtt-10"> [b,c,1,2,3] 
</span>
</span> . So 
<span class="verb">
<span class="cmtt-10"> _G518 
</span>
</span> is unified to 
<span class="verb">
<span class="cmtt-10"> [a,b,c,1,2,3] 
</span>
</span> . 
</li>
<li class="enumerate" id="x40-54044x9"> Thus Prolog now knows how to instantiate 
<span class="verb">
<span class="cmtt-10"> X 
</span>
</span> , the original query variable. It tells us that 
<span class="verb">
<span class="cmtt-10"> X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [a,b,c,1,2,3] 
</span>
</span> , which is what we want. 
</li>
</ol>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Work through this example carefully, and make sure you fully understand the pattern of variable instantiations, namely: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb285">
<a id="x40-54046r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  _G518 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [a|_G587] 
</span>
<br class="fancyvrb"/>
<a id="x40-54048r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [a|[b|_G590]] 
</span>
<br class="fancyvrb"/>
<a id="x40-54050r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [a|[b|[c|_G593]]] 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> This type of pattern lies at the heart of the way 
<span class="verb">
<span class="cmtt-10"> append/3 
</span>
</span> works. Moreover, it illustrates a more general theme: the use of unification to build structure. In a nutshell, the recursive calls to 
<span class="verb">
<span class="cmtt-10"> append/3 
</span>
</span> build up this nested pattern of variables which code up the required answer. When Prolog finally instantiates the innermost variable 
<span class="verb">
<span class="cmtt-10"> _G593 
</span>
</span> to 
<span class="verb">
<span class="cmtt-10"> [1, 
</span>
<span class="cmtt-10">  2, 
</span>
<span class="cmtt-10">  3] 
</span>
</span> , the answer crystallises out, like a snowflake forming around a grain of dust. But it is unification, not magic, that produces the result. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent">
</p>
</div>
<div class="nb-cell html" name="htm1">
<h4 class="likesubsectionHead">
<a id="x40-550006.1">
</a> Using append 
</h4>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> Now that we understand how 
<span class="verb">
<span class="cmtt-10"> append/3 
</span>
</span> works, let’s see how we can put it to work. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> One important use of 
<span class="verb">
<span class="cmtt-10"> append/3 
</span>
</span> is to split up a list into two consecutive lists. For example: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb286">
<a id="x40-55002r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  append(X,Y,[a,b,c,d]). 
</span>
<br class="fancyvrb"/>
<a id="x40-55004r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x40-55006r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [] 
</span>
<br class="fancyvrb"/>
<a id="x40-55008r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Y 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [a,b,c,d] 
</span>
<span class="cmtt-10">  ; 
</span>
<br class="fancyvrb"/>
<a id="x40-55010r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x40-55012r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [a] 
</span>
<br class="fancyvrb"/>
<a id="x40-55014r7">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Y 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [b,c,d] 
</span>
<span class="cmtt-10">  ; 
</span>
<br class="fancyvrb"/>
<a id="x40-55016r8">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x40-55018r9">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [a,b] 
</span>
<br class="fancyvrb"/>
<a id="x40-55020r10">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Y 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [c,d] 
</span>
<span class="cmtt-10">  ; 
</span>
<br class="fancyvrb"/>
<a id="x40-55022r11">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x40-55024r12">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [a,b,c] 
</span>
<br class="fancyvrb"/>
<a id="x40-55026r13">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Y 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [d] 
</span>
<span class="cmtt-10">  ; 
</span>
<br class="fancyvrb"/>
<a id="x40-55028r14">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x40-55030r15">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [a,b,c,d] 
</span>
<br class="fancyvrb"/>
<a id="x40-55032r16">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  Y 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [] 
</span>
<span class="cmtt-10">  ; 
</span>
<br class="fancyvrb"/>
<a id="x40-55034r17">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x40-55036r18">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  no 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> That is, we give the list we want to split up (here 
<span class="verb">
<span class="cmtt-10"> [a,b,c,d] 
</span>
</span> ) to 
<span class="verb">
<span class="cmtt-10"> append/3 
</span>
</span> as the third argument, and we use variables for the first two arguments. Prolog then searches for ways of instantiating the variables to two lists that concatenate to give the third argument, thus splitting up the list in two. Moreover, as this example shows, by backtracking, Prolog can find all possible ways of splitting up a list into two consecutive lists. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> This ability means it is easy to define some useful predicates with 
<span class="verb">
<span class="cmtt-10"> append/3 
</span>
</span> . Let’s consider some examples. First, we can define a program which finds prefixes of lists. For example, the prefixes of 
<span class="verb">
<span class="cmtt-10"> [a,b,c,d] 
</span>
</span> are 
<span class="verb">
<span class="cmtt-10"> [] 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> [a] 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> [a,b] 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> [a,b,c] 
</span>
</span> , and 
<span class="verb">
<span class="cmtt-10"> [a,b,c,d] 
</span>
</span> . With the help of 
<span class="verb">
<span class="cmtt-10"> append/3 
</span>
</span> it is straightforward to define a program 
<span class="verb">
<span class="cmtt-10"> prefix/2 
</span>
</span> , whose arguments are both lists, such that 
<span class="verb">
<span class="cmtt-10"> prefix(P,L) 
</span>
</span> will hold when 
<span class="verb">
<span class="cmtt-10"> P 
</span>
</span> is a prefix of 
<span class="verb">
<span class="cmtt-10"> L 
</span>
</span> . Here’s how: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb287">
<a id="x40-55038r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  prefix(P,L):- 
</span>
<span class="cmtt-10">  append(P,_,L). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> This says that list 
<span class="verb">
<span class="cmtt-10"> P 
</span>
</span> is a prefix of list 
<span class="verb">
<span class="cmtt-10"> L 
</span>
</span> when there is some list such that 
<span class="verb">
<span class="cmtt-10"> L 
</span>
</span> is the result of concatenating 
<span class="verb">
<span class="cmtt-10"> P 
</span>
</span> with that list. (We use the anonymous variable since we don’t care what that other list is: we only care that there is some such list or other.) This predicate successfully finds prefixes of lists, and moreover, via backtracking, finds them all: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb288">
<a id="x40-55040r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  prefix(X,[a,b,c,d]). 
</span>
<br class="fancyvrb"/>
<a id="x40-55042r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x40-55044r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [] 
</span>
<span class="cmtt-10">  ; 
</span>
<br class="fancyvrb"/>
<a id="x40-55046r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x40-55048r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [a] 
</span>
<span class="cmtt-10">  ; 
</span>
<br class="fancyvrb"/>
<a id="x40-55050r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x40-55052r7">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [a,b] 
</span>
<span class="cmtt-10">  ; 
</span>
<br class="fancyvrb"/>
<a id="x40-55054r8">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x40-55056r9">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [a,b,c] 
</span>
<span class="cmtt-10">  ; 
</span>
<br class="fancyvrb"/>
<a id="x40-55058r10">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x40-55060r11">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [a,b,c,d] 
</span>
<span class="cmtt-10">  ; 
</span>
<br class="fancyvrb"/>
<a id="x40-55062r12">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x40-55064r13">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  no 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> In a similar fashion, we can define a program which finds suffixes of lists. For example, the suffixes of 
<span class="verb">
<span class="cmtt-10"> [a,b,c,d] 
</span>
</span> are 
<span class="verb">
<span class="cmtt-10"> [] 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> [d] 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> [c,d] 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> [b,c,d] 
</span>
</span> , and 
<span class="verb">
<span class="cmtt-10"> [a,b,c,d] 
</span>
</span> . Again, using 
<span class="verb">
<span class="cmtt-10"> append/3 
</span>
</span> it is easy to define 
<span class="verb">
<span class="cmtt-10"> suffix/2 
</span>
</span> , a predicate whose arguments are both lists, such that 
<span class="verb">
<span class="cmtt-10"> suffix(S,L) 
</span>
</span> will hold when 
<span class="verb">
<span class="cmtt-10"> S 
</span>
</span> is a suffix of 
<span class="verb">
<span class="cmtt-10"> L 
</span>
</span> : 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb289">
<a id="x40-55066r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  suffix(S,L):- 
</span>
<span class="cmtt-10">  append(_,S,L). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> That is, list 
<span class="verb">
<span class="cmtt-10"> S 
</span>
</span> is a suffix of list 
<span class="verb">
<span class="cmtt-10"> L 
</span>
</span> if there is some list such that 
<span class="verb">
<span class="cmtt-10"> L 
</span>
</span> is the result of concatenating that list with 
<span class="verb">
<span class="cmtt-10"> S 
</span>
</span> . This predicate successfully finds suffixes of lists, and moreover, via backtracking, finds them all: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb290">
<a id="x40-55068r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  ?- 
</span>
<span class="cmtt-10">  suffix(X,[a,b,c,d]). 
</span>
<br class="fancyvrb"/>
<a id="x40-55070r2">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x40-55072r3">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [a,b,c,d] 
</span>
<span class="cmtt-10">  ; 
</span>
<br class="fancyvrb"/>
<a id="x40-55074r4">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x40-55076r5">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [b,c,d] 
</span>
<span class="cmtt-10">  ; 
</span>
<br class="fancyvrb"/>
<a id="x40-55078r6">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x40-55080r7">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [c,d] 
</span>
<span class="cmtt-10">  ; 
</span>
<br class="fancyvrb"/>
<a id="x40-55082r8">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x40-55084r9">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [d] 
</span>
<span class="cmtt-10">  ; 
</span>
<br class="fancyvrb"/>
<a id="x40-55086r10">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x40-55088r11">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  X 
</span>
<span class="cmtt-10">  = 
</span>
<span class="cmtt-10">  [] 
</span>
<span class="cmtt-10">  ; 
</span>
<br class="fancyvrb"/>
<a id="x40-55090r12">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">   
</span>
<br class="fancyvrb"/>
<a id="x40-55092r13">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  no 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> Make sure you understand why the results come out in this order. 
</p>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> And now it’s very easy to define a program that finds sublists of lists. The sublists of 
<span class="verb">
<span class="cmtt-10"> [a,b,c,d] 
</span>
</span> are 
<span class="verb">
<span class="cmtt-10"> [] 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> [a] 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> [b] 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> [c] 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> [d] 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> [a,b] 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> [b,c] 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> [c,d] 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> [a,b,c] 
</span>
</span> , 
<span class="verb">
<span class="cmtt-10"> [b,c,d] 
</span>
</span> , and 
<span class="verb">
<span class="cmtt-10"> [a,b,c,d] 
</span>
</span> . A little thought reveals that the sublists of a list L are simply the 
<span class="cmti-10"> prefixes of suffixes of 
</span> L. Think about it pictorially: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="quote">
<!--l. 335-->
<p class="noindent"> Take suffix: 
<span class="fbox">
<span class="cmmi-10"> a,b,c,d,e,f,g, 
</span>
<img alt="h,i,j,k,l,m, n,o,p ◟------◝◜------◞" src="html/lpn-html1x.png"/>
</span>
<br class="newline"/> Take prefix:       
<span class="fbox">
<img alt="h,i,j,k,l ◟ ◝◜ ◞" src="html/lpn-html2x.png"/>
<span class="cmmi-10"> ,m,n,o,p 
</span>
</span>
<br class="newline"/> Result:       
<span class="fbox">
<span class="cmmi-10"> h,i,j,k,l 
</span>
</span>
</p>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="indent"> As we already have defined the predicates for producing suffixes and prefixes of lists, we simply define a sublist as: 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="fancyvrb" id="fancyvrb291">
<a id="x40-55094r1">
</a>
<span class="cmtt-10">   
</span>
<span class="cmtt-10">  sublist(SubL,L):- 
</span>
<span class="cmtt-10">  suffix(S,L), 
</span>
<span class="cmtt-10">  prefix(SubL,S). 
</span>
</div>
</div>
<div class="nb-cell html" name="htm1">
<p class="noindent"> That is, 
<span class="verb">
<span class="cmtt-10"> SubL 
</span>
</span> is a sublist of 
<span class="verb">
<span class="cmtt-10"> L 
</span>
</span> if there is some suffix 
<span class="verb">
<span class="cmtt-10"> S 
</span>
</span> of 
<span class="verb">
<span class="cmtt-10"> L 
</span>
</span> of which 
<span class="verb">
<span class="cmtt-10"> SubL 
</span>
</span> is a prefix. This program doesn’t 
<span class="cmti-10"> explicitly 
</span> use 
<span class="verb">
<span class="cmtt-10"> append/3 
</span>
</span> , but of course, under the surface, that’s what’s doing the work for us, as both 
<span class="verb">
<span class="cmtt-10"> prefix/2 
</span>
</span> and 
<span class="verb">
<span class="cmtt-10"> suffix/2 
</span>
</span> are defined using 
<span class="verb">
<span class="cmtt-10"> append/3 
</span>
</span> . 
</p>
</div>
<div class="nb-cell html" name="htm1">
<div class="crosslinks">
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse25"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse24"> front 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch6"> up 
</a> ] 
</p>
</div>
</div>
</div>
